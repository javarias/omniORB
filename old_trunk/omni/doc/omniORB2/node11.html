<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!Converted with LaTeX2HTML 95 (Thu Jan 19 1995) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds >
<HEAD>
<TITLE> Dynamic Management of Any Values</TITLE>
</HEAD>
<BODY>
<meta name="description" value=" Dynamic Management of Any Values">
<meta name="keywords" value="omniORB2">
<meta name="resource-type" value="document">
<meta name="distribution" value="global">
<P>
 <BR> <HR><A NAME=tex2html341 HREF="node12.html"><IMG ALIGN=BOTTOM ALT="next" SRC="http://www.uk.research.att.com/latex2html/icons/next_motif.gif"></A>   <A NAME=tex2html339 HREF="omniORB2.html"><IMG ALIGN=BOTTOM ALT="up" SRC="http://www.uk.research.att.com/latex2html/icons/up_motif.gif"></A>   <A NAME=tex2html333 HREF="node10.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="http://www.uk.research.att.com/latex2html/icons/previous_motif.gif"></A>   <A NAME=tex2html343 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="http://www.uk.research.att.com/latex2html/icons/contents_motif.gif"></A>      <BR>
<B> Next:</B> <A NAME=tex2html342 HREF="node12.html"> The Dynamic Invocation </A>
<B>Up:</B> <A NAME=tex2html340 HREF="omniORB2.html">No Title</A>
<B> Previous:</B> <A NAME=tex2html334 HREF="node10.html"> Type Any and </A>
<BR> <HR> <P>
<H1><A NAME=SECTION001100000000000000000> Dynamic Management of Any Values</A></H1>
<P>

<P>
In CORBA specification 2.2, a new facility- <b> DynAny</b> is
introduced. Previously, it is not possible to insert or extract constructed
and other complex types from an <b> any</b> without using the stub code
generated by an idl compiler for these types. This makes it impossible to
write generic servers (bridges, event channels supporting filtering etc)
because these servers can not have static knowledge of all the possible data
types that they have to handle.
<P>
To fill this gap, the <b> DynAny</b> facility is defined to enable traversal
of the data value associated with an <b> any</b> at runtime and extraction of
its constituents. This facility also enables the construction of an <b>
any</b> at runtime, without having static knowledge of its types.
<P>
This chapter explains how <b> DynAny</b> may be used. For completeness, you
should also read the DynAny specification defined in Chapter 7 of the CORBA
specification 2.2. Where possible, the implementation in omniORB2 adheres
closely to the specification. However, there are areas in the specification
that are ambiguous or lacking in details. A number of these issues are
currently opened with the ORB revision task force. Until the issues are
resolved, it is possible that a different implementation may choose to
intepret the specification differently. This chapter provides
clarifications to the specification, explains the interpretation used and
offers some advice and warnings on potential portability problems.
<P>
Notice that the <b> DynAny</b> interface has been changed in CORBA 2.3,
particularly with the addition of the support for the IDL type <tt> valuetype</tt>.
Future releases of omniORB will be updated to implement the interface as
defined in CORBA 2.3.
<P>
<H1><A NAME=SECTION001110000000000000000> C++ mapping</A></H1>
<P>

<PRE>  // namespace CORBA

  class ORB {
  public:
    ...

    class InconsistentTypeCode : public UserException { ... };

    DynAny_ptr create_dyn_any(const Any&amp; value);

    DynAny_ptr create_basic_dyn_any(TypeCode_ptr tc);

    DynStruct_ptr create_dyn_struct(TypeCode_ptr tc);

    DynSequence_ptr create_dyn_sequence(TypeCode_ptr tc);

    DynArray_ptr create_dyn_array(TypeCode_ptr tc);

    DynUnion_ptr create_dyn_union(TypeCode_ptr tc);

    DynEnum_ptr create_dyn_enum(TypeCode_ptr tc);

  };

  typedef DynAny* DynAny_ptr;
  class DynAny_var { ... };

  class DynAny {
  public:    

    class Invalid : public UserException { ... };
    class InvalidValue : public UserException { ... };
    class TypeMismatch : public UserException { ... };
    class InvalidSeq : public UserException { ... };

    typedef _CORBA_Unbounded_Sequence__Octet OctetSeq;

    TypeCode_ptr type() const;

    void assign(DynAny_ptr dyn_any) throw(Invalid,SystemException);
    void from_any(const Any&amp; value) throw(Invalid,SystemException);
    Any* to_any() throw(Invalid,SystemException);
    void destroy();
    DynAny_ptr copy();

    DynAny_ptr current_component();
    Boolean next();
    Boolean seek(Long index);
    void rewind();

    void insert_boolean(Boolean value) throw(InvalidValue,SystemException);
    void insert_octet(Octet value) throw(InvalidValue,SystemException);
    void insert_char(Char value) throw(InvalidValue,SystemException);
    void insert_short(Short value) throw(InvalidValue,SystemException);
    void insert_ushort(UShort value) throw(InvalidValue,SystemException);
    void insert_long(Long value) throw(InvalidValue,SystemException);
    void insert_ulong(ULong value) throw(InvalidValue,SystemException);
    void insert_float(Float value) throw(InvalidValue,SystemException);
    void insert_double(Double value) throw(InvalidValue,SystemException);
    void insert_string(const char* value) throw(InvalidValue,SystemException);
    void insert_reference(Object_ptr v) throw(InvalidValue,SystemException);
    void insert_typecode(TypeCode_ptr v) throw(InvalidValue,SystemException);
    void insert_any(const Any&amp; value) throw(InvalidValue,SystemException);

    Boolean get_boolean() throw(TypeMismatch,SystemException);
    Octet get_octet() throw(TypeMismatch,SystemException);
    Char get_char() throw(TypeMismatch,SystemException);
    Short get_short() throw(TypeMismatch,SystemException);
    UShort get_ushort() throw(TypeMismatch,SystemException);
    Long get_long() throw(TypeMismatch,SystemException);
    ULong get_ulong() throw(TypeMismatch,SystemException);
    Float get_float() throw(TypeMismatch,SystemException);
    Double get_double() throw(TypeMismatch,SystemException);
    char* get_string() throw(TypeMismatch,SystemException);
    Object_ptr get_reference() throw(TypeMismatch,SystemException);
    TypeCode_ptr get_typecode() throw(TypeMismatch,SystemException);
    Any* get_any() throw(TypeMismatch,SystemException);

    static DynAny_ptr _duplicate(DynAny_ptr);
    static DynAny_ptr _narrow(DynAny_ptr);
    static DynAny_ptr _nil();
  };

  // DynFixed is not supported.

  typedef DynEnum* DynEnum_ptr;
  class DynEnum_var { ... };

  class DynEnum :  public DynAny {
  public:

    char* value_as_string();
    void value_as_string(const char* value);
    ULong value_as_ulong();
    void value_as_ulong(ULong value);

    static DynEnum_ptr _duplicate(DynEnum_ptr);
    static DynEnum_ptr _narrow(DynAny_ptr);
    static DynEnum_ptr _nil();
  };

  typedef char* FieldName;
  typedef String_var FieldName_var;

  struct NameValuePair {
    String_member id;
    Any value;
  };

  typedef _CORBA_ConstrType_Variable_Var&lt;NameValuePair&gt; NameValuePair_var;
  typedef _CORBA_Unbounded_Sequence&lt;NameValuePair &gt; NameValuePairSeq;

  typedef DynStruct* DynStruct_ptr;
  class DynStruct_var { ... };

  class DynStruct :  public DynAny {
  public:

    char*  current_member_name();
    TCKind current_member_kind();
    NameValuePairSeq* get_members();
    void set_members(const NameValuePairSeq&amp; NVSeqVal)
                     throw(InvalidSeq,SystemException);

    static DynStruct_ptr _duplicate(DynStruct_ptr);
    static DynStruct_ptr _narrow(DynAny_ptr);
    static DynStruct_ptr _nil();
  };

  typedef DynUnion* DynUnion_ptr;
  class DynUnion_var { ... };

  class DynUnion :  public DynAny {
  public:

    Boolean set_as_default();
    void set_as_default(Boolean value);
    DynAny_ptr discriminator();
    TCKind discriminator_kind();
    DynAny_ptr member();
    char*  member_name();
    void member_name(const char* value);
    TCKind member_kind();

    static DynUnion_ptr _duplicate(DynUnion_ptr);
    static DynUnion_ptr _narrow(DynAny_ptr);
    static DynUnion_ptr _nil();
  };

  typedef _CORBA_Unbounded_Sequence&lt;Any &gt; AnySeq;

  typedef DynSequence* DynSequence_ptr;
  class DynSequence_var { ... };

  class DynSequence :  public DynAny {
  public:

    ULong length();
    void length (ULong value);
    AnySeq* get_elements();
    void set_elements(const AnySeq&amp; value) throw(InvalidValue,SystemException);

    static DynSequence_ptr _duplicate(DynSequence_ptr);
    static DynSequence_ptr _narrow(DynAny_ptr);
    static DynSequence_ptr _nil();
  };

  typedef DynArray* DynArray_ptr;
  class DynArray_var { ... };

  class DynArray : public DynAny {
  public:

    AnySeq* get_elements();
    void set_elements(const AnySeq&amp; value) throw(InvalidValue,SystemException);

    static DynArray_ptr _duplicate(DynArray_ptr);
    static DynArray_ptr _narrow(DynAny_ptr);
    static DynArray_ptr _nil();
  };
</PRE>

<P>
<H1><A NAME=SECTION001120000000000000000> The DynAny Interface</A></H1>
<P>
<A NAME=dynany>&#160;</A>
<P>
<H2><A NAME=SECTION001121000000000000000> Example: extract data values from an Any</A></H2>
<P>
If an <b> any</b> contains a value of one of the basic data types, its value
can be extracted using the pre-defined operators in the Any interface. When
the value is a struct or other non-basic types, one can use the DynAny
interface to extract its constituent values.
<P>
In this section, we use a struct as an example to illustrate how the DynAny
interface can be used.
<P>
The example struct is as follows:
<P>

<PRE>    // IDL
    
    struct exampleStruct1 {
      string s;
      double d;
      long   l;
    };
</PRE>

<P>
To <b> create</b> a DynAny from an Any value, one uses the <tt> create_dyn_any</tt>
method:
<P>

<PRE>    // C++
    
    CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
    
    Any v;
    ...       // Initialise v to contain a value of type exampleStruct1.
    
    CORBA::DynAny_var dv = orb-&gt;create_dyn_any(v);
</PRE>

<P>
Like CORBA object and pseudo object references, a <tt> DynAny_ptr</tt> can be
managed by a _var type (<tt> DynAny_var</tt>) which will release the <tt>
DynAny_ptr</tt> automatically when the variable goes out of scope.
<P>
<H3><A NAME=SECTION001121100000000000000> Iterate through the components</A></H3>
<P>
<A NAME=dynanyiterate>&#160;</A>
<P>
Once the DynAny object is created, we can use the
DynAny interface to extract the individual components in <tt>
exampleStruct1</tt>. The DynAny interface provides a number of
functions to extract and insert component values. These functions are
defined to operate on the component identified by the <b> current
component</b> pointer.
<P>
A <b> current component</b> pointer is an internal state of a DynAny object.  
When a DynAny object is created, the pointer is initialised to point to the
first component of the any value.
<P>
The pointer can be advanced to the next component with the <tt> next()</tt>
operation. The function returns FALSE (0) if there are no more components.
Otherwise it returns TRUE (1). When the any value in the DynAny object
contains only one component, the <tt> next()</tt> operation always returns
FALSE(0).
<P>
Another way of adjusting the pointer is the <tt> seek()</tt> operation. The
function returns FALSE (0) if there is no component at the specified
index. Otherwise it returns TRUE (1). The index value of the first
component is zero. Therefore, a <tt> seek(0)</tt> call rewinds the pointer to
the first component, this is also equivalent to a call to the <tt>
rewind()</tt> operation.
<P>
For completeness, we should also mention here the <tt>
current_component()</tt> operation. This operation causes the DynAny object to
return a reference to another DynAny object that can be used to access the
current component. It is possible that the current component pointer is not
pointing to a valid component, for instance, the <tt> next()</tt> operation has
been invoked and there is no more component. Under this circumstance, the <tt>
current_component()</tt> operation returns a nil DynAny object
reference<A NAME=tex2html21 HREF="footnode.html#1275"><IMG ALIGN=BOTTOM ALT="gif" SRC="http://www.uk.research.att.com/latex2html/icons/foot_motif.gif"></A>. For components which are just
basic data types, calling <tt> current_component()</tt> is an overkill because
we can just use the basic type extraction and insertion functions directly.
<P>
<H3><A NAME=SECTION001121200000000000000> Extract basic type components</A></H3>
<P>
In our example, the component values can be extracted as follows:
<P>

<PRE>    CORBA::String_var s = dv-&gt;get_string();
    CORBA::Double     d = dv-&gt;get_double();
    CORBA::Long       l = dv-&gt;get_long();
</PRE>

<P>
Each get basic type operation has the side-effect of advancing the current
component pointer. For instance:
<P>

<PRE>    CORBA::String_var s = dv-&gt;get_string();
</PRE>

<P>
is equivalent to:
<P>

<PRE>    CORBA::DynAny_var temp = dv-&gt;current_component();
    CORBA::String_var s = temp-&gt;get_string();
    dv-&gt;next();
</PRE>

<P>
The get operations ensure that the current component is of the same type as
requested. Otherwise, the object throws a TypeMismatch exception. If the
current component pointer is invalid when a get operation is called, the
object also throws a TypeMismatch exception<A NAME=tex2html22 HREF="footnode.html#869"><IMG ALIGN=BOTTOM ALT="gif" SRC="http://www.uk.research.att.com/latex2html/icons/foot_motif.gif"></A>.
<P>
To repeatedly access the components, one can use the <tt> rewind()</tt> or <tt>
seek()</tt> operation to manipulate the current component pointer. For
instance, to access the <tt> d</tt> member in <tt> exampleStruct1</tt> directly:
<P>

<PRE>    dv-&gt;seek(1);          // position current component to member d.
    CORBA::Double     d = dv-&gt;get_double();
</PRE>

<P>
<H3><A NAME=SECTION001121300000000000000> Extract complex components</A></H3>
<P>
When a component is not one of the basic data types, it is not possible to
extract its value using the get operations. Instead, a DynAny object has to
be created from which the component is accessed.
<P>
Consider this example:
<P>

<PRE>    // IDL
    
    struct exampleStruct2 {
      string m1;
      exampleStruct1 m2;
    };
</PRE>

<P>
In order to extract the data members within <tt> m2</tt> (of type 
<tt> exampleStruct1</tt>), we use <tt> current_component()</tt> as follows:
<P>

<PRE>    // C++
    
    CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
    Any v;
    ...       // Initialise v to contain a value of type exampleStruct2.
    
    CORBA::DynAny_var dv = orb-&gt;create_dyn_any(v);
    
    CORBA::String_var m1 = dv-&gt;get_string();  // extract member m1
    CORBA::DynAny_var dm = dv-&gt;current_component(); // DynAny reference to m2
    CORBA::String_var s = dm-&gt;get_string();   // m2.s
    CORBA::Double     d = dm-&gt;get_double();   // m2.d
    CORBA::Long       l = dm-&gt;get_long();     // m2.l
</PRE>

<P>
<H3><A NAME=SECTION001121400000000000000> Clean-up</A></H3>
<P>
Now we finish off this example with a description on destroying DynAny
objects. There are two points to remember:
<P>
<OL><LI> A DynAny reference (<tt> DynAny_ptr</tt>) is like any CORBA object or
psuedo object reference and should be handled in the same way. In
particular, one has to call the <tt> CORBA::release</tt> operation to indicate
that a DynAny reference will no longer be accessed. In the example, this is
done automatically by <tt> DynAny_var</tt>.
<LI> A DynAny object and its references are separate entities, just as a
CORBA object implementation and its object references are different
entities. While <tt> CORBA::release</tt> will release any resource associated
with a <tt> DynAny_ptr</tt>, one has to separately destroy the DynAny object
to avoid any memory leak. This is done by calling the <tt> destroy()</tt>
operation.
</OL>
<P>
In the example, the DynAny object can be destroyed as follows:
<P>

<PRE>    // C++
    ...
    CORBA::DynAny_var dv = orb-&gt;create_dyn_any(v);
    ...
    dv-&gt;destroy();
    
    // From now on, one should not invoke any operation in dv. Otherwise the
    // behavior is undefined.
</PRE>

<P>
<H2><A NAME=SECTION001122000000000000000> Example: insert data values into an Any</A></H2>
<P>
Using the DynAny interface, one can create an Any value from scratch.  In
this example, we are going to create an Any containing the value of the
<tt> exampleStruct1</tt> type.
<P>
Firstly, we have to create a DynAny to store the value using one of the
<tt> create_dyn</tt> functions. Because <tt> exampleStruct1</tt> is a struct type, we
use the <tt> create_dyn_struct()</tt> operation.
<P>

<PRE>    // C++
    
    CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
    
    // create the TypeCode for exampleStruct.
    StructMemberSeq tc_members;
    tc_members.length(3);
    tc_members[0].name = (const char*)&quot;s&quot;;
    tc_members[0].type = CORBA::TypeCode::_duplicate(CORBA::_tc_string);
    tc_members[0].type_def = CORBA::IDLType::_nil();
    tc_members[1].name = (const char*)&quot;d&quot;;
    tc_members[1].type = CORBA::TypeCode::_duplicate(CORBA::_tc_double);
    tc_members[1].type_def = CORBA::IDLType::_nil();
    tc_members[2].name = (const char*)&quot;l&quot;;
    tc_members[2].type = CORBA::TypeCode::_duplicate(CORBA::_tc_long);
    tc_members[2].type_def = CORBA::IDLType::_nil();
    CORBA::TypeCode_var tc = orb-&gt;create_struct_tc(&quot;IDL:exampleStruct1:1.0&quot;,
                                                   &quot;exampleStruct1&quot;,
                                                   tc_members);
    
    // create the DynAny object to represent the any value
    CORBA::DynAny_var dv = orb-&gt;create_dyn_struct(tc);
</PRE>

<P>
<H3><A NAME=SECTION001122100000000000000> Insert basic type components</A></H3>
<P>
Once the DynAny object is created, we can use the DynAny interface to
insert the components. The DynAny interface provides a number of insert
operations to insert basic types into the any value. In our example, the
component values can be inserted as follows:
<P>

<PRE>    CORBA::String_var s = (const char*)&quot;Hello&quot;;
    CORBA::Double     d = 3.1416;
    CORBA::Long       l = 1;
    
    dv-&gt;insert_string(s);
    dv-&gt;insert_double(d);
    dv-&gt;insert_long(l);
</PRE>

<P>
Each insert basic type operation has the side-effect of advancing the
current component pointer. For instance:
<P>

<PRE>    dv-&gt;insert_string(s);
</PRE>

<P>
is equivalent to:
<P>

<PRE>    CORBA::DynAny_var temp = dv-&gt;current_component();
    temp-&gt;insert_string(s);
    dv-&gt;next();
</PRE>

<P>
The insert operations ensure that the current component is of the same type
as the inserted value. Otherwise, the object throws a InvalidValue
exception. If the current component pointer is invalid when an insert operation
is called, the object also throws a InvalidValue exception<A NAME=tex2html23 HREF="footnode.html#901"><IMG ALIGN=BOTTOM ALT="gif" SRC="http://www.uk.research.att.com/latex2html/icons/foot_motif.gif"></A>.
<P>
Sometimes, one may just want to modify one component in an Any value. For
instance, one may just want to change the value of the double member in
<tt> exampleStruct1</tt>. This can be done as follows:
<P>

<PRE>    // C++
    
    CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
    
    Any v;
    ...       // Initialise v to contain a value of type exampleStruct1.
    
    CORBA::Double d = 6.28;
    
    CORBA::DynAny_var dv = orb-&gt;create_dyn_any(v);
    
    dv-&gt;seek(1);
    dv-&gt;insert_double(d);    // Change the value of the member d.
</PRE>

<P>
Finally, the any value can be obtained from the DynAny object using the
<tt> to_any()</tt> operation:
<P>

<PRE>    CORBA::Any_var v = dv-&gt;to_any();    // Obtain the any value.
</PRE>

<P>
<H3><A NAME=SECTION001122200000000000000> Insert complex components</A></H3>
<P>
When a component is not one of the basic data types, it is not possible to
insert its value using the insert operations. Instead, a DynAny object has
to be created through which the component can be inserted.
<P>
In our example, one can insert component values into <tt> exampleStruct2</tt> as
follows:
<P>

<PRE>    // C++
    
    CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
    
    CORBA::TypeCode_var tc;
    // create the TypeCode for exampleStruct2.
    ...
    // create the DynAny object to represent the any value
    CORBA::DynAny_var dv = orb-&gt;create_dyn_struct(tc);
    
    CORBA::String_var m1  = (const char*)&quot;Greetings&quot;;
    CORBA::String_var m2s = (const char*)&quot;Hello&quot;;
    CORBA::Double     m2d = 3.1416;
    CORBA::Long       m2l = 1;
    
    dv-&gt;insert_string(m1);   // insert member m1
    CORBA::DynAny_var dm = dv-&gt;current_component(); // DynAny reference to m2
    dm-&gt;insert_string(m2s);  // insert member m2.s
    dm-&gt;insert_double(m2d);  // insert member m2.d
    dm-&gt;insert_long(m2l);    // insert member m2.l
    
    CORBA::Any_var v = dv-&gt;to_any();  // obtain the any value
    
    dv-&gt;destroy();          // destroy the DynAny object.
                            // No operation should be invoked on dv
                            // from this point on except CORBA::release.
</PRE>

<P>
In addition to the DynAny interface, a number of derived interfaces are
defined. These interfaces are specialisation of the DynAny interface to
facilitate the handling of any values containing non-basic types: struct,
sequence, array, enum and union<A NAME=tex2html24 HREF="footnode.html#909"><IMG ALIGN=BOTTOM ALT="gif" SRC="http://www.uk.research.att.com/latex2html/icons/foot_motif.gif"></A>. The next few sections will provide more
details on these interfaces.
<P>
<H1><A NAME=SECTION001130000000000000000> The DynStruct Interface</A></H1>
<P>
When a DynAny object is created through the <tt> create_dyn_any()</tt>
operation and the any value contains a struct type, a DynStruct object is
created. The DynAny reference returned can be narrowed to a DynStruct
reference using the <tt> CORBA::DynStruct::_narrow()</tt> operation.
<P>
In the previous example, the components are extracted using the get
operations. Alternatively, the DynStruct interface provides an addition
operation (<tt> get_members()</tt>) to return all the components in a single
call. The returned value is a sequence of name value pair. The member name
is given in the name field and its value is returned as an Any value.
For example, an alternative way to extract the components in the previous
example is as follows:
<P>

<PRE>    // C++
    
    CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
    Any v;
    ...       // Initialise v to contain a value of type exampleStruct1.
    CORBA::DynAny_var dv = orb-&gt;create_dyn_any(v);
    
    CORBA::DynStruct_var ds = CORBA::DynStruct::_narrow(dv);
    
    CORBA::NameValuePairSeq* sq = ds-&gt;get_members();
    
    char*         s;
    CORBA::Double d;
    CORBA::Long   l;
    
    (*sq)[0].value &gt;&gt;= s;        // 1st element contains member s
    (*sq)[1].value &gt;&gt;= d;        // 2nd element contains member d
    (*sq)[2].value &gt;&gt;= l;        // 3rd element contains member l
</PRE>

<P>
Similarly, the DynStruct interface provides an addition operation (<tt>
set_members()</tt>) to insert all the components in a single call. The
following is an alternative way to insert the components of the type
<tt> exampleStruct1</tt> into an Any value:
<P>

<PRE>    // C++
    
    CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
    
    CORBA::TypeCode_var tc;
    // create the TypeCode for exampleStruct1.
    ...
    // create the DynAny object to represent the any value
    CORBA::DynAny_var dv = orb-&gt;create_dyn_struct(tc);
    
    CORBA::String_var s = (const char*)&quot;Hello&quot;;
    CORBA::Double     d = 3.1416;
    CORBA::Long       l = 1;
    
    CORBA::NameValuePairSeq sq;
    sq.length(3);
    sq[0].id = (const char*)&quot;s&quot;;
    sq[0].value &lt;&lt;= CORBA::Any::from_string(s,0); 
                                    // 1st element contains member s
    sq[1].id = (const char*)&quot;d&quot;;
    sq[1].value &lt;&lt;= d;             // 2nd element contains member d
    sq[2].id = (const char*)&quot;l&quot;;
    sq[2].value &lt;&lt;= l;             // 3rd element contains member l
    
    dv-&gt;set_members(sq);
</PRE>

<P>
Notice that the name-value pairs in the argument to <tt> set_members()</tt>
must match the members of the struct exactly or the object would throw the
InvalidSeq exception.
<P>
In addition to the <tt> current_component()</tt> operation, the DynStruct
interface provides two operations: <tt> current_member_name()</tt> and <tt>
current_member_kind()</tt>, to return information about the current
component.
<P>
<H1><A NAME=SECTION001140000000000000000> The DynSequence Interface</A></H1>
<P>
Like struct values, sequence values can be traversed using the operations
introduced in section <A HREF="node11.html#dynany">10.2</A>. The first sequence element can be
accessed as the first DynAny component, the second sequence element as the
second DynAny component and so on.
<P>
To extract component values from an Any containing a sequence, the length
of the sequence can be obtained using the get length operation in the
DynSequence interface. Here is an example to extract the components of a
sequence of long:
<P>

<PRE>    // C++
    
    CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
    Any v;
    ...       // Initialise v to contain a value of a sequence of long
    CORBA::DynAny_var dv = orb-&gt;create_dyn_any(v);
    
    CORBA::DynSequence_var ds = CORBA::DynSequence::_narrow(dv);
    CORBA::ULong len = ds-&gt;length();     // extract the length of the sequence
    CORBA::ULong index;
    for (index = 0; index &lt; len; index++) {
      CORBA::Long v = ds-&gt;get_long();
      cerr &lt;&lt; &quot;[&quot; &lt;&lt; index &lt;&lt; &quot;] = &quot; &lt;&lt; v &lt;&lt; endl;
    }
</PRE>

<P>
Conversely, the set length operation is provided to set the length of the
sequence. Here is an example to insert the components of a sequence of
long:
<P>

<PRE>    // C++
    
    CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
    
    CORBA::TypeCode_var tc;
    // create the TypeCode for a sequence of long.
    ...
    // create the DynAny object to represent the any value
    CORBA::DynSequence_var ds = orb-&gt;create_dyn_sequence(tc);
    
    CORBA::ULong len = 3;
    
    ds-&gt;length(len);             // set the length of the sequence
    
    CORBA::ULong index;
    for (index = 0; index &lt; len; index++) {
      ds-&gt;insert_long(index);    // insert a sequence element
    }
</PRE>

<P>
Similar to the DynStruct interface, the <tt> get_elements()</tt> operation is
provided to return all the sequence elements and the <tt> set_elements()</tt>
operation is provided to insert all the sequence elements.
<P>
<H1><A NAME=SECTION001150000000000000000> The DynArray Interface</A></H1>
<P>
Array values are handled by the DynArray interface. The DynArray interface
is the same as the DynSequence interface except that the former does not
provide the set length and get length operations.
<P>
<H1><A NAME=SECTION001160000000000000000> The DynEnum Interface</A></H1>
<P>
Enum values are handled by the DynEnum interface. A DynEnum object contains
a single component which is the enum value. This value cannot be
extracted or inserted using the get and insert operations of the DynAny
interface. Instead, two pairs of operations are provided to handle this
value.
<P>
The <tt> value_as_string</tt> operations allow the enum value to be
extracted or inserted as a string. The <tt> value_as_ulong</tt> operations
allow the enum value to be extracted or inserted as an unsigned long.
<P>
<H1><A NAME=SECTION001170000000000000000> The DynUnion Interface</A></H1>
<P>
Union values are handled by the DynUnion interface. Unfortunately, the
CORBA 2.2 specification does not define the DynUnion interface in sufficent
details to nail down its intended usage<A NAME=tex2html25 HREF="footnode.html#933"><IMG ALIGN=BOTTOM ALT="gif" SRC="http://www.uk.research.att.com/latex2html/icons/foot_motif.gif"></A>. In this
section, we try to fill in the gaps and describe a sensible way to use the
DynUnion interface. Where necessary, the semantics of the operations is
clarified. It is possible that the behavior of this interface in another
ORB is different from this implmentation. Where appropriate, we give
warnings on usage that might cause problems with portability.
<P>
In relation to the current component pointer (<A HREF="node11.html#dynanyiterate">10.2.1.1</A>), a
DynUnion object contains two components. The first component (with the
index value equals 0) is the discriminator value, the second one is the
member value.  Therefore, one can use the <tt> seek()</tt> and <tt>
current_component()</tt> operations to obtain a reference to the DynAny
objects that handle the two components. However, it is better to use the
operations defined in the DynUnion interface to manipulate these components
as the semantics of the operations is easier to understand.
<P>
<H2><A NAME=SECTION001171000000000000000> Three Categories of Union</A></H2>
<P>
<A NAME=dynunioncat>&#160;</A>
<P>
Before we continue, it is important to understand that unions can be
classified into the following categories:
<P>
<OL><LI> One that has a default branch defined in the IDL. This will be called
<b> explicit default union</b> in the rest of this section.
<LI> One that has no default branch and not all the possible values of the
discriminator type are covered by the branch labels in the IDL. This will
be called <b> implicit default union</b>.
<LI> One that has no default branch but all the possible values of the
discriminator type are covered. This will be called <b> no default union</b>.
</OL>
<P>
Of the three categories, the implicit default union is interesting because
by definition if the discriminator value is not equal to any of the branch
labels, the union has <b> no</b> member. That is, the union value consists
solely of the discriminator value.
<P>
<H2><A NAME=SECTION001172000000000000000> Example: extract data values from a union</A></H2>
<P>
<H3><A NAME=SECTION001172100000000000000> Explicit default union</A></H3>
<P>
Consider a union of the following type:
<P>

<PRE>    // IDL
    
    union exampleUnion1 switch(boolean) {
    case TRUE: long l;
    default:   double d; 
    };
</PRE>

<P>
The most straightforward way to extract the member value is as follows:
<P>

<PRE>    // C++
    
    CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
    
    Any v;
    ...       // Initialise v to contain a value of type exampleUnion1.
    
    CORBA::DynAny_var dv = orb-&gt;create_dyn_any(v);
    CORBA::DynUnion_var du = CORBA::DynUnion::_narrow(dv);
    
    CORBA::String_var di = du-&gt;member_name();
    CORBA::DynAny_var dm = du-&gt;member();
    
    if (strcmp((const char*)di,&quot;l&quot;) == 0) {
      // branch label is TRUE
      CORBA::Long v = dm-&gt;get_long();
      cerr &lt;&lt; &quot;l = &quot; &lt;&lt; v &lt;&lt; endl;
    }
    
    if (strcmp((const char*)di,&quot;d&quot;) == 0) {
      // Is default branch
      CORBA::Double v = dm-&gt;get_double();
      cerr &lt;&lt; &quot;d = &quot; &lt;&lt; v &lt;&lt; endl;
    }
</PRE>

<P>
In the example, the operation <tt> member_name()</tt> is used to determine
which branch the union has been instantiated. The operation <tt> member()</tt>
is used to obtain a reference to the DynAny object that handles the member.
<P>
Alternatively, the branch can be determined by reading the discriminator
value:
<P>

<PRE>    // C++
    
    CORBA::DynAny_var di = du-&gt;discriminator();
    CORBA::DynAny_var dm = du-&gt;member();
    
    CORBA::Boolean di_v = di-&gt;get_boolean();
    
    switch (di_v) {
    case 1:
      CORBA::Long v = dm-&gt;get_long();
      cerr &lt;&lt; &quot;l = &quot; &lt;&lt; v &lt;&lt; endl;
      break;
    default:
      CORBA::Double v = dm-&gt;get_double();
      cerr &lt;&lt; &quot;d = &quot; &lt;&lt; v &lt;&lt; endl;
    }
</PRE>

<P>
The operation <tt> discriminator()</tt> is used to obtain the value of the
discriminator.
<P>
Finally, the third way to determine the branch is to test if the default is
selected:
<P>

<PRE>    // C++
    
    switch (dv-&gt;set_as_default()) {
    case 1:
      CORBA::Double v = dm-&gt;get_double();
      cerr &lt;&lt; &quot;d = &quot; &lt;&lt; v &lt;&lt; endl;
      break;
    default:
      CORBA::Long v = dm-&gt;get_long();
      cerr &lt;&lt; &quot;l = &quot; &lt;&lt; v &lt;&lt; endl;
    }
</PRE>

<P>
The operation <tt> set_as_default()</tt> returns TRUE (1) if the
discriminator has been assigned a valid default value.
<P>
<H3><A NAME=SECTION001172200000000000000> Implicit default union</A></H3>
<P>
Consider a union of the following type:
<P>

<PRE>    // IDL
    
    union exampleUnion2 switch(long) {
    case 1: long l;
    case 2: double d; 
    };
</PRE>

<P>
This example is similar to the previous one but there is no default branch.
The description above also applies to this example. However, the
discriminator may be set to neither 1 nor 2. Under this condition, the
implicit default is selected and the union value contains the discriminator
only!
<P>
When the discriminator contains an implicit default value, one might ask
what is the value returned by the <tt> member_name()</tt> and <tt> member()</tt>
operation. Since there is no member in the union value, omniORB2 returns a
null string and a nil DynAny reference respectively. This behavior is not
specified in the CORBA 2.2 specification. To ensure that your application
is portable, it is best to avoid calling these operations when the DynUnion
object might contain an implicit default value.
<P>
<H3><A NAME=SECTION001172300000000000000> No default union</A></H3>
<P>
This is the last union category. For instance:
<P>

<PRE>    // IDL
    
    union exampleUnion3 switch(boolean) {
    case TRUE: long l;
    case FALSE: double d; 
    };
</PRE>

<P>
In this example, all the possible values of the discriminator are used as
union labels. There is no default branch. The only difference between this
category and the explicit default union is that the <tt>
set_as_default()</tt> operation always returns FALSE (0).
<P>
<H2><A NAME=SECTION001173000000000000000> Example: insert data values into a union</A></H2>
<P>
Writing into a union involves selecting the union branch with the
appropriate discriminator value and then writing the member value.
There are three ways to set the discriminator value:
<P>
<OL><LI> Use the <tt> member_name()</tt> write operation to specify the union
branch by specifying the union member directly. This operation has the side
effect of setting the discriminator to the label value of the
branch.
<LI> Write the label value of a union branch into the DynAny
object that handles the discriminator.
<LI> If the union has a default branch, either explicitly or implicitly,
use the <tt> set_as_default()</tt> write operation to set the discriminator
to a valid default value.
</OL>
<P>
The following example shows the three ways of writing into a union:
<P>

<PRE>    // C++
    
    CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
    
    CORBA::TypeCode_var tc;
    // create the TypeCode for exampleUnion1.
    ...
    // create the DynAny object to represent the any value
    CORBA::DynUnion_var dv = orb-&gt;create_dyn_union(tc);
    
    CORBA::Any_var v;
    DynAny_ptr dm;
    
    // Use member_name to select the union branch
    dv-&gt;member_name(&quot;l&quot;);
    dm = dv-&gt;member();
    dm-&gt;insert_long(10);
    v = dv-&gt;to_any();          // transfer to an Any
    CORBA::release(dm);
    
    // Setting the discriminator value to select the union branch
    CORBA::DynAny_var di = dv-&gt;discriminator();
    di-&gt;insert_boolean(1);     // set discriminator to label TRUE
    dm = dv-&gt;member();
    dm-&gt;insert_long(20);
    v = dv-&gt;to_any();          // transfer to an Any
    CORBA::release(dm);
    
    // Use set_as_default to select the default union branch
    dv-&gt;set_as_default(1);
    dm = dv-&gt;member();
    dm-&gt;insert_double(3.14);
    v = dv-&gt;to_any();          // transfer to an Any
    CORBA::release(dm);
    
    dv-&gt;destroy();
</PRE>

<P>
<H3><A NAME=SECTION001173100000000000000> Ambiguous usage</A></H3>
<P>
<OL><LI> When the discriminator is set to a different value, a different
member branch is selected. Suppose the application has previously obtained
a DynAny reference to a union member when it changes the discriminator
value. As a result of the value change, the union is now instantiated to
another union branch, i.e. a call to the <tt> member()</tt> operation will now
return a reference to a different DynAny object. If the application
continues to access the DynAny object of the old union member, the behavior
of the ORB under this condition is not defined by the CORBA 2.2
specification. With omniORB2, the DynAny object of the old union member is
detached from the union when a new union branch is selected. Therefore
reading or writing this object will not have any relation to the current
value of the union. To avoid this ambiguity, the reference to the old union
member should be released before a different union branch is selected.
<P>
<LI> The write operation <tt> set_as_default()</tt> takes a boolean
argument. It is ambiguous to call this function with the argument set to
FALSE (0). With omniORB2, such a call will be silently ignored.
<P>
<LI> It is also ambiguous to pass the value TRUE (1) to the <tt>
set_as_default()</tt> operation when the union is a no default union
(<A HREF="node11.html#dynunioncat">10.7.1</A>). With omniORB2, such a call will be silently ignored.
<P>
<LI> When the discriminator value is not set, calling the <tt> member()</tt>
operation is ambiguous. With omniORB2, such a call will return a nil DynAny
reference. Similarly, a call to the <tt> member_kind()</tt> operation under
this condition will return <tt> tk_null</tt>.
<P>
</OL>
<P>
To ensure portability, it is best to avoid using the DynUnion interface
and not to rely on the ORB to behave as omniORB2 does under these ambiguous
conditions.
<P>
<H1><A NAME=SECTION001180000000000000000> Duplicate DynAny References</A></H1>
<P>
Like any CORBA object and psuedo object references, a DynAny reference can
be duplicated using the <tt> _duplicate()</tt> operations. When an application
has obtained multiple DynAny references to the same DynAny object, it
should be noted that a change made to the object by invoking on one
reference is also visible through the other references. In particular, if
a call through one reference has caused the current component pointer to be
changed, subsequent calls through other references will operate on the new
current component pointer.
<P>
<H1><A NAME=SECTION001190000000000000000> Other Operations</A></H1>
<P>
The following is a short summary of the other operations in the DynAny
interface which have not been covered in previous sections:
<P>
<DL ><DT><tt> assign()</tt>
<DD> initialises a DynAny object with another DynAny
object. The two objects must have the same typecode.
<P>
<DT><tt> from_any()</tt>
<DD> initialises a DynAny object from the value in an
any. The typecode in the two objects must be the same.
<P>
<DT><tt> copy()</tt>
<DD> creates a new DynAny object whose value is a deep copy
of the current object.
<P>
<DT><tt> type()</tt>
<DD> returns the typecode associated with the DynAny object.
<P>
 </DL>
<P>

<BR> <HR><A NAME=tex2html341 HREF="node12.html"><IMG ALIGN=BOTTOM ALT="next" SRC="http://www.uk.research.att.com/latex2html/icons/next_motif.gif"></A>   <A NAME=tex2html339 HREF="omniORB2.html"><IMG ALIGN=BOTTOM ALT="up" SRC="http://www.uk.research.att.com/latex2html/icons/up_motif.gif"></A>   <A NAME=tex2html333 HREF="node10.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="http://www.uk.research.att.com/latex2html/icons/previous_motif.gif"></A>   <A NAME=tex2html343 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="http://www.uk.research.att.com/latex2html/icons/contents_motif.gif"></A>      <BR>
<B> Next:</B> <A NAME=tex2html342 HREF="node12.html"> The Dynamic Invocation </A>
<B>Up:</B> <A NAME=tex2html340 HREF="omniORB2.html">No Title</A>
<B> Previous:</B> <A NAME=tex2html334 HREF="node10.html"> Type Any and </A>
<BR> <HR> <P>
<BR> <HR>
<P><ADDRESS>
<I>Sai Lai Lo <BR>
Fri Jul  2 17:38:50 BST 1999</I>
</ADDRESS>
</BODY>
