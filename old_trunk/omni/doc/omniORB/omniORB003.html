<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.05">
<TITLE>
 C++ language mapping
</TITLE>
</HEAD>
<BODY >
<A HREF="omniORB002.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Contents"></A>
<A HREF="omniORB004.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1>Chapter&nbsp;3&nbsp;&nbsp; C++ language mapping</H1>
Now that you are familiar with the basics, it is important to
familiarise yourself with the standard IDL to C++ language mapping.
The mapping is described in detail in&nbsp;[<A HREF="omniORB014.html#corba23-spec"><CITE>OMG99</CITE></A>]. If you have
not done so, you should obtain a copy of the document and use that as
the programming guide to omniORB.<BR>
<BR>
The specification is not an easy read. The alternative is to use one
of the books on CORBA programming that has begun to appear. For
instance, Henning and Vinoski's `Advanced CORBA Programming with
C++'&nbsp;[<A HREF="omniORB014.html#henning1999"><CITE>HV99</CITE></A>] includes many example code bits to illustrate
how to use the CORBA 2.3 C++ mapping.<BR>
<BR>
<A NAME="toc16"></A>
<H2>3.1&nbsp;&nbsp; Incompatibilities with pre-2.8.0 releases</H2>Before 2.8.0, omniORB implemented the CORBA 2.0 C++ mapping. From
2.8.0 onwards, the mapping has been updated to CORBA 2.3.
Unfortunately, to comply with the CORBA 2.3 specification, it has been
necessary to change the semantics of a few APIs in a way that is
incompatible with older omniORB releases. The incompatible changes are
limited to:<BR>
<BR>
<OL type=1>
<LI>
 The mapping for some out and inout argument types is different.<BR>
<BR>

<LI> The extraction of string, object reference and typecode from an
Any has different ownership rules.<BR>
<BR>

<LI> the DII interface now defaults to reporting a system exception
by raising a C++ exception, instead of returning the exception as an
environment value.</OL>The changes are minor and require minimal changes to the application
source code. The C++ compiler will complain about the first change.
<B>However, it is not possible to detect the old usage for
changes 2 and 3 at compile time. In particular, unmodified code that
uses the affected Any extraction operators will most certainly cause
runtime errors to occur.</B><BR>
<BR>
To smooth the transition from the old usage to the new, an omniORB
configuration variable
<TT>omniORB::omniORB_27_CompatibleAnyExtraction</TT> can be set to
revert the any extraction operators to the old semantics. More
information can be found in chapter&nbsp;<A HREF="omniORB009.html#ch_any">9</A>.<BR>
<BR>
<A NAME="toc17"></A>
<H2>3.2&nbsp;&nbsp; BOA compatibility</H2>
<A NAME="sec:BOAcompat"></A>If you use the <TT>-WbBOA</TT> option to omniidl, it will generate
skeleton code with the same interface as the old omniORB 2 BOA
mapping, as well as code to be used with the POA. Note that since the
major problem with the BOA specification was that server code was not
portable between ORBs, it is unlikely that omniORB 3's BOA
compatibility will help you much if you are moving from a different
BOA-based ORB.<BR>
<BR>
The BOA compatibility permits the majority of BOA code to compile
without difficulty. However, there are a number of constructs which
relied on omniORB 2 implementation details which no longer work.<BR>
<BR>
<UL>
<LI> omniORB 2 did not use distinct types for object references and
servants, and often accepted a pointer to a servant when the CORBA
specification says it should only accept an object reference. Such
code will not compile under omniORB 3.<BR>
<BR>

<LI> The reverse is true for <TT>BOA::obj_is_ready()</TT>. It now only
works when passed a pointer to a servant object, not an object
reference. The more commonly used mechanism of calling
<TT>_obj_is_ready(boa)</TT> on the servant object still works as
expected.<BR>
<BR>

<LI> It used to be the case that the skeleton class for interface
<TT>I</TT> (<TT>_sk_I</TT>) was derived from class <TT>I</TT>. This meant
that the names of any types declared in the interface were available
in the scope of the skeleton class. This is no longer true. If you
have an interface:<BR>
<BR>
<PRE>
interface I {
  struct S {
    long a,b;
  };
  S op();
};
</PRE>then where before the implementation code might have been:<BR>
<BR>
<PRE>
class I_impl : public virtual _sk_I {
  S op();  // _sk_I is derived from I
};
I::S I_impl::op() {
  S ret;
  // ...
}
</PRE>it is now necessary to fully qualify all uses of <TT>S</TT>:<BR>
<BR>
<PRE>
class I_impl : public virtual _sk_I {
  I::S op(); // _sk_I is not derived from I
};
I::S I_impl::op() {
  I::S ret;
  // ...
}
</PRE>
<LI> The proprietary omniORB 2 LifeCycle extensions are no longer
supported. All of the facilities it offered can be implemented with
the POA interfaces, and the <TT>omniORB::LOCATION_FORWARD</TT>
exception (see section&nbsp;<A HREF="omniORB006.html#sec:locationForward">6.13</A>). Code which used the
old interfaces will have to be rewritten.</UL><HR>
<A HREF="omniORB002.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Contents"></A>
<A HREF="omniORB004.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
