<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!Converted with LaTeX2HTML 95 (Thu Jan 19 1995) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds >
<HEAD>
<TITLE> Threaded I/O shutdown for Unix</TITLE>
</HEAD>
<BODY>
<meta name="description" value=" Threaded I/O shutdown for Unix">
<meta name="keywords" value="omnithread">
<meta name="resource-type" value="document">
<meta name="distribution" value="global">
<P>
 <BR> <HR><A NAME=tex2html57 HREF="node6.html"><IMG ALIGN=BOTTOM ALT="next" SRC="http://www.orl.co.uk/latex2html/icons/next_motif.gif"></A>   <A NAME=tex2html55 HREF="omnithread.html"><IMG ALIGN=BOTTOM ALT="up" SRC="http://www.orl.co.uk/latex2html/icons/up_motif.gif"></A>   <A NAME=tex2html49 HREF="node4.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="http://www.orl.co.uk/latex2html/icons/previous_motif.gif"></A>         <BR>
<B> Next:</B> <A NAME=tex2html58 HREF="node6.html">References</A>
<B>Up:</B> <A NAME=tex2html56 HREF="omnithread.html">The OMNI Thread Abstraction</A>
<B> Previous:</B> <A NAME=tex2html50 HREF="node4.html"> Using OMNI threads </A>
<BR> <HR> <P>
<H1><A NAME=SECTION00050000000000000000> Threaded I/O shutdown for Unix</A></H1>
<P>
or, how one thread should tell another thread to shut down when it might
be doing a blocking call on a socket.
<P>
Unfortunately there doesn't seem to be a standard way of doing this which works
across all Unix systems.  I have investigated the behaviour of our two main
Unix platforms, Solaris 2.5 and Digital Unix 3.2.  On Digital Unix everything
is fine, as the obvious method using shutdown() seems to work OK.
Unfortunately on Solaris shutdown can only be used on a connected socket, so we
need devious means to get around this limitation.  The details are summarised
below:
<P>
<H2><A NAME=SECTION00051000000000000000> read()</A></H2>
<P>
Thread A is in a loop, doing read(sock), processing the data, then going back
into the read.
<P>
Thread B comes along and wants to shut it down - it can't cancel thread A since
(i) working out how to clean up according to where A is in its loop is a
nightmare, and (ii) this isn't available in omnithread anyway.
<P>
On Solaris 2.5 and Digital Unix 3.2 the following strategy works:
<P>
Thread B does shutdown(sock,2).
<P>
At this point thread A is either blocked inside read(sock), or is elsewhere in
the loop.  If the former then read will return 0, indicating that the socket is
closed.  If the latter then eventually thread A will call read(sock) and then
this will return 0.  Thread A should close(sock), do any other tidying up, and
exit.
<P>
If there is another point in the loop that thread A can block then obviously
thread B needs to be aware of this and be able to wake it up in the appropriate
way from that point.
<P>
<H2><A NAME=SECTION00052000000000000000> accept()</A></H2>
<P>
Again thread A is in a loop, this time doing an accept on listenSock, dealing
with a new connection and going back into accept.  Thread B wants to cancel it.
<P>
On Digital Unix 3.2 the strategy is identical to that for read:
<P>
Thread B does shutdown(listenSock,2).  Wherever thread A is in the loop,
eventually it will return ECONNABORTED from the accept call.  It should
close(listenSock), tidy up as necessary and exit.
<P>
On Solaris 2.5 thread B can't do shutdown(listenSock,2) - this returns
ENOTCONN.  Instead the following strategy can be used:
<P>
First thread B sets some sort of &quot;shutdown flag&quot; associated with listenSock.
Then it does getsockaddr(listenSock) to find out which port listenSock is on
(or knows already), sets up a socket dummySock, does connect(dummySock, this
host, port) and finally does close(dummySock).
<P>
Now wherever thread A is in the loop, eventually it will call
accept(listenSock).  This will return successfully with a new socket, say
connSock.  Thread A then checks to see if the &quot;shutdown flag&quot; is set.  If not,
then it's a normal connection.  If it is set, then thread A closes listenSock
and connSock, tidies up and exits.
<P>
<H2><A NAME=SECTION00053000000000000000> write()</A></H2>
<P>
Thread A may be blocked in write, or about to go in to a potentially-blocking
write.  Thread B wants to shut it down.
<P>
On Solaris 2.5:
<P>
Thread B does shutdown(sock,2).
<P>
If thread A is already in write(sock) then it will return with ENXIO.  If
thread A calls write after thread B calls shutdown this will return EIO.
<P>
On Digital Unix 3.2:
<P>
Thread B does shutdown(sock,2).
<P>
If thread A is already in write(sock) then it will return the number of bytes
written before it became blocked.  A subsequent call to write will then
generate SIGPIPE (or EPIPE will be returned if SIGPIPE is ignored by the
thread).
<P>
<H2><A NAME=SECTION00054000000000000000> connect()</A></H2>
<P>
Thread A may be blocked in connect, or about to go in to a potentially-blocking
connect.  Thread B wants to shut it down.
<P>
On Digital Unix 3.2:
<P>
Thread B does shutdown(sock,2).
<P>
If thread A is already in connect(sock) then it will return a successful
connection.  Subsequent reading or writing will show that the socket has been
shut down (i.e. read returns 0, write generates SIGPIPE or returns EPIPE).  If
thread A calls connect after thread B calls shutdown this will return EINVAL.
<P>
On Solaris 2.5:
<P>
There is no way to wake up a thread which is blocked in connect.  Instead
Solaris forces us through a ridiculous procedure whichever way we try it.
One way is this:
<P>
First thread A creates a pipe in addition to the socket.  Instead of shutting
down the socket, thread B simply writes a byte to the pipe.
<P>

Thread A meanwhile sets the socket non-blocking using fcntl(sock, F_SETFL,
O_NONBLOCK).  Then it calls connect on the socket - this will return
EINPROGRESS.  Then it must call select, waiting for either sock to become
writable or for the pipe to become readable.  If select returns that just sock
is writable then the connection has succeeded.  It then needs to set the socket
back to blocking mode using fcntl(sock, F_SETFL, 0).  If instead select
returns that the pipe is readable, thread A closes the socket, tidies up and
exits.

<P>
An alternative method is similar but to use polling instead of the pipe.
Thread B justs sets a flag and thread A calls select with a timeout,
periodically waking up to see if the flag has been set.
<P>
<BR> <HR><A NAME=tex2html57 HREF="node6.html"><IMG ALIGN=BOTTOM ALT="next" SRC="http://www.orl.co.uk/latex2html/icons/next_motif.gif"></A>   <A NAME=tex2html55 HREF="omnithread.html"><IMG ALIGN=BOTTOM ALT="up" SRC="http://www.orl.co.uk/latex2html/icons/up_motif.gif"></A>   <A NAME=tex2html49 HREF="node4.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="http://www.orl.co.uk/latex2html/icons/previous_motif.gif"></A>         <BR>
<B> Next:</B> <A NAME=tex2html58 HREF="node6.html">References</A>
<B>Up:</B> <A NAME=tex2html56 HREF="omnithread.html">The OMNI Thread Abstraction</A>
<B> Previous:</B> <A NAME=tex2html50 HREF="node4.html"> Using OMNI threads </A>
<BR> <HR> <P>
<BR> <HR>

</BODY>
