<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.05">
<TITLE>
 Dynamic Management of Any Values
</TITLE>
</HEAD>
<BODY >
<A HREF="omniORB009.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Contents"></A>
<A HREF="omniORB011.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1>Chapter&nbsp;10&nbsp;&nbsp; Dynamic Management of Any Values</H1>
In CORBA specification 2.2, a new facility---<I>DynAny</I> was
introduced. Previously, it was not possible to insert or extract
constructed and other complex types from an Any without using the stub
code generated by an idl compiler for these types. This makes it
impossible to write generic servers (bridges, event channels
supporting filtering, etc.) because these servers can not have static
knowledge of all the possible data types that they have to handle.<BR>
<BR>
To fill this gap, the DynAny facility is defined to enable traversal
of the data value associated with an Any at runtime and extraction of
its constituents. This facility also enables the construction of an
Any at runtime, without having static knowledge of its types.<BR>
<BR>
This chapter describes how DynAny may be used. For completeness, you
should also read the DynAny specification defined in Chapter 9 of the
CORBA 2.3 specification. Where possible, the implementation in omniORB
adheres closely to the specification. However, there are areas in the
specification that are ambiguous or lacking in details. A number of
these issues are currently opened with the ORB revision task force.
Until the issues are resolved, it is possible that a different
implementation may choose to interpret the specification differently.
This chapter provides clarifications to the specification, explains
the interpretation used and offers some advice and warnings on
potential portability problems.<BR>
<BR>
Notice that the DynAny interface has been changed in CORBA 2.3,
particularly with the addition of the support for the IDL type
<TT>valuetype</TT>. Future releases of omniORB will be updated to
implement the interface as defined in CORBA 2.3.<BR>
<BR>
<A NAME="toc50"></A>
<H2>10.1&nbsp;&nbsp; C++ mapping</H2><PRE>
// namespace CORBA

class ORB {
public:
  ...

  class InconsistentTypeCode : public UserException { ... };

  DynAny_ptr create_dyn_any(const Any&amp; value);

  DynAny_ptr create_basic_dyn_any(TypeCode_ptr tc);

  DynStruct_ptr create_dyn_struct(TypeCode_ptr tc);

  DynSequence_ptr create_dyn_sequence(TypeCode_ptr tc);

  DynArray_ptr create_dyn_array(TypeCode_ptr tc);

  DynUnion_ptr create_dyn_union(TypeCode_ptr tc);

  DynEnum_ptr create_dyn_enum(TypeCode_ptr tc);

};

typedef DynAny* DynAny_ptr;
class DynAny_var { ... };

class DynAny {
public:    

  class Invalid : public UserException { ... };
  class InvalidValue : public UserException { ... };
  class TypeMismatch : public UserException { ... };
  class InvalidSeq : public UserException { ... };

  typedef _CORBA_Unbounded_Sequence__Octet OctetSeq;

  TypeCode_ptr type() const;

  void assign(DynAny_ptr dyn_any) throw(Invalid,SystemException);
  void from_any(const Any&amp; value) throw(Invalid,SystemException);
  Any* to_any() throw(Invalid,SystemException);
  void destroy();
  DynAny_ptr copy();

  DynAny_ptr current_component();
  Boolean next();
  Boolean seek(Long index);
  void rewind();

  void insert_boolean(Boolean value) throw(InvalidValue,SystemException);
  void insert_octet(Octet value) throw(InvalidValue,SystemException);
  void insert_char(Char value) throw(InvalidValue,SystemException);
  void insert_short(Short value) throw(InvalidValue,SystemException);
  void insert_ushort(UShort value) throw(InvalidValue,SystemException);
  void insert_long(Long value) throw(InvalidValue,SystemException);
  void insert_ulong(ULong value) throw(InvalidValue,SystemException);
  void insert_float(Float value) throw(InvalidValue,SystemException);
  void insert_double(Double value) throw(InvalidValue,SystemException);
  void insert_string(const char* value) throw(InvalidValue,SystemException);
  void insert_reference(Object_ptr v) throw(InvalidValue,SystemException);
  void insert_typecode(TypeCode_ptr v) throw(InvalidValue,SystemException);
  void insert_any(const Any&amp; value) throw(InvalidValue,SystemException);

  Boolean get_boolean() throw(TypeMismatch,SystemException);
  Octet get_octet() throw(TypeMismatch,SystemException);
  Char get_char() throw(TypeMismatch,SystemException);
  Short get_short() throw(TypeMismatch,SystemException);
  UShort get_ushort() throw(TypeMismatch,SystemException);
  Long get_long() throw(TypeMismatch,SystemException);
  ULong get_ulong() throw(TypeMismatch,SystemException);
  Float get_float() throw(TypeMismatch,SystemException);
  Double get_double() throw(TypeMismatch,SystemException);
  char* get_string() throw(TypeMismatch,SystemException);
  Object_ptr get_reference() throw(TypeMismatch,SystemException);
  TypeCode_ptr get_typecode() throw(TypeMismatch,SystemException);
  Any* get_any() throw(TypeMismatch,SystemException);

  static DynAny_ptr _duplicate(DynAny_ptr);
  static DynAny_ptr _narrow(DynAny_ptr);
  static DynAny_ptr _nil();
};

// DynFixed is not supported.

typedef DynEnum* DynEnum_ptr;
class DynEnum_var { ... };

class DynEnum :  public DynAny {
public:

  char* value_as_string();
  void value_as_string(const char* value);
  ULong value_as_ulong();
  void value_as_ulong(ULong value);

  static DynEnum_ptr _duplicate(DynEnum_ptr);
  static DynEnum_ptr _narrow(DynAny_ptr);
  static DynEnum_ptr _nil();
};

typedef char* FieldName;
typedef String_var FieldName_var;

struct NameValuePair {
  String_member id;
  Any value;
};

typedef _CORBA_ConstrType_Variable_Var&lt;NameValuePair&gt; NameValuePair_var;
typedef _CORBA_Unbounded_Sequence&lt;NameValuePair &gt; NameValuePairSeq;

typedef DynStruct* DynStruct_ptr;
class DynStruct_var { ... };

class DynStruct :  public DynAny {
public:

  char*  current_member_name();
  TCKind current_member_kind();
  NameValuePairSeq* get_members();
  void set_members(const NameValuePairSeq&amp; NVSeqVal)
                   throw(InvalidSeq,SystemException);

  static DynStruct_ptr _duplicate(DynStruct_ptr);
  static DynStruct_ptr _narrow(DynAny_ptr);
  static DynStruct_ptr _nil();
};

typedef DynUnion* DynUnion_ptr;
class DynUnion_var { ... };

class DynUnion :  public DynAny {
public:

  Boolean set_as_default();
  void set_as_default(Boolean value);
  DynAny_ptr discriminator();
  TCKind discriminator_kind();
  DynAny_ptr member();
  char*  member_name();
  void member_name(const char* value);
  TCKind member_kind();

  static DynUnion_ptr _duplicate(DynUnion_ptr);
  static DynUnion_ptr _narrow(DynAny_ptr);
  static DynUnion_ptr _nil();
};

typedef _CORBA_Unbounded_Sequence&lt;Any &gt; AnySeq;

typedef DynSequence* DynSequence_ptr;
class DynSequence_var { ... };

class DynSequence :  public DynAny {
public:

  ULong length();
  void length (ULong value);
  AnySeq* get_elements();
  void set_elements(const AnySeq&amp; value) throw(InvalidValue,SystemException);

  static DynSequence_ptr _duplicate(DynSequence_ptr);
  static DynSequence_ptr _narrow(DynAny_ptr);
  static DynSequence_ptr _nil();
};

typedef DynArray* DynArray_ptr;
class DynArray_var { ... };

class DynArray : public DynAny {
public:

  AnySeq* get_elements();
  void set_elements(const AnySeq&amp; value) throw(InvalidValue,SystemException);

  static DynArray_ptr _duplicate(DynArray_ptr);
  static DynArray_ptr _narrow(DynAny_ptr);
  static DynArray_ptr _nil();
};
</PRE><A NAME="toc51"></A>
<H2>10.2&nbsp;&nbsp; The DynAny Interface</H2>
<A NAME="dynany"></A>
<H3>10.2.1&nbsp;&nbsp; Example: extract data values from an Any</H3>If an Any contains a value of one of the basic data types, its value
can be extracted using the pre-defined operators in the Any interface.
When the value is a struct or other non-basic types, one can use the
DynAny interface to extract its constituent values.<BR>
<BR>
In this section, we use a struct as an example to illustrate how the
DynAny interface can be used.<BR>
<BR>
The example struct is as follows:<BR>
<BR>
<PRE>
// IDL
struct exampleStruct1 {
  string s;
  double d;
  long   l;
};
</PRE>To create a DynAny from an Any value, one uses the
<TT>create_dyn_any()</TT> method:<BR>
<BR>
<PRE>
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
  
Any v;
...       // Initialise v to contain a value of type exampleStruct1.
  
CORBA::DynAny_var dv = orb-&gt;create_dyn_any(v);
</PRE>Like CORBA object and pseudo object references, a <TT>DynAny_ptr</TT>
can be managed by a <TT>_var</TT> type (<TT>DynAny_var</TT>) which will
release the <TT>DynAny_ptr</TT> automatically when the variable goes
out of scope.<BR>
<BR>

<H4> Iterate through the components</H4>
<A NAME="dynanyiterate"></A>Once the DynAny object is created, we can use the DynAny interface to
extract the individual components in <TT>exampleStruct1</TT>. The DynAny
interface provides a number of functions to extract and insert
component values. These functions are defined to operate on the
component identified by the <I>current component</I> pointer.<BR>
<BR>
A <I>current component</I> pointer is an internal state of a DynAny
object. When a DynAny object is created, the pointer is initialised
to point to the first component of the any value.<BR>
<BR>
The pointer can be advanced to the next component with the <TT>next()</TT>
operation. The function returns FALSE (0) if there are no more
components. Otherwise it returns TRUE (1). When the any value in the
DynAny object contains only one component, the <TT>next()()</TT> operation
always returns FALSE(0).<BR>
<BR>
Another way of adjusting the pointer is the <TT>seek()</TT> operation. The
function returns FALSE (0) if there is no component at the specified
index. Otherwise it returns TRUE (1). The index value of the first
component is zero. Therefore, a <TT>seek(0)</TT> call rewinds the
pointer to the first component, this is also equivalent to a call to
the <TT>rewind()</TT> operation.<BR>
<BR>
For completeness, we should also mention here the
<TT>current_component()</TT> operation. This operation causes the DynAny
object to return a reference to another DynAny object that can be used
to access the current component. It is possible that the current
component pointer is not pointing to a valid component, for instance,
the <TT>next()</TT> operation has been invoked and there is no more
component. Under this circumstance, the <TT>current_component()</TT>
operation returns a nil DynAny object reference<A NAME="text21" HREF="#note21"><SUP><FONT SIZE=2>1</FONT></SUP></A>. For components which are just basic data types,
calling <TT>current_component()</TT> is an overkill because we can just use
the basic type extraction and insertion functions directly.<BR>
<BR>

<H4> Extract basic type components</H4>In our example, the component values can be extracted as follows:<BR>
<BR>
<PRE>
CORBA::String_var s = dv-&gt;get_string();
CORBA::Double     d = dv-&gt;get_double();
CORBA::Long       l = dv-&gt;get_long();
</PRE>Each get basic type operation has the side-effect of advancing the
current component pointer. For instance:<BR>
<BR>
<PRE>
CORBA::String_var s = dv-&gt;get_string();
</PRE>is equivalent to:<BR>
<BR>
<PRE>
CORBA::DynAny_var temp = dv-&gt;current_component();
CORBA::String_var s = temp-&gt;get_string();
dv-&gt;next();
</PRE>The get operations ensure that the current component is of the same
type as requested. Otherwise, the object throws a <TT>TypeMismatch</TT>
exception. If the current component pointer is invalid when a get
operation is called, the object also throws a <TT>TypeMismatch</TT>
exception<A NAME="text22" HREF="#note22"><SUP><FONT SIZE=2>2</FONT></SUP></A>.<BR>
<BR>
To repeatedly access the components, one can use the <TT>rewind()</TT> or
<TT>seek()</TT> operations to manipulate the current component pointer. For
instance, to access the <TT>d</TT> member in <TT>exampleStruct1</TT>
directly:<BR>
<BR>
<PRE>
dv-&gt;seek(1);       // position current component to member d.
CORBA::Double d = dv-&gt;get_double();
</PRE>
<H4> Extract complex components</H4>When a component is not one of the basic data types, it is not
possible to extract its value using the get operations. Instead, a
DynAny object has to be created from which the component is accessed.<BR>
<BR>
Consider this example:<BR>
<BR>
<PRE>
// IDL
struct exampleStruct2 {
  string m1;
  exampleStruct1 m2;
};
</PRE>In order to extract the data members within <TT>m2</TT> (of type
<TT>exampleStruct1</TT>), we use <TT>current_component()</TT> as follows:<BR>
<BR>
<PRE>
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
Any v;
...       // Initialise v to contain a value of type exampleStruct2.

CORBA::DynAny_var dv = orb-&gt;create_dyn_any(v);

CORBA::String_var m1 = dv-&gt;get_string();  // extract member m1
CORBA::DynAny_var dm = dv-&gt;current_component(); // DynAny reference to m2
CORBA::String_var s = dm-&gt;get_string();   // m2.s
CORBA::Double     d = dm-&gt;get_double();   // m2.d
CORBA::Long       l = dm-&gt;get_long();     // m2.l
</PRE>
<H4> Clean-up</H4>
Now we finish off this example with a description on destroying DynAny
objects. There are two points to remember:<BR>
<BR>
<OL type=1>
<LI>
 A DynAny reference (<TT>DynAny_ptr</TT>) is like any CORBA object
or psuedo object reference and should be handled in the same way. In
particular, one has to call the <TT>CORBA::release()</TT> operation to
indicate that a DynAny reference will no longer be accessed. In the
example, this is done automatically by <TT>DynAny_var</TT>.<BR>
<BR>

<LI> A DynAny object and its references are separate entities, just
as a CORBA object implementation and its object references are
different entities. While <TT>CORBA::release()</TT> will release any
resources associated with a <TT>DynAny_ptr</TT>, one has to
separately destroy the DynAny object to avoid any memory leak. This is
done by calling the <TT>destroy()()</TT> operation.
</OL>In the example, the DynAny object can be destroyed as follows:<BR>
<BR>
<PRE>
// C++
...
CORBA::DynAny_var dv = orb-&gt;create_dyn_any(v);
...
dv-&gt;destroy();

// From now on, one should not invoke any operation in dv.
// Otherwise the behaviour is undefined.
</PRE>
<H3>10.2.2&nbsp;&nbsp; Example: insert data values into an Any</H3>Using the DynAny interface, one can create an Any value from scratch.
In this example, we are going to create an Any containing a value of
the <TT>exampleStruct1</TT> type.<BR>
<BR>
First, we have to create a DynAny to store the value using one of the
<TT>create_dyn()</TT> functions. Because <TT>exampleStruct1</TT> is a
struct, we use the <TT>create_dyn_struct()</TT> operation.<BR>
<BR>
<PRE>
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.

// create the TypeCode for exampleStruct.
StructMemberSeq tc_members;
tc_members.length(3);
tc_members[0].name = (const char*)"s";
tc_members[0].type = CORBA::TypeCode::_duplicate(CORBA::_tc_string);
tc_members[0].type_def = CORBA::IDLType::_nil();
tc_members[1].name = (const char*)"d";
tc_members[1].type = CORBA::TypeCode::_duplicate(CORBA::_tc_double);
tc_members[1].type_def = CORBA::IDLType::_nil();
tc_members[2].name = (const char*)"l";
tc_members[2].type = CORBA::TypeCode::_duplicate(CORBA::_tc_long);
tc_members[2].type_def = CORBA::IDLType::_nil();
CORBA::TypeCode_var tc = orb-&gt;create_struct_tc("IDL:exampleStruct1:1.0",
                                               "exampleStruct1",
                                               tc_members);

// create the DynAny object to represent the any value
CORBA::DynAny_var dv = orb-&gt;create_dyn_struct(tc);
</PRE>
<H4> Insert basic type components</H4>Once the DynAny object is created, we can use the DynAny interface to
insert the components. The DynAny interface provides a number of
insert operations to insert basic types into the any value. In our
example, the component values can be inserted as follows:<BR>
<BR>
<PRE>
CORBA::String_var s = (const char*)"Hello";
CORBA::Double     d = 3.1416;
CORBA::Long       l = 1;

dv-&gt;insert_string(s);
dv-&gt;insert_double(d);
dv-&gt;insert_long(l);
</PRE>Each insert basic type operation has the side-effect of advancing the
current component pointer. For instance:<BR>
<BR>
<PRE>
dv-&gt;insert_string(s);
</PRE>is equivalent to:<BR>
<BR>
<PRE>
CORBA::DynAny_var temp = dv-&gt;current_component();
temp-&gt;insert_string(s);
dv-&gt;next();
</PRE>The insert operations ensure that the current component is of the same
type as the inserted value. Otherwise, the object throws an
<TT>InvalidValue</TT> exception. If the current component pointer is
invalid when an insert operation is called, the object also throws a
<TT>InvalidValue</TT> exception<A NAME="text23" HREF="#note23"><SUP><FONT SIZE=2>3</FONT></SUP></A>.<BR>
<BR>
Sometimes, one may just want to modify one component in an Any
value. For instance, one may just want to change the value of the
double member in <TT>exampleStruct1</TT>. This can be done as follows:<BR>
<BR>
<PRE>
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.

Any v;
...       // Initialise v to contain a value of type exampleStruct1.

CORBA::Double d = 6.28;

CORBA::DynAny_var dv = orb-&gt;create_dyn_any(v);

dv-&gt;seek(1);
dv-&gt;insert_double(d);    // Change the value of the member d.
</PRE>Finally, the any value can be obtained from the DynAny object using
the <TT>to_any()</TT> operation:<BR>
<BR>
<PRE>
CORBA::Any_var v = dv-&gt;to_any();    // Obtain the any value.
</PRE>
<H4> Insert complex components</H4>When a component is not one of the basic data types, it is not
possible to insert its value using the insert operations. Instead, a
DynAny object has to be created through which the component can be
inserted.<BR>
<BR>
In our example, one can insert component values into
<TT>exampleStruct2</TT> as follows:<BR>
<BR>
<PRE>
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
  
CORBA::TypeCode_var tc;
// create the TypeCode for exampleStruct2.
...
// create the DynAny object to represent the any value
CORBA::DynAny_var dv = orb-&gt;create_dyn_struct(tc);
  
CORBA::String_var m1  = (const char*)"Greetings";
CORBA::String_var m2s = (const char*)"Hello";
CORBA::Double     m2d = 3.1416;
CORBA::Long       m2l = 1;
  
dv-&gt;insert_string(m1);   // insert member m1
CORBA::DynAny_var dm = dv-&gt;current_component(); // DynAny reference to m2
dm-&gt;insert_string(m2s);  // insert member m2.s
dm-&gt;insert_double(m2d);  // insert member m2.d
dm-&gt;insert_long(m2l);    // insert member m2.l
  
CORBA::Any_var v = dv-&gt;to_any();  // obtain the any value
  
dv-&gt;destroy();          // destroy the DynAny object.
                        // No operation should be invoked on dv
                        // from this point on except CORBA::release.
</PRE>In addition to the DynAny interface, a number of derived interfaces
are defined. These interfaces are specialisation of the DynAny
interface to facilitate the handling of any values containing
non-basic types: struct, sequence, array, enum and union<A NAME="text24" HREF="#note24"><SUP><FONT SIZE=2>4</FONT></SUP></A>. The next few sections will provide more details on
these interfaces.<BR>
<BR>
<A NAME="toc52"></A>
<H2>10.3&nbsp;&nbsp; The DynStruct Interface</H2>When a DynAny object is created through the <TT>create_dyn_any()</TT>
operation and the any value contains a struct type, a <TT>DynStruct</TT>
object is created. The DynAny reference returned can be narrowed to a
<TT>DynStruct</TT> reference using the <TT>CORBA::DynStruct::_narrow()</TT>
operation.<BR>
<BR>
In the previous example, the components are extracted using the get
operations. Alternatively, the DynStruct interface provides an
additional operation (<TT>get_members()</TT>) to return all the components
in a single call. The returned value is a sequence of name value
pairs. The member name is given in the name field and its value is
returned as an Any value. For example, an alternative way to extract
the components in the previous example is as follows:<BR>
<BR>
<PRE>
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
Any v;
...       // Initialise v to contain a value of type exampleStruct1.
CORBA::DynAny_var dv = orb-&gt;create_dyn_any(v);
  
CORBA::DynStruct_var ds = CORBA::DynStruct::_narrow(dv);
  
CORBA::NameValuePairSeq* sq = ds-&gt;get_members();
  
char*         s;
CORBA::Double d;
CORBA::Long   l;
  
(*sq)[0].value &gt;&gt;= s;        // 1st element contains member s
(*sq)[1].value &gt;&gt;= d;        // 2nd element contains member d
(*sq)[2].value &gt;&gt;= l;        // 3rd element contains member l
</PRE>Similarly, the DynStruct interface provides an additional operation
(<TT>set_members()</TT>) to insert all the components in a single call. The
following is an alternative way to insert the components of the type
<TT>exampleStruct1</TT> into an Any value:<BR>
<BR>
<PRE>
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
  
CORBA::TypeCode_var tc;
// create the TypeCode for exampleStruct1.
...
// create the DynAny object to represent the any value
CORBA::DynAny_var dv = orb-&gt;create_dyn_struct(tc);
  
CORBA::String_var s = (const char*)"Hello";
CORBA::Double     d = 3.1416;
CORBA::Long       l = 1;
  
CORBA::NameValuePairSeq sq;
sq.length(3);
sq[0].id = (const char*)"s";
sq[0].value &lt;&lt;= CORBA::Any::from_string(s,0); 
                               // 1st element contains member s
sq[1].id = (const char*)"d";
sq[1].value &lt;&lt;= d;             // 2nd element contains member d
sq[2].id = (const char*)"l";
sq[2].value &lt;&lt;= l;             // 3rd element contains member l
  
dv-&gt;set_members(sq);    
</PRE>Notice that the name-value pairs in the argument to <TT>set_members()</TT>
must match the members of the struct exactly or the object would throw
the <TT>InvalidSeq</TT> exception.<BR>
<BR>
In addition to the <TT>current_component()</TT> operation, the DynStruct
interface provides two operations: <TT>current_member_name()</TT> and
<TT>current_member_kind()</TT>, to return information about the
current component.<BR>
<BR>
<A NAME="toc53"></A>
<H2>10.4&nbsp;&nbsp; The DynSequence Interface</H2>Like struct values, sequence values can be traversed using the
operations introduced in section&nbsp;<A HREF="#dynany">10.2</A>. The first sequence
element can be accessed as the first DynAny component, the second
sequence element as the second DynAny component and so on.<BR>
<BR>
To extract component values from an Any containing a sequence, the
length of the sequence can be obtained using the get length operation
in the DynSequence interface. Here is an example to extract the
components of a sequence of long:<BR>
<BR>
<PRE>
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
Any v;
...       // Initialise v to contain a value of a sequence of long
CORBA::DynAny_var dv = orb-&gt;create_dyn_any(v);
  
CORBA::DynSequence_var ds = CORBA::DynSequence::_narrow(dv);
CORBA::ULong len = ds-&gt;length();     // extract the length of the sequence
CORBA::ULong index;
for (index = 0; index &lt; len; index++) {
  CORBA::Long v = ds-&gt;get_long();
  cerr &lt;&lt; "[" &lt;&lt; index &lt;&lt; "] = " &lt;&lt; v &lt;&lt; endl;
}
</PRE>Conversely, the set length operation is provided to set the length of
the sequence. Here is an example to insert the components of a
sequence of long:<BR>
<BR>
<PRE>
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
  
CORBA::TypeCode_var tc;
// create the TypeCode for a sequence of long.
...
// create the DynAny object to represent the any value
CORBA::DynSequence_var ds = orb-&gt;create_dyn_sequence(tc);
  
CORBA::ULong len = 3;
  
ds-&gt;length(len);             // set the length of the sequence
  
CORBA::ULong index;
for (index = 0; index &lt; len; index++) {
  ds-&gt;insert_long(index);    // insert a sequence element
}
</PRE>Similar to the DynStruct interface, the <TT>get_elements()</TT> operation
is provided to return all the sequence elements and the
<TT>set_elements()</TT> operation is provided to insert all the sequence
elements.<BR>
<BR>
<A NAME="toc54"></A>
<H2>10.5&nbsp;&nbsp; The DynArray Interface</H2>Array values are handled by the DynArray interface. The DynArray
interface is the same as the DynSequence interface except that the
former does not provide the set length and get length operations.<BR>
<BR>
<A NAME="toc55"></A>
<H2>10.6&nbsp;&nbsp; The DynEnum Interface</H2>Enum values are handled by the DynEnum interface. A DynEnum object
contains a single component which is the enum value. This value cannot
be extracted or inserted using the get and insert operations of the
DynAny interface. Instead, two pairs of operations are provided to
handle this value.<BR>
<BR>
The <TT>value_as_string()</TT> operation allows the enum value to be
extracted or inserted as a string. The <TT>value_as_ulong()</TT> operation
allows the enum value to be extracted or inserted as an unsigned long.<BR>
<BR>
<A NAME="toc56"></A>
<H2>10.7&nbsp;&nbsp; The DynUnion Interface</H2>Union values are handled by the DynUnion interface. Unfortunately, the
CORBA 2.2 specification does not define the DynUnion interface in
sufficient details to nail down its intended usage<A NAME="text25" HREF="#note25"><SUP><FONT SIZE=2>5</FONT></SUP></A>. In this section, we try to fill in the gaps and describe a
sensible way to use the DynUnion interface. Where necessary, the
semantics of the operations is clarified. It is possible that the
behavior of this interface in another ORB is different from this
implementation. Where appropriate, we give warnings on usage that
might cause problems with portability.<BR>
<BR>
In relation to the current component pointer
(section&nbsp;<A HREF="#dynanyiterate">10.2.1.1</A>), a DynUnion object contains two
components. The first component (with the index value equals 0) is the
discriminator value, the second one is the member value. Therefore,
one can use the <TT>seek()</TT> and <TT>current_component()</TT> operations to
obtain a reference to the DynAny objects that handle the two
components. However, it is better to use the operations defined in the
DynUnion interface to manipulate these components as the semantics of
the operations is easier to understand.<BR>
<BR>

<H3>10.7.1&nbsp;&nbsp; Three Categories of Union</H3>
<A NAME="dynunioncat"></A>Before we continue, it is important to understand that unions can be
classified into the following categories:<BR>
<BR>
<OL type=1>
<LI>
 One that has a default branch defined in the IDL. This will be
called <I>explicit default union</I> in the rest of this section.

<LI> One that has no default branch and not all the possible values
of the discriminator type are covered by the branch labels in the IDL.
This will be called <I>implicit default union</I>.

<LI> One that has no default branch but all the possible values of
the discriminator type are covered. This will be called <I>no
default union</I>.
</OL>Of the three categories, the implicit default union is interesting
because by definition if the discriminator value is not equal to any
of the branch labels, the union has <EM>no</EM> member. That is, the
union value consists solely of the discriminator value.<BR>
<BR>

<H3>10.7.2&nbsp;&nbsp; Example: extract data values from a union</H3>
<H4> Explicit default union</H4>Consider a union of the following type:<BR>
<BR>
<PRE>
// IDL
union exampleUnion1 switch(boolean) {
case TRUE: long l;
default:   double d; 
};
</PRE>The most straightforward way to extract the member value is as
follows:<BR>
<BR>
<PRE>
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
  
Any v;
...       // Initialise v to contain a value of type exampleUnion1.
  
CORBA::DynAny_var dv = orb-&gt;create_dyn_any(v);
CORBA::DynUnion_var du = CORBA::DynUnion::_narrow(dv);
  
CORBA::String_var di = du-&gt;member_name();
CORBA::DynAny_var dm = du-&gt;member();
  
if (strcmp((const char*)di,"l") == 0) {
  // branch label is TRUE
  CORBA::Long v = dm-&gt;get_long();
  cerr &lt;&lt; "l = " &lt;&lt; v &lt;&lt; endl;
}
  
if (strcmp((const char*)di,"d") == 0) {
  // Is default branch
  CORBA::Double v = dm-&gt;get_double();
  cerr &lt;&lt; "d = " &lt;&lt; v &lt;&lt; endl;
}
</PRE>In the example, the operation <TT>member_name()</TT> is used to determine
which branch the union has been instantiated. The operation
<TT>member()</TT> is used to obtain a reference to the DynAny object that
handles the member.<BR>
<BR>
Alternatively, the branch can be determined by reading the
discriminator value:<BR>
<BR>
<PRE>
// C++
CORBA::DynAny_var di = du-&gt;discriminator();
CORBA::DynAny_var dm = du-&gt;member();
  
CORBA::Boolean di_v = di-&gt;get_boolean();
  
switch (di_v) {
case 1:
  CORBA::Long v = dm-&gt;get_long();
  cerr &lt;&lt; "l = " &lt;&lt; v &lt;&lt; endl;
  break;
default:
  CORBA::Double v = dm-&gt;get_double();
  cerr &lt;&lt; "d = " &lt;&lt; v &lt;&lt; endl;
}
</PRE>The operation <TT>discriminator()</TT> is used to obtain the value of the
discriminator.<BR>
<BR>
Finally, the third way to determine the branch is to test if the
default is selected:<BR>
<BR>
<PRE>
// C++
switch (dv-&gt;set_as_default()) {
case 1:
  CORBA::Double v = dm-&gt;get_double();
  cerr &lt;&lt; "d = " &lt;&lt; v &lt;&lt; endl;
  break;
default:
  CORBA::Long v = dm-&gt;get_long();
  cerr &lt;&lt; "l = " &lt;&lt; v &lt;&lt; endl;
}
</PRE>The operation <TT>set_as_default()()</TT> returns TRUE (1) if the
discriminator has been assigned a valid default value.<BR>
<BR>

<H4> Implicit default union</H4>Consider a union of the following type:<BR>
<BR>
<PRE>
// IDL
union exampleUnion2 switch(long) {
case 1: long l;
case 2: double d; 
};
</PRE>This example is similar to the previous one but there is no default
branch. The description above also applies to this example. However,
the discriminator may be set to neither 1 nor 2. Under this condition,
the implicit default is selected and the union value contains the
discriminator only!<BR>
<BR>
When the discriminator contains an implicit default value, one might
ask what is the value returned by the <TT>member_name()</TT> and
<TT>member()</TT> operation. Since there is no member in the union value,
omniORB returns a null string and a nil DynAny reference respectively.
This behavior is not specified in the CORBA 2.2 specification. To
ensure that your application is portable, it is best to avoid calling
these operations when the DynUnion object might contain an implicit
default value.<BR>
<BR>

<H4> No default union</H4>This is the last union category. For instance:<BR>
<BR>
<PRE>
// IDL
union exampleUnion3 switch(boolean) {
case TRUE: long l;
case FALSE: double d; 
};
</PRE>In this example, all the possible values of the discriminator are used
as union labels. There is no default branch. The only difference
between this category and the explicit default union is that the
<TT>set_as_default()</TT> operation always returns FALSE (0).<BR>
<BR>

<H3>10.7.3&nbsp;&nbsp; Example: insert data values into a union</H3>Writing into a union involves selecting the union branch with the
appropriate discriminator value and then writing the member value.
There are three ways to set the discriminator value:<BR>
<BR>
<OL type=1>
<LI> Use the <TT>member_name()()</TT> write operation to specify the union
branch by specifying the union member directly. This operation has the
side effect of setting the discriminator to the label value of the
branch.<BR>
<BR>

<LI> Write the label value of a union branch into the DynAny object
that handles the discriminator.<BR>
<BR>

<LI> If the union has a default branch, either explicitly or
implicitly, use the <TT>set_as_default()()</TT> write operation to
set the discriminator to a valid default value.</OL>The following example shows the three ways of writing into a union:<BR>
<BR>
<PRE>
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
  
CORBA::TypeCode_var tc;
// create the TypeCode for exampleUnion1.
...
// create the DynAny object to represent the any value
CORBA::DynUnion_var dv = orb-&gt;create_dyn_union(tc);
  
CORBA::Any_var v;
DynAny_ptr dm;
  
// Use member_name to select the union branch
dv-&gt;member_name("l");
dm = dv-&gt;member();
dm-&gt;insert_long(10);
v = dv-&gt;to_any();          // transfer to an Any
CORBA::release(dm);

// Setting the discriminator value to select the union branch
CORBA::DynAny_var di = dv-&gt;discriminator();
di-&gt;insert_boolean(1);     // set discriminator to label TRUE
dm = dv-&gt;member();
dm-&gt;insert_long(20);
v = dv-&gt;to_any();          // transfer to an Any
CORBA::release(dm);

// Use set_as_default to select the default union branch
dv-&gt;set_as_default(1);
dm = dv-&gt;member();
dm-&gt;insert_double(3.14);
v = dv-&gt;to_any();          // transfer to an Any
CORBA::release(dm);

dv-&gt;destroy();
</PRE>
<H4> Ambiguous usage</H4><OL type=1>
<LI> When the discriminator is set to a different value, a different
member branch is selected. Suppose the application has previously
obtained a DynAny reference to a union member when it changes the
discriminator value. As a result of the value change, the union is now
instantiated to another union branch, i.e. a call to the <TT>member()</TT>
operation will now return a reference to a different DynAny object. If
the application continues to access the DynAny object of the old union
member, the behavior of the ORB under this condition is not defined by
the CORBA 2.2 specification. With omniORB, the DynAny object of the
old union member is detached from the union when a new union branch is
selected. Therefore reading or writing this object will not have any
relation to the current value of the union. To avoid this ambiguity,
the reference to the old union member should be released before a
different union branch is selected.<BR>
<BR>

<LI> The write operation <TT>set_as_default()</TT> takes a boolean
argument. It is ambiguous to call this function with the argument set
to FALSE (0). With omniORB, such a call will be silently ignored.<BR>
<BR>

<LI> It is also ambiguous to pass the value TRUE (1) to the
<TT>set_as_default()</TT> operation when the union is a no default union
(<A HREF="#dynunioncat">10.7.1</A>). With omniORB, such a call will be silently
ignored.<BR>
<BR>

<LI> When the discriminator value is not set, calling the <TT>member()</TT>
operation is ambiguous. With omniORB, such a call will return a nil
DynAny reference. Similarly, a call to the <TT>member_kind()</TT> operation
under this condition will return <TT>tk_null</TT>.</OL>To ensure portability, it is best to avoid using the DynUnion
interface and not to rely on the ORB to behave as omniORB does under
these ambiguous conditions.<BR>
<BR>
<A NAME="toc57"></A>
<H2>10.8&nbsp;&nbsp; Duplicate DynAny References</H2>Like any CORBA object and psuedo object references, a DynAny reference
can be duplicated using the <TT>_duplicate()()</TT> operations. When an
application has obtained multiple DynAny references to the same DynAny
object, it should be noted that a change made to the object by
invoking on one reference is also visible through the other
references. In particular, if a call through one reference has caused
the current component pointer to be changed, subsequent calls through
other references will operate on the new current component pointer.<BR>
<BR>
<A NAME="toc58"></A>
<H2>10.9&nbsp;&nbsp; Other Operations</H2>The following is a short summary of the other operations in the DynAny
interface which have not been covered in previous sections:<BR>
<BR>
<DL COMPACT=compact>
<DT>
<TT>assign()</TT><DD> initialises a DynAny object with another DynAny
object. The two objects must have the same typecode.<BR>
<BR>

<DT><TT>from_any()</TT><DD> initialises a DynAny object from the value in an
any. The typecode in the two objects must be the same.<BR>
<BR>

<DT><TT>copy()</TT><DD> creates a new DynAny object whose value is a deep
copy of the current object.<BR>
<BR>

<DT><TT>type()</TT><DD> returns the typecode associated with the DynAny
object.</DL><HR WIDTH="50%" SIZE=1><DL>
<DT><A NAME="note21" HREF="#text21"><FONT SIZE=5>1</FONT></A><DD> Testing a nil
DynAny object with CORBA::is_nil() returns TRUE(1). The CORBA 2.2
specification does not specify what is the return value of this
function when the current component pointer is invalid. To ensure
portability, it is best to avoid calling <TT>current_component()</TT> under
this condition.

<DT><A NAME="note22" HREF="#text22"><FONT SIZE=5>2</FONT></A><DD> The CORBA 2.2 specification does not define the
behavior of this error condition. To ensure portability, it is best to
avoid calling the get operations when the current component pointer is
known to be invalid.

<DT><A NAME="note23" HREF="#text23"><FONT SIZE=5>3</FONT></A><DD> The CORBA 2.2 specification
does not define the behavior of this error condition. To ensure
portability, it is best to avoid calling the insert operations when
the current component pointer is known to be invalid.

<DT><A NAME="note24" HREF="#text24"><FONT SIZE=5>4</FONT></A><DD> In
the CORBA 2.2 specification, the DynFixed interface is defined to
handle the fixed data type. This is not supported in this
implementation.

<DT><A NAME="note25" HREF="#text25"><FONT SIZE=5>5</FONT></A><DD> This
interface is currently an open issue with the ORB revision task
force.
</DL>
<HR>
<A HREF="omniORB009.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Contents"></A>
<A HREF="omniORB011.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
