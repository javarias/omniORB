<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!Converted with LaTeX2HTML 95 (Thu Jan 19 1995) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds >
<HEAD>
<TITLE> Thread object</TITLE>
</HEAD>
<BODY>
<meta name="description" value=" Thread object">
<meta name="keywords" value="omnithread">
<meta name="resource-type" value="document">
<meta name="distribution" value="global">
<P>
 <BR> <HR><A NAME=tex2html37 HREF="node4.html"><IMG ALIGN=BOTTOM ALT="next" SRC="http://www.orl.co.uk/latex2html/icons/next_motif.gif"></A>   <A NAME=tex2html35 HREF="omnithread.html"><IMG ALIGN=BOTTOM ALT="up" SRC="http://www.orl.co.uk/latex2html/icons/up_motif.gif"></A>   <A NAME=tex2html29 HREF="node2.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="http://www.orl.co.uk/latex2html/icons/previous_motif.gif"></A>         <BR>
<B> Next:</B> <A NAME=tex2html38 HREF="node4.html"> Using OMNI threads </A>
<B>Up:</B> <A NAME=tex2html36 HREF="omnithread.html">The OMNI Thread Abstraction</A>
<B> Previous:</B> <A NAME=tex2html30 HREF="node2.html"> Synchronisation objects</A>
<BR> <HR> <P>
<H1><A NAME=SECTION00030000000000000000> Thread object</A></H1>
<P>
A thread is represented by an <tt> omni_thread</tt> object.  There are broadly two
different ways in which it can be used.
<P>
The first way is simply to create an <tt> omni_thread</tt> object, giving a
particular function which the thread should execute.  This is like the POSIX
(or any other) C language interface.
<P>
The second method of use is to create a new class which inherits from <tt>
omni_thread</tt>.  In this case the thread will execute the <tt> run()</tt> member
function of the new class.  One advantage of this scheme is that
thread-specific data can be implemented simply by having data members of the
new class.
<P>
When constructed a thread is in the &quot;new&quot; state and has not actually started.
A call to <tt> start()</tt> causes the thread to begin executing.  A static member
function <tt> create()</tt> is provided to construct and start a thread in a single
call.  A thread exits by calling <tt> exit()</tt> or by returning from the thread
function.
<P>
Threads can be either detached or undetached.  Detached threads are threads for
which all state will be lost upon exit.  Other threads cannot determine when a
detached thread will disappear, and therefore should not attempt to access the
thread object unless some explicit synchronisation with the detached thread
guarantees that it still exists.
<P>
Undetached threads are threads for which storage is not reclaimed until another
thread waits for its termination by calling <tt> join()</tt>.  An exit value can be
passed from an undetached thread to the thread which joins it.
<P>

Detached / undetached threads are distinguished on creation by the type of
function they execute.  Undetached threads execute a function which has a <tt>
void*</tt> return type, whereas detached threads execute a function which has a
<tt> void</tt> return type.  Unfortunately C++ member functions are not allowed to
be distinguished simply by their return type.  Thus in the case of a derived
class of <tt> omni_thread</tt> which needs an undetached thread, the member
function executed by the thread is called <tt> run_undetached()</tt> rather than
<tt> run()</tt>, and it is started by calling <tt> start_undetached()</tt> instead of
<tt> start()</tt>.

<P>
The abstraction currently supports three priorities of thread, but no guarantee
is made of how this will affect underlying thread scheduling.  The three
priorities are <tt> PRIORITY_LOW</tt>, <tt> PRIORITY_NORMAL</tt> and <tt>
PRIORITY_HIGH</tt>.  By default all threads run at <tt> PRIORITY_NORMAL</tt>.  A
different priority can be specified on thread creation, or while the thread is
running using <tt> set_priority().</tt>  A thread's current priority is returned
by <tt> priority()</tt>.
<P>

Other functions provided are <tt> self()</tt> which returns the calling thread's
<tt> omni_thread</tt> object, <tt> yield()</tt> which requests that other threads be
allowed to run, <tt> id()</tt> which returns an integer id for the thread for use
in debugging, <tt> state()</tt>, <tt> sleep()</tt> and <tt> get_time()</tt>.

<P>
<BR> <HR><A NAME=tex2html37 HREF="node4.html"><IMG ALIGN=BOTTOM ALT="next" SRC="http://www.orl.co.uk/latex2html/icons/next_motif.gif"></A>   <A NAME=tex2html35 HREF="omnithread.html"><IMG ALIGN=BOTTOM ALT="up" SRC="http://www.orl.co.uk/latex2html/icons/up_motif.gif"></A>   <A NAME=tex2html29 HREF="node2.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="http://www.orl.co.uk/latex2html/icons/previous_motif.gif"></A>         <BR>
<B> Next:</B> <A NAME=tex2html38 HREF="node4.html"> Using OMNI threads </A>
<B>Up:</B> <A NAME=tex2html36 HREF="omnithread.html">The OMNI Thread Abstraction</A>
<B> Previous:</B> <A NAME=tex2html30 HREF="node2.html"> Synchronisation objects</A>
<BR> <HR> <P>
<BR> <HR>

</BODY>
