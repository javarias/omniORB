<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!Converted with LaTeX2HTML 95 (Thu Jan 19 1995) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds >
<HEAD>
<TITLE> Interface Type Checking</TITLE>
</HEAD>
<BODY>
<meta name="description" value=" Interface Type Checking">
<meta name="keywords" value="omniORB2">
<meta name="resource-type" value="document">
<meta name="distribution" value="global">
<P>
 <BR> <HR><A NAME=tex2html294 HREF="node8.html"><IMG ALIGN=BOTTOM ALT="next" SRC="next_motif.gif"></A>   <A NAME=tex2html292 HREF="omniORB2.html"><IMG ALIGN=BOTTOM ALT="up" SRC="up_motif.gif"></A>   <A NAME=tex2html286 HREF="node6.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="previous_motif.gif"></A>   <A NAME=tex2html296 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="contents_motif.gif"></A>      <BR>
<B> Next:</B> <A NAME=tex2html295 HREF="node8.html"> Connection Management</A>
<B>Up:</B> <A NAME=tex2html293 HREF="omniORB2.html">No Title</A>
<B> Previous:</B> <A NAME=tex2html287 HREF="node6.html"> The Basic Object </A>
<BR> <HR> <P>
<H1><A NAME=SECTION00700000000000000000> Interface Type Checking</A></H1>
<P>

<A NAME=ch_intf>&#160;</A>
<P>
This chapter describes the mechanism used by omniORB2 to ensure type safety
when object references are exchanged across the network. This mechanism is
handled completely within the ORB. There is no programming interface
visible at the application level. However, for the sake of diagnosing the
problem when there is a type violation, it is useful to understand the
underlying mechanism in order to interpret the error conditions reported by
the ORB.
<P>
<H1><A NAME=SECTION00710000000000000000> Introduction</A></H1>
<P>
In GIOP/IIOP, an object reference is encoded as an Interoperable Object
Reference (IOR) when it is sent across a network connection. The IOR
contains a Repository ID (REPOID) and one or more communication profiles. The
communication profiles describe where and how the object can be
contacted. The REPOID is a string which uniquely identifies the
IDL interface of the object.
<P>
Unless the <b> ID</b> pragma is specified in the IDL, the ORB generates the
REPOID string in the so-called OMG IDL Format<A NAME=tex2html18 HREF="footnode.html#537"><IMG ALIGN=BOTTOM ALT="gif" SRC="foot_motif.gif"></A>. For instance, the REPOID for the <tt> Echo</tt> interface used
in the examples of chapter <A HREF="node3.html#ch_basic">2</A> is <tt> IDL:Echo:1.0</tt>.
<P>
When interface inheritance is used in the IDL, the ORB always sends the
REPOID of the most derived interface. For example:
<P>

<PRE>// IDL
   interface A {
     ...
   };
   interface B : A {
     ...
   };
   interface C {
      void op(in A arg);
   };

// C++
   C_ptr server;
   B_ptr objB;
   A_ptr objA = objB;
   server-&gt;op(objA);      // Send B as A
</PRE>

<P>
In the example, the operation C::op accepts an object reference of type
A. The real type of the reference passed to C::op is B, which inherits from
A. In this case, the REPOID of B, and not that of A, is sent across the
network.
<P>
The GIOP/IIOP specification allows an ORB to send a null string in the
REPOID field of an IOR. It is up to the receiving end to work out the real
type of the object. OmniORB2 never sends out null strings as
REPOID. However, it may receive null REPOID from other ORBs. In that case,
it will use the mechanism described below to ensure type safety.
<P>
<H1><A NAME=SECTION00720000000000000000> Basic Interface Type Checking</A></H1>
<P>
<A NAME=sec_intf>&#160;</A>
<P>
The ORB is provided with the interface information by the stubs via the
proxyObjectFactory class. For an interface A, the stub of A contains a
A_proxyObjectFactory class. This class is derived from the
proxyObjectFactory class. The proxyObjectFactory is an abstract class which
contains 3 virtual functions.
<P>

<PRE>class proxyObjectFactory {
public:

  virtual const char *irRepoId() const = 0;

  virtual _CORBA_Boolean  is_a(const char *base_repoId) const = 0;
       
  virtual CORBA::Object_ptr newProxyObject(Rope *r,
                                           CORBA::Octet *key,
                                           size_t keysize,
                                           IOP::TaggedProfileList
                                           *profiles,
                                           CORBA::Boolean release) = 0;

};
</PRE>

<P>
<UL><LI> <tt> irRepoId</tt> returns the REPOID of the interface.
<LI> <tt> is_a</tt> returns true(1) if the argument is the REPOID of the
interface itself or it is that of its base interfaces.
<LI> <tt> newProxyObject</tt> returns an object reference based on the
information supplied in the arguments.
</UL>
<P>
A single instance of every *_proxyObjectFactory is instantiated at runtime.
The instances are entered into a list inside the ORB. The list constitutes
all the interface information known to the ORB.
<P>
When the ORB receives an IOR from the network, it unmarshals and
extracts the REPOID from the IOR. At this point, the ORB has two pieces of
information in hand:
<P>
<OL><LI> The REPOID of the object reference received from the network.
<LI> The REPOID the ORB is expecting. This comes from the unmarshal
      function that tells the ORB to receive the object reference.
</OL>
<P>
Using the REPOID received, the ORB searches its proxyObjectFactory list for
an exact match. If there is an exact match, all is well because the runtime
can use the <tt> is_a</tt> method of the proxyFactory to check if the expected
REPOID is the same as the received REPOID or if it is that of its base
interfaces. If the answer is positive, the IOR passes the type checking
test and the ORB can proceed to create an object reference in its own
address space to represent the IOR.
<P>
However, the ORB may fail to find a match in its proxyObjectFactory
list. This means that the ORB has no local knowledge of the REPOID.
There are three possible causes:
<P>
<OL><LI> The remote end is another ORB and it sends a null string as the REPOID.
<LI> The ORB is expecting an object reference of interface A. The remote
      end sends the REPOID of B which is an interface that inherits from A.
      The stubs of A is linked into the executable but the stubs of B is
      not.
<LI> The remote end has sent a duff IOR.
</OL>
<P>
To handle this situation, the ORB must find out the type information
dynamically. This is explained in the next section.
<P>
<H1><A NAME=SECTION00730000000000000000> Interface Inheritance</A></H1>
<P>
When the ORB receives an IOR of interface type B when it expects the type to
be A, it must find out if B inherits from A. When the ORB has no local
knowledge of the type B, it must work out the type of B dynamically.
<P>
The CORBA specification defines an Interface Repository (IR) from which IDL
interfaces can be queried dynamically. In the above situation, the ORB
could contact the IR to find out the type of B. However, this approach
assumes that an IR is always available and contains the up-to-date
information of all the interfaces used in the domain. This assumption may
not be valid in many applications.
<P>
An alternative is to use the <tt> _is_a</tt> operation to
work out the actual type of an object. This approach is simpler
and more robust than the previous one because no 3rd party is involved.
<P>

<PRE>class Object{
    CORBA::Boolean _is_a(const char* type_id);
};
</PRE>

<P>
The <tt> _is_a</tt> operation is part of the <tt> CORBA::Object</tt> interface
and must be implemented by every object. The input argument is a
REPOID. The function returns true(1) if the object is really an instance of
that type, including if that type is a base type of the most derived type
of that object.
<P>
In the situation above, the ORB would invoke the <tt> _is_a</tt>
operation on the object and ask if the object is of type A <b> before</b>
it processes any application invocation on the object.
<P>
Notice that the <tt> _is_a</tt> call is <b> not</b> performed when the IOR is
unmarshalled. It is performed just prior to the first application
invocation on the object. This leads to some interesting failure mode if
B reports that it is not an A. Consider the following example:
<P>

<PRE>\\  IDL
   interface A { ... };
   interface B : A { ... };
   interface D { ... };
   interface C {
     A      op1();
     Object op2();
   };

\\  C++

   C_ptr objC;
   A_ptr objA;
   CORBA::Object_ptr objR;

   objA =  objC-&gt;op1();              // line 1
   (void) objA-&gt;_non_existent();     // line 2

   objR =  objC-&gt;op2();              // line 3
   objA =  A::_narrow(objR);         // line 4
</PRE>

<P>
 If the stubs of A,B,C,D are linked into the executable and:
<P>
<DL ><DT>Case 1
<DD> <tt> C::op1</tt> and <tt> C::op2</tt> returns a B. Line 1-4 complete successful. The
remote object is only contacted at line 2.
<DT>Case 2
<DD> <tt> C::op1</tt> and <tt> C::op2</tt> returns a D. This condition only occurs if the
runtime of the remote end is buggy. The ORB raises a CORBA::Marshal
exception at line 1 because it knows it has received an interface of the
wrong type.
<P>
 </DL>
<P>
 If only the stub of A is linked into the executable and:
<P>
<DL ><DT>Case 1
<DD> C::op1 and C::op2 returns a B. Line 1-4 completes successful. When
line 2 and 4 is executed, the object is contacted to ask if it is a A.
<DT>Case 2
<DD> C::op1 and C::op2 returns a D. This condition only occurs if the
runtime of the remote end is buggy. Line 1 completes and no exception is
raised. At line 2, the object is contacted to ask if it is a A. If the
answer is no, a CORBA::INV_OBJREF exception is raised. The application will
also see a CORBA::INV_OBJREF at line 4.
<P>
 </DL>
<P>

<BR> <HR><A NAME=tex2html294 HREF="node8.html"><IMG ALIGN=BOTTOM ALT="next" SRC="next_motif.gif"></A>   <A NAME=tex2html292 HREF="omniORB2.html"><IMG ALIGN=BOTTOM ALT="up" SRC="up_motif.gif"></A>   <A NAME=tex2html286 HREF="node6.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="previous_motif.gif"></A>   <A NAME=tex2html296 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="contents_motif.gif"></A>      <BR>
<B> Next:</B> <A NAME=tex2html295 HREF="node8.html"> Connection Management</A>
<B>Up:</B> <A NAME=tex2html293 HREF="omniORB2.html">No Title</A>
<B> Previous:</B> <A NAME=tex2html287 HREF="node6.html"> The Basic Object </A>
<BR> <HR> <P>
<BR> <HR>
<P><ADDRESS>
<I>David Riddoch <BR>
Wed Feb 24 14:48:15 GMT 1999</I>
</ADDRESS>
</BODY>
