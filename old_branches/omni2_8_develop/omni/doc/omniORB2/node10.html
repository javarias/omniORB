<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!Converted with LaTeX2HTML 95 (Thu Jan 19 1995) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds >
<HEAD>
<TITLE> Type Any and TypeCode</TITLE>
</HEAD>
<BODY>
<meta name="description" value=" Type Any and TypeCode">
<meta name="keywords" value="omniORB2">
<meta name="resource-type" value="document">
<meta name="distribution" value="global">
<P>
 <BR> <HR><A NAME=tex2html330 HREF="node11.html"><IMG ALIGN=BOTTOM ALT="next" SRC="http://www.uk.research.att.com/latex2html/icons/next_motif.gif"></A>   <A NAME=tex2html328 HREF="omniORB2.html"><IMG ALIGN=BOTTOM ALT="up" SRC="http://www.uk.research.att.com/latex2html/icons/up_motif.gif"></A>   <A NAME=tex2html322 HREF="node9.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="http://www.uk.research.att.com/latex2html/icons/previous_motif.gif"></A>   <A NAME=tex2html332 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="http://www.uk.research.att.com/latex2html/icons/contents_motif.gif"></A>      <BR>
<B> Next:</B> <A NAME=tex2html331 HREF="node11.html"> Dynamic Management of </A>
<B>Up:</B> <A NAME=tex2html329 HREF="omniORB2.html">No Title</A>
<B> Previous:</B> <A NAME=tex2html323 HREF="node9.html"> Proxy Objects</A>
<BR> <HR> <P>
<H1><A NAME=SECTION001000000000000000000> Type Any and TypeCode</A></H1>
<P>

<A NAME=ch_any>&#160;</A>
<P>
The CORBA specification provides for a type that can hold the value of any 
OMG IDL type. This type is known as type Any. The OMG also specifies a 
pseudo-object, TypeCode, that can encode a description of any type specifiable
in OMG IDL.
<P>
In this chapter, an example demonstrating the use of type Any is presented. 
This is followed by sections describing the behaviour of type Any and TypeCode 
in omniORB2. 
For further information on type Any, refer to the C++ Mapping section of the 
CORBA 2 specification [<A HREF="node15.html#corba2spec">OMG99a</A>], and for more information on 
TypeCode, refer to the Interface Repository chapter in the CORBA core section 
of the CORBA 2 specification.
<P>
<b> WARNING: </b> Since 2.8.0, omniORB2 has been updated to CORBA 2.3. In
order to comply with the 2.3 specification, it is necessary to change the
semantics of <em> the extraction of string, object reference and typecode
from an Any</em>. The memory of the extracted values of these types now belong
to the Any value. The storage is freed when the Any value is
deallocated. Previously the extracted value is a copy and the application
is responsible to release the storage. It is not possible to detect the old
usage at compile time. In particular, unmodified code that uses the
affected Any extraction operators would most certainly cause runtime errors
to occur.  To smooth the transition from the old usage to the new, an ORB
configuration variable <tt> omniORB::omniORB_27_CompatibleAnyExtraction</tt>
can be set to revert the any extraction operators to the old semantics.
<P>
<H1><A NAME=SECTION001010000000000000000> Example using type Any</A></H1>
<P>
Before going through this example, you should make sure that you have read 
and understood the examples in chapter <A HREF="node3.html#ch_basic">2</A>.
The source code for this example is included in the omniORB2 distribution,
in the directory src/examples/anyExample. A listing of the source code is
provided at the end of this chapter.
<P>
<H2><A NAME=SECTION001011000000000000000> Type Any in IDL</A></H2>
<P>
Type Any allows one to delay the decision on the type used in an operation 
until run-time. To use type any in IDL, use the keyword <tt> any</tt>, as in the 
following example:

<PRE>// IDL

interface anyExample {
  any testOp(in any mesg);
};
</PRE>

<P>
The operation <tt> testOp()</tt> in this example can now take any value 
expressible in OMG IDL as an argument, and can also return any type 
expressible in OMG IDL.
<P>
Type Any is mapped into C++ as the type <tt> CORBA::Any</tt>. When passed as
an argument or as a result of an operation, the following rules apply:
<P>

<P><IMG  ALIGN=BOTTOM ALT="" SRC="img14.gif"><P>

<P>
So, the above IDL would map to the following C++
<P>

<PRE>// C++

class anyExample_i : public virtual _sk_anyExample {
public:
  anyExample_i() { }
  virtual ~anyExample_i() { }
  virtual CORBA::Any* testOp(const CORBA::Any&amp; a);
};
</PRE>

<P>
<H2><A NAME=SECTION001012000000000000000> Inserting and Extracting Basic Types from an Any</A></H2>
<P>
The question now arises as to how values are inserted into and removed from
an Any. This is achieved using two overloaded operators: <tt> &lt;&lt;= and &gt;&gt;= </tt>.
<P>
Two insert a value into an Any, the <tt> &lt;&lt;= </tt>operator is used, as in this 
example:
<P>

<PRE>// C++
 
CORBA::Any an_any;
CORBA::Long l = 100;
an_any &lt;&lt;= l;
</PRE>

<P>
Note that the overloaded <tt> &lt;&lt;= </tt>operator has a return type of <tt> void</tt>.
<P>
To extract a value, the <tt> &gt;&gt;= </tt>operator is used, as in this example (where
the Any contains a long):
<P>

<PRE>// C++

CORBA::Long l;
an_any &gt;&gt;= l;

cout &lt;&lt; &quot;This is a long: &quot; &lt;&lt; l &lt;&lt; endl;
</PRE>

<P>
The overloaded <tt> &gt;&gt;= </tt>operator returns a CORBA::Boolean. If an attempt is 
made to extract a value from an Any when it contains a different value (e.g. 
an attempt to extract a long from an Any containing a double), the overloaded 
<tt> &gt;&gt;= </tt>operator will return False; otherwise it will return True. Thus, a 
common tactic to extract values from an Any is as follows:
<P>

<PRE>// C++


CORBA::Long l;
CORBA::Double d;
const char* str;     // From CORBA 2.3 onwards, uses const char*
                     // instead of char*. 

if (an_any &gt;&gt;= l) {
    cout &lt;&lt; &quot;Long: &quot; &lt;&lt; l &lt;&lt; endl;
}
else if (an_any &gt;&gt;= d) {
    cout &lt;&lt; &quot;Double: &quot; &lt;&lt; d &lt;&lt; endl;
}
else if (an_any &gt;&gt;= str) {
    cout &lt;&lt; &quot;String: &quot; &lt;&lt; str &lt;&lt; endl;
    // Since 2.8.0 the storage of the extracted string is still
    // owned by the any.
    // In pre-omniORB 2.8.0 releases, the string returned is a copy.
}
else {
    cout &lt;&lt; &quot;Unknown value.&quot; &lt;&lt; endl;
}
</PRE>

<P>
<H2><A NAME=SECTION001013000000000000000> Inserting and Extracting Constructed Types from an Any</A></H2>
<P>
It is also possible to insert and extract constructed types and object
references from an Any. <tt> omniidl2 </tt>will generate insertion and extraction 
operators for the constructed type. Note that it is necessary to specify
the <tt> -a</tt> command-line flag when running omniidl2 in order to generate
these operators. The following example illustrates the use of constructed types
with type Any:
<P>

<PRE>// IDL

struct testStruct {
  long l;
  short s;
};


interface anyExample {
  any testOp(in any mesg);
};
</PRE>

<P>
Upon compiling the above IDL with <tt> omniidl2 -a</tt>, the following overloaded 
operators are generated:
<P>
<OL><LI> <tt> void operator&lt;&lt;=(CORBA::Any&amp;, const testStruct&amp; ) </tt>
<LI> <tt> void operator&lt;&lt;=(CORBA::Any&amp;, testStruct* ) </tt>
<LI> <tt> CORBA::Boolean operator&gt;&gt;=(const CORBA::Any&amp;, const testStruct*&amp;) </tt>
</OL>
<P>
Operators of this form are generated for all constructed types, and for 
interfaces.
<P>
The first operator, <em> (1) </em>, copies the constructed type, and inserts it 
into the Any. The second operator, <em> (2) </em>, inserts the constructed type 
into the Any, and then manages it. Note that if the second operator is used,
the Any consumes the constructed type, and the caller should not used the
pointer to access the data after insertion. The following is an example of how
to insert a value into an Any using operator <em> (1) </em>:

<PRE>// C++

CORBA::Any an_any;

testStruct t;
t.l = 456;
t.s = 8;

an_any &lt;&lt;= t;
</PRE>

<P>
The third operator, <em> (3) </em>, is used to extract the constructed type 
from the Any, and can be used as follows:
<P>

<PRE>const testStruct* tp;   // From CORBA 2.3 onwards, use 
                        // const testStruct* instead of testStruct*

if (an_any &gt;&gt;= tp) {
    cout &lt;&lt; &quot;testStruct: l: &quot; &lt;&lt; tp-&gt;l &lt;&lt; endl;
    cout &lt;&lt; &quot;            s: &quot; &lt;&lt; tp-&gt;s &lt;&lt; endl;
}
else {
    cout &lt;&lt; &quot;Unknown value contained in Any.&quot; &lt;&lt; endl;
}
</PRE>

<P>
As with basic types, if an attempt is made to extract a type from an Any
that does not contain a value of that type, the extraction operator returns
False. If the Any does contain that type, the extraction operator returns
True. If the extraction is successful, the caller's pointer will point to
memory managed by the Any. The caller must not delete or otherwise change
this storage, and should not use this storage after the contents of the Any
are replaced (either by insertion or assignment), or after the Any has been
destroyed. In particular, management of the pointer should not be assigned
to a <tt>_var</tt> type.
<P>
<b> WARNING!!!</b> In pre-omniORB 2.8.0 releases, it is unclear in the CORBA
specification whether or not object references should be managed by an Any.
The omniORB2 implementation leaves management of an extracted object
reference to the caller. Therefore, the programmer should release object
references and TypeCodes that have been extracted from an Any. The same
also applies to string extraction. CORBA 2.3 has clarified this issue and
decreed that the management of an extracted object reference still belongs
to the Any! Since 2.8.0, the omniORB2 implementation conforms to the CORBA
2.3 specification. For backward compatibility, the runtime variable <tt>
omniORB::omniORB_27_CompatibleAnyExtraction</tt> can be set to 1 to get back
the old behaviour. Notice that this should be used as a transitional
measure and in the long run, applications should be written to use the new
behaviour.
<P>
If the extraction fails, the caller's pointer will be set to point to null.
<P>
Note that there are special rules for inserting and extracting arrays
(using <tt> _forany</tt> types), and for inserting and extracting booleans,
octets, chars, and bounded strings. Please refer to the C++ Mapping chapter
of the CORBA 2 specification [<A HREF="node15.html#corba2spec">OMG99a</A>] for further information.
<P>
<H1><A NAME=SECTION001020000000000000000> Type Any in omniORB2</A></H1>
<P>
<A NAME=anyOmniORB2>&#160;</A>
<P>
This section contains some notes on the use and behaviour of type Any in 
omniORB2.
<P>
<H4><A NAME=SECTION001020010000000000000> Generating Insertion and Extraction Operators.</A></H4>
<P>
To generate type Any insertion and extraction operators for constructed 
types and interfaces, the <tt> -a </tt>command line flag should be specified when 
running <tt> omniidl2</tt>.
<P>
<H4><A NAME=SECTION001020020000000000000> TypeCode comparison when extracting from an Any.</A></H4>
<P>
When an attempt is made to extract a type from an Any, the TypeCode of the
type is checked for <b> equivalence</b> with the TypeCode of the type stored
by the Any. The equivalent() test in the TypeCode interface is used for this
purpose<A NAME=tex2html20 HREF="footnode.html#1273"><IMG ALIGN=BOTTOM ALT="gif" SRC="http://www.uk.research.att.com/latex2html/icons/foot_motif.gif"></A>.
<P>
 Examples:
<P>

<PRE>// IDL 1

typedef double Double1;

struct Test1 {
Double1 a;
};


------


// IDL 2

typedef double Double2;

struct Test1 {
  Double2 a;
};
</PRE>

<P>
If an attempt is made to extract the type <tt> Test1 </tt>defined in IDL 1 from an
Any containing the <tt> Test1 </tt>defined in IDL 2, this will succeed (and 
vice-versa), as the two types differ only by an alias.
<P>
<H4><A NAME=SECTION001020030000000000000> Object references.</A></H4>
<P>
<b> WARNING!!</b> In pre-omniORB 2.8.0 releases, the type Any does not manage
object reference types - it was unclear in the pre-2.3 CORBA specification
whether this is required or not. Therefore, the programmer should release
object references and pseudo-objects (such as TypeCode) that have been
extracted from an Any. Type Any will, however, manage constructed types (as
per the CORBA 2 specification) - constructed types extracted from an Any
should not be deleted, as they will be deleted by the Any when it is
destroyed. CORBA 2.3 has clarified this issue and decreed that the
management of an extracted object reference still belongs to the Any! Since
2.8.0, the omniORB2 implementation conforms to the CORBA 2.3
specification. For backward compatibility, the runtime variable <tt>
omniORB::omniORB_27_CompatibleAnyExtraction</tt> can be set to 1 to get back
the old behaviour.
<P>
<H4><A NAME=SECTION001020040000000000000> Top-level aliases.</A></H4>
<P>
When a type is inserted into an Any, the Any stores both the value of the
type and the TypeCode for that type. The treatment of top-level aliases
from omniORB 2.8.0 onwards is different from pre-omniORB 2.8.0 releases.
<P>
In pre-omniORB 2.8.0 releases, if there are any top-level <tt> tk_alias</tt>
TypeCodes in the TypeCode, they will be removed from the TypeCode stored in
the Any. Note that this does not affect the <tt> _tc_ </tt>TypeCode generated
to represent the type (see section on TypeCode, below). This behaviour is
necessary, as two types that differ only by a top-level alias can use the
same insertion and extraction operators. If the <tt> tk_alias</tt> is not
removed, one of the types could be transmitted with an incorrect <tt>
tk_alias</tt> TypeCode. Example:
<P>

<PRE>// IDL 3

typedef sequence&lt;double&gt; seqDouble1;
typedef sequence&lt;double&gt; seqDouble2;
typedef seqDouble2       seqDouble3;
</PRE>

<P>
If either seqDouble1 or seqDouble2 is inserted into an Any, the TypeCode
stored will be for a <tt> sequence&lt;double&gt;</tt>, and not for an alias to a 
<tt> sequence&lt;double&gt;</tt>.
<P>
From omniORB 2.8.0 onwards, there are two changes. Firstly, in the example,
seqDouble1 and seqDouble2 are now distinct types and therefore each has its
own set of C++ operators for Any insertion and extraction. Secondly, the
top level aliases are not removed. For example, if seqDouble3 is inserted
into an Any, the insertion operator for seqDouble2 is invoked (because 
seqDouble3 is just a C++ typedef of seqDouble2). Therefore, the typecode in
the Any would be that of seqDouble2. If this is not desirable, one can use
the new member function 'void type(TypeCode_ptr)' of the Any interface to
explicitly set the typecode to the correct one.
<P>
<H4><A NAME=SECTION001020050000000000000> Removing aliases from TypeCodes.</A></H4>
<P>
Some ORBs (e.g. Orbix) will not accept TypeCodes containing <tt> tk_alias</tt> 
TypeCodes. When using type Any while interoperating with these ORBs, it is 
necessary to remove <tt> tk_alias</tt> TypeCodes from throughout the TypeCode 
representing a constructed type.
<P>
To remove all <tt> tk_alias</tt> TypeCodes from TypeCodes stored in Anys,
supply the <tt> -ORBtcAliasExpand 1 </tt> command-line flag when running an
omniORB2 executable. There will be some (small) performance penalty when
inserting values into an Any.
<P>
Note that the <tt> _tc_ </tt>TypeCodes generated for all constructed types will 
contain the complete TypeCode for the type (including any <tt> tk_alias</tt> 
TypeCodes), regardless of whether the <tt> -ORBtcAliasExpand</tt> flag is set to 1
or not.
<P>
<H4><A NAME=SECTION001020060000000000000> Recursive TypeCodes.</A></H4>
<P>
omniORB2 does now (as of version 2.7) support recursive TypeCodes. This
means that types such as the following can be inserted or extracted from
an Any:

<PRE>   
// IDL 4

struct Test4 {
  sequence&lt;Test4&gt; a;
};
</PRE>

<P>
<H4><A NAME=SECTION001020070000000000000> Type-unsafe construction and insertion.</A></H4>
<P>
If using the type-unsafe Any constructor, or the <tt> CORBA::Any::replace()</tt> 
member function, ensure that the value returned by the 
<tt> CORBA::Any::value()</tt> member function and the TypeCode returned by the 
<tt> CORBA::Any::type()</tt> member function are used as arguments to the 
constructor or function. Using other values or TypeCodes may result in a 
mismatch, and is undefined behaviour.
<P>
Note that a non-CORBA 2 function, 

<PRE>   CORBA::ULong CORBA::Any::NP_length() const
</PRE>

is supplied. This member function returns the length of the value returned 
by the <tt> CORBA::Any::value() </tt>member function. It may be necessary to use 
this function if the Any's value is to be stored in a file.
<P>
<H4><A NAME=SECTION001020080000000000000> Threads and type Any.</A></H4>
<P>
Inserting and extracting simultaneously from the same Any (in 2 different 
threads) is undefined behaviour.
<P>
Extracting simultaneously from the same Any (in 2 or more different threads)
also leads to undefined behaviour.
It was decided not to protect the Any with a mutex, as this condition
should rarely arise, and adding a mutex would lead to performance penalties.
<P>
<H1><A NAME=SECTION001030000000000000000> TypeCode in omniORB2</A></H1>
<P>
This section contains some notes on the use and behaviour of TypeCode in 
omniORB2
<P>
<H4><A NAME=SECTION001030010000000000000> TypeCodes in IDL.</A></H4>
<P>
When using TypeCodes in IDL, note that they are defined in the CORBA scope.
Therefore, CORBA::TypeCode should be used. Example:

<PRE>// IDL 5

struct Test5 {
  long length;
  CORBA::TypeCode desc;
};
</PRE>

<P>
<H4><A NAME=SECTION001030020000000000000> orb.idl</A></H4>
<P>
Inclusion of the file <tt> orb.idl </tt>in IDL using CORBA::TypeCode is optional.
An empty orb.idl file is provided for compatibility purposes.
<P>
<H4><A NAME=SECTION001030030000000000000> Generating TypeCodes for constructed types.</A></H4>
<P>
To generate a TypeCode for constructed types, specify the <tt> -a</tt>
command-line flag when running omniidl2. This will generate a <tt> _tc_</tt> 
TypeCode describing the type, at the same scope as the type (as per the 
CORBA 2 specification). Example:
<P>

<PRE>// IDL 6

struct Test6 {
 double a;
 sequence&lt;long&gt; b;
};
</PRE>

<P>
A TypeCode, <tt> _tc_Test6</tt>, will be generated to describe the struct 
<tt> Test6</tt>. The operations defined in the TypeCode interface (see 
section 6.7.1 of the CORBA 2 specification [<A HREF="node15.html#corba2spec">OMG99a</A>] ) can be used to
query the TypeCode about the type it represents.
<P>
<H4><A NAME=SECTION001030040000000000000> TypeCode equality.</A></H4>
<P>
The behaviour of <tt> CORBA::TypeCode::equal()</tt> member function from
omniORB 2.8.0 onwards is different from pre-omniORB 2.8.0 releases.
In summary, the pre-omniORB 2.8.0 is close to the semantics of the new <tt>
CORBA::TypeCode::equivalent()</tt> member function. Details are as follows:
<P>
The <tt> CORBA::TypeCode::equal()</tt> member function will return true only if
the two TypeCodes are <b> exactly</b> the same. <tt> tk_alias</tt> TypeCodes are
included in this comparison, unlike the comparison made when values are
extracted from an Any (see section on Any, above).
<P>
In pre-omniORB 2.8.0 releases, equality test would ignore the optional
fields when one of the fields in the two typecodes is empty. For example,
if one of the TypeCodes being checked is a <tt> tk_struct</tt>, <tt>
tk_union</tt>, <tt> tk_enum</tt>, or <tt> tk_alias</tt>, and has an empty repository
ID parameter, then the repository ID parameter will be ignored when
checking for equality.  Similarly, if the <tt> name </tt>or <tt> member_name
</tt>parameters of a TypeCode are empty strings, they will be ignored for
equality checking purposes. This is because a CORBA 2 ORB does not have to
include these parameters in a TypeCode (see the Interoperability section of
the CORBA 2 specification [<A HREF="node15.html#corba2spec">OMG99a</A>]). Note that these (optional)
parameters are included in TypeCodes generated by omniORB2.
<P>
Since CORBA 2.3, the issue of typecode equality has been clarified. There
is now a new member <tt> CORBA::TypeCode::equivalent()</tt> which provides the
semantics of the <tt> CORBA::TypeCode::equal()</tt> as implemented in
pre-omniORB 2.8.0 releases. So from omniORB 2.8.0 onwards, the <tt>
CORBA::TypeCode::equal()</tt> function has been changed to enforce strict equality.
The pre-2.8.0 behaviour can be obtained with <tt> equivalent()</tt>.
<P>
<H1><A NAME=SECTION001040000000000000000> Source Listing</A></H1>
<P>
<H2><A NAME=SECTION001041000000000000000> anyExample_impl.cc</A></H2>
<P>
<PRE>// anyExample_impl.cc - This is the source code of the example used in 
//                      Chapter 9 &quot;Type Any and TypeCode&quot; of the omniORB2 
//                      users guide.
//
//               This is the object implementation.
//
// Usage: anyExample_impl
//
//        On startup, the object reference is registered with the 
//        COS naming service. The client uses the naming service to
//        locate this object.
//
//        The name which the object is bound to is as follows:
//              root  [context]
//               |
//              text  [context] kind [my_context]
//               |
//              anyExample  [object]  kind [Object]
//

#include &lt;iostream.h&gt;

#include &quot;anyExample.hh&quot;


static CORBA::Boolean bindObjectToName(CORBA::ORB_ptr,CORBA::Object_ptr);


class anyExample_i : public virtual _sk_anyExample {
public:
  anyExample_i() { }
  virtual ~anyExample_i() { }
  virtual CORBA::Any* testOp(const CORBA::Any&amp; a);
};


CORBA::Any* 
anyExample_i::testOp(const CORBA::Any&amp; a) {

  cout &lt;&lt; &quot;Any received, containing: &quot; &lt;&lt; endl;
  
#ifndef NO_FLOAT
  CORBA::Double d;
#endif

  CORBA::Long l;
  const char* str;      // From CORBA 2.3 onwards, uses const char*
                        // instead of char*. 

  const testStruct* tp;   // From CORBA 2.3 onwards, use 
                          // const testStruct* instead of testStruct*


  if (a &gt;&gt;= l) {
    cout &lt;&lt; &quot;Long: &quot; &lt;&lt; l &lt;&lt; endl;
  }
#ifndef NO_FLOAT
  else if (a &gt;&gt;= d) {
    cout &lt;&lt; &quot;Double: &quot; &lt;&lt; d &lt;&lt; endl;
  }
#endif
  else if (a &gt;&gt;= str) {
    cout &lt;&lt; &quot;String: &quot; &lt;&lt; str &lt;&lt; endl;
    // Since 2.8.0 the storage of the extracted string is still
    // owned by the any.
    // In pre-omniORB 2.8.0 releases, the string returned is a copy.
  }
  else if (a &gt;&gt;= tp) {
    cout &lt;&lt; &quot;testStruct: l: &quot; &lt;&lt; tp-&gt;l &lt;&lt; endl;
    cout &lt;&lt; &quot;            s: &quot; &lt;&lt; tp-&gt;s &lt;&lt; endl;
  }
  else {
    cout &lt;&lt; &quot;Unknown value.&quot; &lt;&lt; endl;
  }

  CORBA::Any* ap = new CORBA::Any;
  
  *ap &lt;&lt;= (CORBA::ULong) 314;

  cout &lt;&lt; &quot;Returning Any containing: ULong: 314\n&quot; &lt;&lt; endl;
  return ap;
}


int
main(int argc, char **argv)
{
  CORBA::ORB_ptr orb = CORBA::ORB_init(argc,argv,&quot;omniORB2&quot;);
  CORBA::BOA_ptr boa = orb-&gt;BOA_init(argc,argv,&quot;omniORB2_BOA&quot;);

  anyExample_i *myobj = new anyExample_i();
  myobj-&gt;_obj_is_ready(boa);

  {
    anyExample_var myobjRef = myobj-&gt;_this();
    if (!bindObjectToName(orb,myobjRef)) {
      return 1;
    }
  }

  boa-&gt;impl_is_ready();
  // Tell the BOA we are ready. The BOA's default behaviour is to block
  // on this call indefinitely.

  return 0;
}


static
CORBA::Boolean
bindObjectToName(CORBA::ORB_ptr orb,CORBA::Object_ptr obj)
{
  CosNaming::NamingContext_var rootContext;
  
  try {
    // Obtain a reference to the root context of the Name service:
    CORBA::Object_var initServ;
    initServ = orb-&gt;resolve_initial_references(&quot;NameService&quot;);

    // Narrow the object returned by resolve_initial_references()
    // to a CosNaming::NamingContext object:
    rootContext = CosNaming::NamingContext::_narrow(initServ);
    if (CORBA::is_nil(rootContext)) 
      {
        cerr &lt;&lt; &quot;Failed to narrow naming context.&quot; &lt;&lt; endl;
        return 0;
      }
  }
  catch(CORBA::ORB::InvalidName&amp; ex) {
    cerr &lt;&lt; &quot;Service required is invalid [does not exist].&quot; &lt;&lt; endl;
    return 0;
  }


  try {
    // Bind a context called &quot;test&quot; to the root context:

    CosNaming::Name contextName;
    contextName.length(1);
    contextName[0].id   = (const char*) &quot;test&quot;;    // string copied
    contextName[0].kind = (const char*) &quot;my_context&quot;; // string copied    
    // Note on kind: The kind field is used to indicate the type
    // of the object. This is to avoid conventions such as that used
    // by files (name.type -- e.g. test.ps = postscript etc.)

    CosNaming::NamingContext_var testContext;
    try {
      // Bind the context to root, and assign testContext to it:
      testContext = rootContext-&gt;bind_new_context(contextName);
    }
    catch(CosNaming::NamingContext::AlreadyBound&amp; ex) {
      // If the context already exists, this exception will be raised.
      // In this case, just resolve the name and assign testContext
      // to the object returned:
      CORBA::Object_var tmpobj;
      tmpobj = rootContext-&gt;resolve(contextName);
      testContext = CosNaming::NamingContext::_narrow(tmpobj);
      if (CORBA::is_nil(testContext)) {
        cerr &lt;&lt; &quot;Failed to narrow naming context.&quot; &lt;&lt; endl;
        return 0;
      }
    } 

    // Bind the object (obj) to testContext, naming it anyExample:
    CosNaming::Name objectName;
    objectName.length(1);
    objectName[0].id   = (const char*) &quot;anyExample&quot;;   // string copied
    objectName[0].kind = (const char*) &quot;Object&quot;; // string copied


    // Bind obj with name anyExample to the testContext:
    try {
      testContext-&gt;bind(objectName,obj);
    }
    catch(CosNaming::NamingContext::AlreadyBound&amp; ex) {
      testContext-&gt;rebind(objectName,obj);
    }
    // Note: Using rebind() will overwrite any Object previously bound 
    //       to /test/anyExample with obj.
    //       Alternatively, bind() can be used, which will raise a
    //       CosNaming::NamingContext::AlreadyBound exception if the name
    //       supplied is already bound to an object.
  }
  catch (CORBA::COMM_FAILURE&amp; ex) {
    cerr &lt;&lt; &quot;Caught system exception COMM_FAILURE, unable to contact the &quot;
         &lt;&lt; &quot;naming service.&quot; &lt;&lt; endl;
    return 0;
  }
  catch (omniORB::fatalException&amp; ex) {
    throw;
  }
  catch (...) {
    cerr &lt;&lt; &quot;Caught a system exception while using the naming service.&quot;&lt;&lt; endl;
    return 0;
  }
  return 1;
}
</PRE>
<P>
<H2><A NAME=SECTION001042000000000000000> anyExample_clt.cc</A></H2>
<P>
<PRE>// anyExample_clt.cc -  This is the source code of the example used in 
//                      Chapter 9 &quot;Type Any and TypeCode&quot; of the omniORB2 
//                      users guide.
//
//              This is the client. It uses the COSS naming service
//              to obtain the object reference.
//
// Usage: anyExample_clt
//
//
//        On startup, the client lookup the object reference from the
//        COS naming service.
//
//        The name which the object is bound to is as follows:
//              root  [context]
//               |
//              text  [context] kind [my_context]
//               |
//              anyExample  [object]  kind [Object]
//

#include &lt;iostream.h&gt;
#include &quot;anyExample.hh&quot;

static CORBA::Object_ptr getObjectReference(CORBA::ORB_ptr orb);
static void invokeOp(anyExample_ptr&amp; tobj, const CORBA::Any&amp; a);

int
main (int argc, char **argv) 
{
  CORBA::ORB_ptr orb = CORBA::ORB_init(argc,argv,&quot;omniORB2&quot;);
  CORBA::BOA_ptr boa = orb-&gt;BOA_init(argc,argv,&quot;omniORB2_BOA&quot;);
  CORBA::Object_var obj;
  
  try {
    obj = getObjectReference(orb);
  }
  catch(CORBA::COMM_FAILURE&amp; ex) {
    cerr &lt;&lt; &quot;Caught system exception COMM_FAILURE, unable to contact the &quot;
         &lt;&lt; &quot;object.&quot; &lt;&lt; endl;
    return -1;
  }
  catch(omniORB::fatalException&amp; ex) {
    cerr &lt;&lt; &quot;Caught omniORB2 fatalException. This indicates a bug is caught &quot;
         &lt;&lt; &quot;within omniORB2.\nPlease send a bug report.\n&quot;
         &lt;&lt; &quot;The exception was thrown in file: &quot; &lt;&lt; ex.file() &lt;&lt; &quot;\n&quot;
         &lt;&lt; &quot;                            line: &quot; &lt;&lt; ex.line() &lt;&lt; &quot;\n&quot;
         &lt;&lt; &quot;The error message is: &quot; &lt;&lt; ex.errmsg() &lt;&lt; endl;
    return -1;
  }
  catch(...) {
    cerr &lt;&lt; &quot;Caught a system exception.&quot; &lt;&lt; endl;
    return -1;
  }


  anyExample_ptr tobj = anyExample::_narrow(obj);
  
  if (CORBA::is_nil(tobj)) {
    cerr &lt;&lt; &quot;Can't narrow object reference to type anyExample.&quot; &lt;&lt; endl;
    return -1;
  }


  CORBA::Any a;

  try {
    // Sending Long
    CORBA::Long l = 100;
    a &lt;&lt;= l;
    cout &lt;&lt; &quot;Sending Any containing Long: &quot; &lt;&lt; l &lt;&lt; endl; 
    invokeOp(tobj,a);
    
    // Sending Double
#ifndef NO_FLOAT
    CORBA::Double d = 1.2345;
    a &lt;&lt;= d;
    cout &lt;&lt; &quot;Sending Any containing Double: &quot; &lt;&lt; d &lt;&lt; endl; 
    invokeOp(tobj,a);
#endif
  
    // Sending String
    const char* str = &quot;Hello&quot;;
    a &lt;&lt;= str;
    cout &lt;&lt; &quot;Sending Any containing String: &quot; &lt;&lt; str &lt;&lt; endl;
    invokeOp(tobj,a);
    
    // Sending testStruct  [Struct defined in IDL]
    testStruct t;
    t.l = 456;
    t.s = 8;
    a &lt;&lt;= t;
    cout &lt;&lt; &quot;Sending Any containing testStruct: l: &quot; &lt;&lt; t.l &lt;&lt; endl;
    cout &lt;&lt; &quot;                                   s: &quot; &lt;&lt; t.s &lt;&lt; endl;
    invokeOp(tobj,a);
  }
  catch(CORBA::COMM_FAILURE&amp; ex) {
    cerr &lt;&lt; &quot;Caught system exception COMM_FAILURE, unable to contact the &quot;
         &lt;&lt; &quot;object.&quot; &lt;&lt; endl;
    return -1;
  }
  catch(omniORB::fatalException&amp; ex) {
    cerr &lt;&lt; &quot;Caught omniORB2 fatalException. This indicates a bug is caught &quot;
         &lt;&lt; &quot;within omniORB2.\nPlease send a bug report.\n&quot;
         &lt;&lt; &quot;The exception was thrown in file: &quot; &lt;&lt; ex.file() &lt;&lt; &quot;\n&quot;
         &lt;&lt; &quot;                            line: &quot; &lt;&lt; ex.line() &lt;&lt; &quot;\n&quot;
         &lt;&lt; &quot;The error message is: &quot; &lt;&lt; ex.errmsg() &lt;&lt; endl;
    return -1;
  }
  catch(...) {
    cerr &lt;&lt; &quot;Caught a system exception.&quot; &lt;&lt; endl;
    return -1;
  }
	
  return 0;
}

static 
CORBA::Object_ptr
getObjectReference(CORBA::ORB_ptr orb)
{
  CosNaming::NamingContext_var rootContext;
  
  try {
    // Obtain a reference to the root context of the Name service:
    CORBA::Object_var initServ;
    initServ = orb-&gt;resolve_initial_references(&quot;NameService&quot;);

    // Narrow the object returned by resolve_initial_references()
    // to a CosNaming::NamingContext object:
    rootContext = CosNaming::NamingContext::_narrow(initServ);
    if (CORBA::is_nil(rootContext)) 
      {
        cerr &lt;&lt; &quot;Failed to narrow naming context.&quot; &lt;&lt; endl;
        return CORBA::Object::_nil();
      }
  }
  catch(CORBA::ORB::InvalidName&amp; ex) {
    cerr &lt;&lt; &quot;Service required is invalid [does not exist].&quot; &lt;&lt; endl;
    return CORBA::Object::_nil();
  }


  // Create a name object, containing the name test/context:
  CosNaming::Name name;
  name.length(2);

  name[0].id   = (const char*) &quot;test&quot;;       // string copied
  name[0].kind = (const char*) &quot;my_context&quot;; // string copied
  name[1].id   = (const char*) &quot;anyExample&quot;;
  name[1].kind = (const char*) &quot;Object&quot;;
  // Note on kind: The kind field is used to indicate the type
  // of the object. This is to avoid conventions such as that used
  // by files (name.type -- e.g. test.ps = postscript etc.)

  
  CORBA::Object_ptr obj;
  try {
    // Resolve the name to an object reference, and assign the reference 
    // returned to a CORBA::Object:
    obj = rootContext-&gt;resolve(name);
  }
  catch(CosNaming::NamingContext::NotFound&amp; ex)
    {
      // This exception is thrown if any of the components of the
      // path [contexts or the object] aren't found:
      cerr &lt;&lt; &quot;Context not found.&quot; &lt;&lt; endl;
      return CORBA::Object::_nil();
    }
  catch (CORBA::COMM_FAILURE&amp; ex) {
    cerr &lt;&lt; &quot;Caught system exception COMM_FAILURE, unable to contact the &quot;
         &lt;&lt; &quot;naming service.&quot; &lt;&lt; endl;
    return CORBA::Object::_nil();
  }
  catch(omniORB::fatalException&amp; ex) {
    throw;
  }
  catch (...) {
    cerr &lt;&lt; &quot;Caught a system exception while using the naming service.&quot;&lt;&lt; endl;
    return CORBA::Object::_nil();
  }
  return obj;
}


static void 
invokeOp(anyExample_ptr&amp; tobj, const CORBA::Any&amp; a)
{
  CORBA::Any_var bp;

  cout &lt;&lt; &quot;Invoking operation.&quot; &lt;&lt; endl;
  bp = tobj-&gt;testOp(a);

  cout &lt;&lt; &quot;Operation completed. Returned Any: &quot;;
  CORBA::ULong ul;

  if (bp &gt;&gt;= ul) {
    cout &lt;&lt; &quot;ULong: &quot; &lt;&lt; ul &lt;&lt; &quot;\n&quot; &lt;&lt; endl;
  }
  else {
    cout &lt;&lt; &quot;Unknown value.&quot; &lt;&lt; &quot;\n&quot; &lt;&lt; endl;
  }
}
</PRE>
<P>

<BR> <HR><A NAME=tex2html330 HREF="node11.html"><IMG ALIGN=BOTTOM ALT="next" SRC="http://www.uk.research.att.com/latex2html/icons/next_motif.gif"></A>   <A NAME=tex2html328 HREF="omniORB2.html"><IMG ALIGN=BOTTOM ALT="up" SRC="http://www.uk.research.att.com/latex2html/icons/up_motif.gif"></A>   <A NAME=tex2html322 HREF="node9.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="http://www.uk.research.att.com/latex2html/icons/previous_motif.gif"></A>   <A NAME=tex2html332 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="http://www.uk.research.att.com/latex2html/icons/contents_motif.gif"></A>      <BR>
<B> Next:</B> <A NAME=tex2html331 HREF="node11.html"> Dynamic Management of </A>
<B>Up:</B> <A NAME=tex2html329 HREF="omniORB2.html">No Title</A>
<B> Previous:</B> <A NAME=tex2html323 HREF="node9.html"> Proxy Objects</A>
<BR> <HR> <P>
<BR> <HR>
<P><ADDRESS>
<I>Sai Lai Lo <BR>
Fri Jul  2 17:38:50 BST 1999</I>
</ADDRESS>
</BODY>
