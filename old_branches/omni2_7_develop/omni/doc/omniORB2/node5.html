<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN">
<!Converted with LaTeX2HTML 95 (Thu Jan 19 1995) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds >
<HEAD>
<TITLE> The omniORB2 API</TITLE>
</HEAD>
<BODY>
<meta name="description" value=" The omniORB2 API">
<meta name="keywords" value="omniORB2">
<meta name="resource-type" value="document">
<meta name="distribution" value="global">
<P>
 <BR> <HR><A NAME=tex2html272 HREF="node6.html"><IMG ALIGN=BOTTOM ALT="next" SRC="next_motif.gif"></A>   <A NAME=tex2html270 HREF="omniORB2.html"><IMG ALIGN=BOTTOM ALT="up" SRC="up_motif.gif"></A>   <A NAME=tex2html264 HREF="node4.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="previous_motif.gif"></A>   <A NAME=tex2html274 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="contents_motif.gif"></A>      <BR>
<B> Next:</B> <A NAME=tex2html273 HREF="node6.html"> The Basic Object </A>
<B>Up:</B> <A NAME=tex2html271 HREF="omniORB2.html">No Title</A>
<B> Previous:</B> <A NAME=tex2html265 HREF="node4.html"> IDL to C++ </A>
<BR> <HR> <P>
<H1><A NAME=SECTION00500000000000000000> The omniORB2 API</A></H1>
<P>

<A NAME=omniorb2api>&#160;</A>
<P>
In this chapter, we introduce the omniORB2 API. The purpose
of this API is to provide access points to omniORB2 specific
functionalities that are not covered by the CORBA specification.
Obviously, if you use this API in your application, that part of your code
is not going to be portable to run unchanged on other vendors' ORBs. To
make it easier to identify omniORB2 dependent code, this API is defined
under the name space ``omniORB''<A NAME=tex2html16 HREF="footnode.html#340"><IMG ALIGN=BOTTOM ALT="gif" SRC="foot_motif.gif"></A>.
<P>
<H1><A NAME=SECTION00510000000000000000> ORB and BOA initialisation options</A></H1>
<P>
<A NAME=omniorbapioptions>&#160;</A>
<P>
<tt> CORBA::ORB_init</tt> accepts the following command-line arguments:
<P>
<DL ><DT><tt> -ORBid ``omniORB2''
<DD> The identifier supplied must be ``omniORB2''.
<DT><tt> -ORBtraceLevel &lt;level&gt;
<DD> See section <A HREF="node5.html#rttrace">4.2</A>.
<DT><tt> -ORBserverName &lt;string&gt;
<DD> See section <A HREF="node5.html#sec_servername">4.3</A>.
<DT><tt> -ORBtcAliasExpand &lt;0 or 1&gt;
<DD> See section <A HREF="node10.html#anyOmniORB2">9.2</A>.
<DT><tt> -ORBgiopMaxMsgSize &lt;size in bytes&gt;
<DD> See section <A HREF="node5.html#giopmsg">4.5</A>.
<DT><tt> -ORBInitialHost &lt;string&gt;
<DD> See section <A HREF="node5.html#bootstrap">4.6</A>.
<DT><tt> -ORBInitialPort &lt;1-65535&gt;
<DD> See section <A HREF="node5.html#bootstrap">4.6</A>.
<DT><tt> -ORBdiiThrowsSysExceptions &lt;0 or 1&gt;
<DD> See section <A HREF="node12.html#dii_invoke">11.4</A>.
<DT><tt> -ORBinConScanPeriod &lt;0-65535&gt;
<DD> See section <A HREF="node8.html#sec_shut">7.3</A>.
<DT><tt> -ORBoutConScanPeriod &lt;0-65535&gt;
<DD> See section <A HREF="node8.html#sec_shut">7.3</A>.
<P>
 </DL>
<P>
<tt> BOA_init</tt> accepts the following command-line arguments:
<P>
<DL ><DT><tt> -BOAid ``omniORB2_BOA''
<DD> The identifier supplied must be ``omniORB2_BOA''.
<DT><tt> -BOAiiop_port &lt;port number&gt;
<DD> This option tells the BOA which
TCP/IP port to use to accept IIOP calls. If this option is not specified,
the BOA will use an arbitrary port assigned by the operating system.
<DT><tt> -BOAno_bootstrap_agent
<DD> See section <A HREF="node5.html#bootstrap">4.6</A>.
<P>
 </DL>
<P>
By default, the BOA can work out the IP address of the host machine. This
address is recorded in the object references of the local objects.
However, when the host has multiple network interfaces and multiple IP
addresses, it may be desirable for the application to control what address
the BOA should use. This can be done by defining the environment variable
<tt> OMNIORB_USEHOSTNAME</tt> to contain the preferred host name or IP
address in dot-numeric form.
<P>
As defined in the CORBA specification, any command-line arguments
understood by the ORB/BOA will be removed from <tt> argv</tt> when the
initialisation functions return. Therefore, an application is not required
to handle any command-line arguments it does not understand.
<P>
</tt></tt></tt></tt></tt></tt></tt></tt></tt></tt></tt></tt></tt><H1><A NAME=SECTION00520000000000000000> Run-time Tracing and Diagnostic Messages</A></H1>
<P>
<A NAME=rttrace>&#160;</A>
<P>
OmniORB2 uses the C++ iostream <tt> cerr</tt> to output any tracing and
diagnostic messages. Some or all of these messages can be turned-on/off by
setting the variable <tt> omniORB::traceLevel</tt>. The type definition of
the variable is:
<P>

<PRE>CORBA::ULong omniORB::traceLevel = 1;  // The default value is 1
</PRE>

<P>
At the moment, the following trace levels are defined:
<P>
<DL ><DT>level 0
<DD> turn off all tracing and informational messages
<DT>level 1
<DD> informational messages only
<DT>level 2
<DD> the above plus configuration information
<DT>level 5
<DD> the above plus notifications when server threads are created
or communication endpoints are shutdown
<DT>level 10-20
<DD> the above plus execution traces
<P>
 </DL>
<P>
The variable can be changed by assignment inside your applications. It can
also be changed by specifying the command-line option: <tt> -ORBtraceLevel
&lt;level&gt;</tt>. For instance:
<P>

<PRE>$ eg2_impl -ORBtraceLevel 5
</PRE>

<P>

<P>
<H1><A NAME=SECTION00530000000000000000> Server Name</A></H1>
<P>
<A NAME=sec_servername>&#160;</A>
<P>
Applications can optionally specified a name to identify the server
process. At the moment, this name is only used by the host-based access
control module. See section <A HREF="node8.html#sec_accept">7.5</A> for details.
<P>
The name is stored in the variable <tt> omniORB::serverName</tt>.
<P>

<PRE>CORBA::String_var omniORB::serverName;
</PRE>

<P>
The variable can be changed by assignment inside your applications. It can
also be changed by specifying the command-line option: <tt> -ORBserverName
&lt;string&gt;</tt>.
<P>
<H1><A NAME=SECTION00540000000000000000> Object Keys</A></H1>
<P>
OmniORB2 uses a data type <tt> omniORB::objectKey</tt> to uniquely
identify each object implementation. This is an opaque data type and 
can only be manipulated by the following functions:
<P>

<PRE>void omniORB::generateNewKey(omniORB::objectKey &amp;k);
</PRE>

<P>
<tt> omniORB::generateNewKey</tt> returns a new <tt> objectKey</tt>. The return
value is guaranteed to be unique among the keys generated during this program
run. On the platforms that have a realtime clock and unique process
identifiers, a stronger assertion can be made, i.e. the keys are guaranteed
to be unique among all keys ever generated on the same machine.
<P>

<PRE>const unsigned int omniORB::hash_table_size;
int omniORB::hash(omniORB::objectKey&amp; k);
</PRE>

<P>
<tt> omniORB::hash</tt> returns the hash value of an <tt> objectKey</tt>. The value
returned by this function is always between 0 and <tt>
omniORB:hash_table_size - 1</tt> inclusively.
<P>

<PRE>omniORB::objectKey omniORB::nullkey();
</PRE>

<P>
<tt> omniORB::nullkey</tt> always returns the same <tt> objectKey</tt> value. This
key is guaranteed to hash to 0.
<P>

<PRE>int operator==(const omniORB::objectKey &amp;k1,const omniORB::objectKey &amp;k2);
int operator!=(const omniORB::objectKey &amp;k1,const omniORB::objectKey &amp;k2);
</PRE>

<P>
<tt> ObjectKeys</tt> can be tested for equality using the overloaded <tt>
operator==</tt> and <tt> operator!=</tt>.
<P>

<PRE>omniORB::seqOctets*
omniORB::keyToOctetSequence(const omniORB::objectKey &amp;k1);

omniORB::objectKey
omniORB::octetSequenceToKey(const omniORB::seqOctets&amp; seq);
</PRE>

<P>
<tt> omniORB::keyToOctetSequence</tt> takes an <tt> objectKey</tt> and returns its
externalised representation in the form of a sequence of octets. The same
sequence can be converted back to an <tt> objectKey</tt> using <tt>
omniORB::octetSequenceToKey</tt>. If the supplied sequence is not an <tt>
objectKey</tt>, <tt> omniORB::octetSequenceToKey</tt> raises a <tt> CORBA::MARSHAL</tt>
exception.
<P>
<H1><A NAME=SECTION00550000000000000000> GIOP Message Size</A></H1>
<P>
<A NAME=giopmsg>&#160;</A>
<P>
omniORB2 sets a limit on the GIOP message size that can be sent or
received. The value can be obtained by calling:

<PRE>size_t omniORB::MaxMessageSize();
</PRE>

 and can be changed by:
<P>

<PRE>void omniORB::MaxMessageSize(size_t newvalue);
</PRE>

<P>
 or by the command-line option <tt> -ORBgiopMaxMsgSize</tt>.
<P>
The exact value is somewhat arbitrary. The reason such a limit exists is to
provide some way to protect the server side from resource exhaustion. Think
about the case when the server receives a rogue GIOP(IIOP) request message
that contains a sequence length field set to 2**31. With a reasonable
message size limit, the server can reject this rogue message straight away.
<P>
<H1><A NAME=SECTION00560000000000000000> Initial Object Reference Bootstrapping</A></H1>
<P>
<A NAME=bootstrap>&#160;</A>
<P>
Starting from 2.6.0, a new mechanism is available for the ORB runtime to
obtain the initial object references to CORBA services. Previously, it is
necessary to write the IOR string of these services in the configuration
file (section <A HREF="node2.html#setup">1.2</A>). Now the object references can be obtained from
a bootstrap service. The bootstrap service is a special object with the
object key 'INIT' and the following interface<A NAME=tex2html17 HREF="footnode.html#409"><IMG ALIGN=BOTTOM ALT="gif" SRC="foot_motif.gif"></A>.:
<P>

<P>
<PRE>     // IDL
     module CORBA {
        interface InitialReferences {
            Object get(in ORB::ObjectId id);
            // returns the initial object reference of the service
            // identified by &lt;id&gt;. For example the id for the COSS
            // Naming service is &quot;NameService&quot;.

            ORB::ObjectIdList list();
            // returns the list of service id that this agent knows of
            // their initial object reference.
        };
     };
</PRE>

<P>
By default, all omniORB2 servers, i.e. those applications with the BOA
initialised, contains an instance of this object and is able to responds to
remote invocations. To prevent the ORB from instantiating this object, the
command-line option <tt> -BOAno_bootstrap_agent</tt> should be specified.
<P>
In particular, the Naming Service omniNames is able to respond to a query
through this interface and returns the object reference of its root
context. In effect, the bootstrap agent provides a level of indirection.
All omniORB2 clients still have to be supplied with the address of the
bootstrap agent. However the information is much easier to specify than a
stringified IOR! Another advantage of this approach is that it is
completely compatiable with JavaIDL. This makes it possible for a client
written in JavaIDL to share with a omniORB2 server the same Naming Service.
<P>
The address of the bootstrap agent is given by the <tt> ORBInitialHost</tt> and
<tt> ORBInitialPort</tt> parameter in the omniORB configuration file
(section <A HREF="node2.html#setup">1.2</A>). The parameters can also be specified as command-line
options (section <A HREF="node5.html#omniorbapioptions">4.1</A>). <tt> ORBInitialHost</tt> is the host
name and <tt> ORBInitialPort</tt> is the TCP/IP port number. The parameter <tt>
ORBInitialPort</tt> is optional. If it is not specified, port number 900 will
be used.
<P>
During initialisation, the ORB reads the parameters in the omniORB
configuration file. If the parameter <tt> NAMESERVICE</tt> is specified, the
stringified IOR would be used as the object reference of the root naming
context. If the parameter is absent and the parameter <tt> ORBInitialHost</tt>
is present, the ORB would contact the bootstrap agent at the address
specified to obtain the root naming context when the application calls <tt>
resolve_initial_reference()</tt>. If neither the <tt> NAMESERVICE</tt> nor <tt>
ORBInitialHost</tt> is present, a call to <tt> resolve_initial_reference()</tt>
returns a nil object. Finally, the command line argument <tt>
-ORBInitialHost</tt> overrides any parameters in the configuration file. The
ORB would always contact the bootstrap agent at the address specified to
obtain the root naming context.
<P>
Now we are ready to describe a simple way to set up omniNames.
<P>
<OL><LI> Start omniNames for the first time on a machine (e.g. wobble):
<P>
<tt> $ omniNames -start 1234</tt>
<P>
<LI> Add to omniORB.cfg:
<P>
<tt> ORBInitialHost wobble</tt>
<P>
<tt> ORBInitialPort 1234</tt>
<P>
<LI> All omniORB2 applications will now be able to contact omniNames.
<P>
</OL>
<P>
Alternatively, the command line options can be used, for example:
<P>
<tt> $ eg3_impl -ORBInitialHost wobble -ORBInitialPort 1234 &amp;</tt>
<P>
<tt> $ eg3_clt -ORBInitialHost wobble -ORBInitialPort 1234</tt>
<P>
<H1><A NAME=SECTION00570000000000000000> Trapping omniORB2 Internal Errors</A></H1>
<P>

<PRE>class fatalException {
public:
    const char *file() const;
    int line() const;
    const char *errmsg() const;
};
</PRE>

<P>
When omniORB2 detects an internal inconsistency that is most likely to be
caused by a bug in the runtime, it raises the exception <tt>
omniORB::fatalException</tt>.  When this exception is raised, it is not
sensible to proceed with any operation that involves the ORB's runtime. It
is best to exit the program immediately. The exception structure carries by
<tt> omniORB::fatalException</tt> contains the exact location (the file name
and the line number) where the exception is raised. You are strongly
encourage to file a bug report and point out the location.
<P>

<BR> <HR><A NAME=tex2html272 HREF="node6.html"><IMG ALIGN=BOTTOM ALT="next" SRC="next_motif.gif"></A>   <A NAME=tex2html270 HREF="omniORB2.html"><IMG ALIGN=BOTTOM ALT="up" SRC="up_motif.gif"></A>   <A NAME=tex2html264 HREF="node4.html"><IMG ALIGN=BOTTOM ALT="previous" SRC="previous_motif.gif"></A>   <A NAME=tex2html274 HREF="node1.html"><IMG ALIGN=BOTTOM ALT="contents" SRC="contents_motif.gif"></A>      <BR>
<B> Next:</B> <A NAME=tex2html273 HREF="node6.html"> The Basic Object </A>
<B>Up:</B> <A NAME=tex2html271 HREF="omniORB2.html">No Title</A>
<B> Previous:</B> <A NAME=tex2html265 HREF="node4.html"> IDL to C++ </A>
<BR> <HR> <P>
<BR> <HR>
<P><ADDRESS>
<I>David Riddoch <BR>
Wed Feb 24 14:48:15 GMT 1999</I>
</ADDRESS>
</BODY>
