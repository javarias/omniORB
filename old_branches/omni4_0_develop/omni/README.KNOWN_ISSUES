Known issues with omniORB 3.0.0
===============================

1. HPUX 11.00 - python

   On this platform, dlopen(3) refuses to load any library that contains 
   Thread Local Storage (TLS) and is not loaded during program startup.
   This creates a problem with loading the omniidl C++ support library in
   python. When the library is built with aCC, the library requires the
   runtime library libcl which contains TLS. dlopen refuse to load the library
   because of this dependency.

   It may be possible to rebuild python's main() function with aCC so that
   libcl will be loaded during program startup.

   Another alternative is to build the omniidl C++ support library in
   g++. To do so, replace the make rules for HPUX in 
   <top>/src/lib/omniORB2/omniidl_be/cxx/dir.mk with the following.

   Notice that building other parts of omniORB with g++ on HPUX has not
   been tested and may not work. It is better to stay with aCC for the rest
   of the tree.

#############################################################################
#   Make rules for HPUX                                                     #
#############################################################################

ifdef HPUX

CXX = /usr/common/opt/gcc/bin/g++
CXXOPTIONS = -Wall -Wno-unused
CXXLINKOPTIONS =
DIR_CPPFLAGS += -fpic

libname = _omniidlmodule.sl
soname = $(libname).$(IDLMODULE_MAJOR)
lib = $(soname).$(IDLMODULE_MINOR)

all:: $(lib)

$(lib): $(OBJS) $(PYOBJS)
	(set -x; \
	$(RM) $@; \
	$(CXXLINK) $(CXXLINKOPTIONS) -shared -fpic -o $@ -Wl,+h$(soname) $(IMPOR
T_LIBRARY_FLAGS) \
	$(filter-out $(LibSuffixPattern),$^) $(LIBS)\
	)

clean::
	$(RM) $(lib)

export:: $(lib)
	@$(ExportLibrary)
	@(set -x; \
	  cd $(EXPORT_TREE)/$(LIBDIR); \
          $(RM) $(soname); \
          ln -s $(lib) $(soname); \
          $(RM) $(libname); \
          ln -s $(soname) $(libname); \
         )

endif


2. Sun C++ compiler v5.0 (or Forte Workshop v6.0)

   omniORB servers or clients built with this compiler frequently core-dump
   on a Solaris 2.7 SMP machine when simulataneously multiple connections
   are bloken. This can be provoked by running multiple threads in a client
   program, all poking the same remote object and then kill the server or 
   the client. Looking at the stack trace under dbx, it seems to go wrong in 
   the exception unwinding when more than one thread is in the unwinding
   state. Effort to reproduce the bug in a small test program has been
   unsuccessful.
   Investigation continues. 

