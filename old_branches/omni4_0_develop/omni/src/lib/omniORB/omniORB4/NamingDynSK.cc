// This file is generated by omniidl (C++ backend)- omniORB_3_0. Do not edit.

#include "Naming.hh"
#include <omniORB4/tcDescriptor.h>

static const char* _0RL_library_version = omniORB_4_0;

static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mIstring = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNaming/Istring:1.0", "Istring", CORBA::TypeCode::PR_string_tc(0));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CosNaming {
  const CORBA::TypeCode_ptr _tc_Istring = _0RL_tc_CosNaming_mIstring;
}
#else
const CORBA::TypeCode_ptr CosNaming::_tc_Istring = _0RL_tc_CosNaming_mIstring;
#endif

static CORBA::PR_structMember _0RL_structmember_CosNaming_mNameComponent[] = {
  {"id", _0RL_tc_CosNaming_mIstring},
  {"kind", _0RL_tc_CosNaming_mIstring}
};

static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mNameComponent = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CosNaming/NameComponent:1.0", "NameComponent", _0RL_structmember_CosNaming_mNameComponent, 2);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CosNaming {
  const CORBA::TypeCode_ptr _tc_NameComponent = _0RL_tc_CosNaming_mNameComponent;
}
#else
const CORBA::TypeCode_ptr CosNaming::_tc_NameComponent = _0RL_tc_CosNaming_mNameComponent;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mName = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNaming/Name:1.0", "Name", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CosNaming_mNameComponent));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CosNaming {
  const CORBA::TypeCode_ptr _tc_Name = _0RL_tc_CosNaming_mName;
}
#else
const CORBA::TypeCode_ptr CosNaming::_tc_Name = _0RL_tc_CosNaming_mName;
#endif

static const char* _0RL_enumMember_CosNaming_mBindingType[] = { "nobject", "ncontext" };
static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mBindingType = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/CosNaming/BindingType:1.0", "BindingType", _0RL_enumMember_CosNaming_mBindingType, 2);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CosNaming {
  const CORBA::TypeCode_ptr _tc_BindingType = _0RL_tc_CosNaming_mBindingType;
}
#else
const CORBA::TypeCode_ptr CosNaming::_tc_BindingType = _0RL_tc_CosNaming_mBindingType;
#endif

static CORBA::PR_structMember _0RL_structmember_CosNaming_mBinding[] = {
  {"binding_name", _0RL_tc_CosNaming_mName},
  {"binding_type", _0RL_tc_CosNaming_mBindingType}
};

static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mBinding = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CosNaming/Binding:1.0", "Binding", _0RL_structmember_CosNaming_mBinding, 2);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CosNaming {
  const CORBA::TypeCode_ptr _tc_Binding = _0RL_tc_CosNaming_mBinding;
}
#else
const CORBA::TypeCode_ptr CosNaming::_tc_Binding = _0RL_tc_CosNaming_mBinding;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mBindingList = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNaming/BindingList:1.0", "BindingList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CosNaming_mBinding));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CosNaming {
  const CORBA::TypeCode_ptr _tc_BindingList = _0RL_tc_CosNaming_mBindingList;
}
#else
const CORBA::TypeCode_ptr CosNaming::_tc_BindingList = _0RL_tc_CosNaming_mBindingList;
#endif

static const char* _0RL_enumMember_CosNaming_mNamingContext_mNotFoundReason[] = { "missing_node", "not_context", "not_object" };
static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mNamingContext_mNotFoundReason = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/CosNaming/NamingContext/NotFoundReason:1.0", "NotFoundReason", _0RL_enumMember_CosNaming_mNamingContext_mNotFoundReason, 3);
const CORBA::TypeCode_ptr CosNaming::NamingContext::_tc_NotFoundReason = _0RL_tc_CosNaming_mNamingContext_mNotFoundReason;

static CORBA::PR_structMember _0RL_structmember_CosNaming_mNamingContext_mNotFound[] = {
  {"why", _0RL_tc_CosNaming_mNamingContext_mNotFoundReason},
  {"rest_of_name", _0RL_tc_CosNaming_mName}
};

static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mNamingContext_mNotFound = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/CosNaming/NamingContext/NotFound:1.0", "NotFound", _0RL_structmember_CosNaming_mNamingContext_mNotFound, 2);

const CORBA::TypeCode_ptr CosNaming::NamingContext::_tc_NotFound = _0RL_tc_CosNaming_mNamingContext_mNotFound;

static CORBA::PR_structMember _0RL_structmember_CosNaming_mNamingContext_mCannotProceed[] = {
  {"cxt", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNaming/NamingContext:1.0", "NamingContext")},
  {"rest_of_name", _0RL_tc_CosNaming_mName}
};

static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mNamingContext_mCannotProceed = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/CosNaming/NamingContext/CannotProceed:1.0", "CannotProceed", _0RL_structmember_CosNaming_mNamingContext_mCannotProceed, 2);

const CORBA::TypeCode_ptr CosNaming::NamingContext::_tc_CannotProceed = _0RL_tc_CosNaming_mNamingContext_mCannotProceed;

static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mNamingContext_mInvalidName = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/CosNaming/NamingContext/InvalidName:1.0", "InvalidName", (CORBA::PR_structMember*) 0, 0);
const CORBA::TypeCode_ptr CosNaming::NamingContext::_tc_InvalidName = _0RL_tc_CosNaming_mNamingContext_mInvalidName;

static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mNamingContext_mAlreadyBound = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/CosNaming/NamingContext/AlreadyBound:1.0", "AlreadyBound", (CORBA::PR_structMember*) 0, 0);
const CORBA::TypeCode_ptr CosNaming::NamingContext::_tc_AlreadyBound = _0RL_tc_CosNaming_mNamingContext_mAlreadyBound;

static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mNamingContext_mNotEmpty = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/CosNaming/NamingContext/NotEmpty:1.0", "NotEmpty", (CORBA::PR_structMember*) 0, 0);
const CORBA::TypeCode_ptr CosNaming::NamingContext::_tc_NotEmpty = _0RL_tc_CosNaming_mNamingContext_mNotEmpty;

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CosNaming {
  const CORBA::TypeCode_ptr _tc_NamingContext = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNaming/NamingContext:1.0", "NamingContext");
}
#else
const CORBA::TypeCode_ptr CosNaming::_tc_NamingContext = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNaming/NamingContext:1.0", "NamingContext");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CosNaming {
  const CORBA::TypeCode_ptr _tc_BindingIterator = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNaming/BindingIterator:1.0", "BindingIterator");
}
#else
const CORBA::TypeCode_ptr CosNaming::_tc_BindingIterator = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNaming/BindingIterator:1.0", "BindingIterator");
#endif

static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mNamingContextExt_mStringName = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNaming/NamingContextExt/StringName:1.0", "StringName", CORBA::TypeCode::PR_string_tc(0));

const CORBA::TypeCode_ptr CosNaming::NamingContextExt::_tc_StringName = _0RL_tc_CosNaming_mNamingContextExt_mStringName;

static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mNamingContextExt_mAddress = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNaming/NamingContextExt/Address:1.0", "Address", CORBA::TypeCode::PR_string_tc(0));

const CORBA::TypeCode_ptr CosNaming::NamingContextExt::_tc_Address = _0RL_tc_CosNaming_mNamingContextExt_mAddress;

static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mNamingContextExt_mURLString = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CosNaming/NamingContextExt/URLString:1.0", "URLString", CORBA::TypeCode::PR_string_tc(0));

const CORBA::TypeCode_ptr CosNaming::NamingContextExt::_tc_URLString = _0RL_tc_CosNaming_mNamingContextExt_mURLString;

static CORBA::TypeCode_ptr _0RL_tc_CosNaming_mNamingContextExt_mInvalidAddress = CORBA::TypeCode::PR_exception_tc("IDL:omg.org/CosNaming/NamingContextExt/InvalidAddress:1.0", "InvalidAddress", (CORBA::PR_structMember*) 0, 0);
const CORBA::TypeCode_ptr CosNaming::NamingContextExt::_tc_InvalidAddress = _0RL_tc_CosNaming_mNamingContextExt_mInvalidAddress;

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CosNaming {
  const CORBA::TypeCode_ptr _tc_NamingContextExt = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNaming/NamingContextExt:1.0", "NamingContextExt");
}
#else
const CORBA::TypeCode_ptr CosNaming::_tc_NamingContextExt = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CosNaming/NamingContextExt:1.0", "NamingContextExt");
#endif

void _0RL_delete_CosNaming_mNameComponent(void* _data) {
  CosNaming::NameComponent* _0RL_t = (CosNaming::NameComponent*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CosNaming_mNameComponent(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CosNaming::NameComponent*)_desc->opq_struct)->id);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((CosNaming::NameComponent*)_desc->opq_struct)->kind);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CosNaming_mNameComponent(tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_cCosNaming_mNameComponent(tcDescriptor &_desc, const CosNaming::NameComponent& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CosNaming_mNameComponent;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CosNaming_mNameComponent;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CosNaming::NameComponent& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mNameComponent(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNameComponent, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CosNaming::NameComponent* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mNameComponent(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNameComponent, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CosNaming::NameComponent*& _sp) {
  return _a >>= (const CosNaming::NameComponent*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CosNaming::NameComponent*& _sp) {
  _sp = (CosNaming::NameComponent *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CosNaming::NameComponent;
    _0RL_buildDesc_cCosNaming_mNameComponent(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CosNaming_mNameComponent, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CosNaming_mNameComponent);
      return 1;
    } else {
      delete (CosNaming::NameComponent *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CosNaming_mNameComponent)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cCosNaming_mNameComponent__
#define __0RL_tcParser_buildDesc_s0_cCosNaming_mNameComponent__
static void
_0RL_tcParser_setElementCount_s0_cCosNaming_mNameComponent(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< CosNaming::NameComponent> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCosNaming_mNameComponent(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< CosNaming::NameComponent> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCosNaming_mNameComponent(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCosNaming_mNameComponent(_newdesc, (*((_CORBA_Unbounded_Sequence< CosNaming::NameComponent> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCosNaming_mNameComponent(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< CosNaming::NameComponent> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCosNaming_mNameComponent;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCosNaming_mNameComponent;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCosNaming_mNameComponent;
  }
#endif

void operator <<= (CORBA::Any& _a, const CosNaming::Name& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCosNaming_mNameComponent(tcdesc, _s);
  _a.PR_packFrom(CosNaming::_tc_Name, &tcdesc);
}

void _0RL_seq_delete_CosNaming_mName(void* _data)
{
  delete (CosNaming::Name*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CosNaming::Name*& _s_out)
{
  return _a >>= (const CosNaming::Name*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CosNaming::Name*& _s_out)
{
  _s_out = 0;
  CosNaming::Name* stmp = (CosNaming::Name*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CosNaming::Name;
    _0RL_buildDesc_s0_cCosNaming_mNameComponent(tcdesc, *stmp);
    if( _a.PR_unpackTo(CosNaming::_tc_Name, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CosNaming_mName);
      _s_out = stmp;
      return 1;
    } else {
      delete (CosNaming::Name *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CosNaming::_tc_Name) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_buildDesc_cCosNaming_mBindingType(tcDescriptor& _desc, const CosNaming::BindingType& _data)
{
  _desc.p_enum = (CORBA::ULong*)&_data;
}

void operator<<=(CORBA::Any& _a, CosNaming::BindingType _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cCosNaming_mBindingType(_0RL_tcd, _s);
  _a.PR_packFrom(_0RL_tc_CosNaming_mBindingType, &_0RL_tcd);
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CosNaming::BindingType& _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cCosNaming_mBindingType(_0RL_tcd, _s);
  return _a.PR_unpackTo(_0RL_tc_CosNaming_mBindingType, &_0RL_tcd);
}

void _0RL_delete_CosNaming_mBinding(void* _data) {
  CosNaming::Binding* _0RL_t = (CosNaming::Binding*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CosNaming_mBinding(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_s0_cCosNaming_mNameComponent(_newdesc, ((CosNaming::Binding*)_desc->opq_struct)->binding_name);
    return 1;
  case 1:
    _0RL_buildDesc_cCosNaming_mBindingType(_newdesc, ((CosNaming::Binding*)_desc->opq_struct)->binding_type);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CosNaming_mBinding(tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_cCosNaming_mBinding(tcDescriptor &_desc, const CosNaming::Binding& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CosNaming_mBinding;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CosNaming_mBinding;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CosNaming::Binding& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mBinding(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CosNaming_mBinding, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CosNaming::Binding* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mBinding(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CosNaming_mBinding, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CosNaming::Binding*& _sp) {
  return _a >>= (const CosNaming::Binding*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CosNaming::Binding*& _sp) {
  _sp = (CosNaming::Binding *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CosNaming::Binding;
    _0RL_buildDesc_cCosNaming_mBinding(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CosNaming_mBinding, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CosNaming_mBinding);
      return 1;
    } else {
      delete (CosNaming::Binding *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CosNaming_mBinding)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cCosNaming_mBinding__
#define __0RL_tcParser_buildDesc_s0_cCosNaming_mBinding__
static void
_0RL_tcParser_setElementCount_s0_cCosNaming_mBinding(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< CosNaming::Binding> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCosNaming_mBinding(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< CosNaming::Binding> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCosNaming_mBinding(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCosNaming_mBinding(_newdesc, (*((_CORBA_Unbounded_Sequence< CosNaming::Binding> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCosNaming_mBinding(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< CosNaming::Binding> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCosNaming_mBinding;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCosNaming_mBinding;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCosNaming_mBinding;
  }
#endif

void operator <<= (CORBA::Any& _a, const CosNaming::BindingList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCosNaming_mBinding(tcdesc, _s);
  _a.PR_packFrom(CosNaming::_tc_BindingList, &tcdesc);
}

void _0RL_seq_delete_CosNaming_mBindingList(void* _data)
{
  delete (CosNaming::BindingList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CosNaming::BindingList*& _s_out)
{
  return _a >>= (const CosNaming::BindingList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CosNaming::BindingList*& _s_out)
{
  _s_out = 0;
  CosNaming::BindingList* stmp = (CosNaming::BindingList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CosNaming::BindingList;
    _0RL_buildDesc_s0_cCosNaming_mBinding(tcdesc, *stmp);
    if( _a.PR_unpackTo(CosNaming::_tc_BindingList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CosNaming_mBindingList);
      _s_out = stmp;
      return 1;
    } else {
      delete (CosNaming::BindingList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CosNaming::_tc_BindingList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

// forward declaration of interface
 void _0RL_buildDesc_cCosNaming_mBindingIterator(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CosNaming::_objref_BindingIterator, CosNaming::BindingIterator_Helper> &);

void _0RL_buildDesc_cCosNaming_mNamingContext_mNotFoundReason(tcDescriptor& _desc, const CosNaming::NamingContext::NotFoundReason& _data)
{
  _desc.p_enum = (CORBA::ULong*)&_data;
}

void operator<<=(CORBA::Any& _a, CosNaming::NamingContext::NotFoundReason _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cCosNaming_mNamingContext_mNotFoundReason(_0RL_tcd, _s);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNamingContext_mNotFoundReason, &_0RL_tcd);
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CosNaming::NamingContext::NotFoundReason& _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cCosNaming_mNamingContext_mNotFoundReason(_0RL_tcd, _s);
  return _a.PR_unpackTo(_0RL_tc_CosNaming_mNamingContext_mNotFoundReason, &_0RL_tcd);
}

 CORBA::Boolean
_0RL_tcParser_getMemberDesc_CosNaming_mNamingContext_mNotFound(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cCosNaming_mNamingContext_mNotFoundReason(_newdesc, ((CosNaming::NamingContext::NotFound*)_desc->opq_struct)->why);
    return 1;
  case 1:
    _0RL_buildDesc_s0_cCosNaming_mNameComponent(_newdesc, ((CosNaming::NamingContext::NotFound*)_desc->opq_struct)->rest_of_name);
    return 1;
  
  default:
    return 0;
  };
}
 CORBA::ULong

_0RL_tcParser_getMemberCount_CosNaming_mNamingContext_mNotFound(tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_cCosNaming_mNamingContext_mNotFound(tcDescriptor &_desc, const CosNaming::NamingContext::NotFound& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CosNaming_mNamingContext_mNotFound;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CosNaming_mNamingContext_mNotFound;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void _0RL_delete_CosNaming_mNamingContext_mNotFound(void* _data) {
  CosNaming::NamingContext::NotFound* _0RL_t = (CosNaming::NamingContext::NotFound*) _data;
  delete _0RL_t;
}

void operator<<=(CORBA::Any& _a, const CosNaming::NamingContext::NotFound& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mNamingContext_mNotFound(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNamingContext_mNotFound, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, const CosNaming::NamingContext::NotFound* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mNamingContext_mNotFound(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNamingContext_mNotFound, &_0RL_tcdesc);
  delete (CosNaming::NamingContext::NotFound *)_sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a,const CosNaming::NamingContext::NotFound*& _sp) {
  _sp = (CosNaming::NamingContext::NotFound *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CosNaming::NamingContext::NotFound;
    _0RL_buildDesc_cCosNaming_mNamingContext_mNotFound(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CosNaming_mNamingContext_mNotFound, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CosNaming_mNamingContext_mNotFound);
      return 1;
    } else {
      delete (CosNaming::NamingContext::NotFound *)_sp;_sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CosNaming_mNamingContext_mNotFound)) return 1;
    delete (CosNaming::NamingContext::NotFound *)_sp;_sp = 0;
    return 0;
  }
}

static void _0RL_insertToAny__cCosNaming_mNamingContext_mNotFound(CORBA::Any& _a,const CORBA::Exception& _e) {
  const CosNaming::NamingContext::NotFound & _ex = (const CosNaming::NamingContext::NotFound &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCosNaming_mNamingContext_mNotFound (CORBA::Any& _a,const CORBA::Exception* _e) {
  const CosNaming::NamingContext::NotFound * _ex = (const CosNaming::NamingContext::NotFound *) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mNotFound {
public:
  _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mNotFound() {
    CosNaming::NamingContext::NotFound::insertToAnyFn = _0RL_insertToAny__cCosNaming_mNamingContext_mNotFound;
    CosNaming::NamingContext::NotFound::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCosNaming_mNamingContext_mNotFound;
  }
};
static _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mNotFound _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mNotFound_;

 void _0RL_buildDesc_cCosNaming_mNamingContext(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CosNaming::_objref_NamingContext, CosNaming::NamingContext_Helper> &);

 CORBA::Boolean
_0RL_tcParser_getMemberDesc_CosNaming_mNamingContext_mCannotProceed(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cCosNaming_mNamingContext(_newdesc, ((CosNaming::NamingContext::CannotProceed*)_desc->opq_struct)->cxt);
    return 1;
  case 1:
    _0RL_buildDesc_s0_cCosNaming_mNameComponent(_newdesc, ((CosNaming::NamingContext::CannotProceed*)_desc->opq_struct)->rest_of_name);
    return 1;
  
  default:
    return 0;
  };
}
 CORBA::ULong

_0RL_tcParser_getMemberCount_CosNaming_mNamingContext_mCannotProceed(tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_cCosNaming_mNamingContext_mCannotProceed(tcDescriptor &_desc, const CosNaming::NamingContext::CannotProceed& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CosNaming_mNamingContext_mCannotProceed;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CosNaming_mNamingContext_mCannotProceed;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void _0RL_delete_CosNaming_mNamingContext_mCannotProceed(void* _data) {
  CosNaming::NamingContext::CannotProceed* _0RL_t = (CosNaming::NamingContext::CannotProceed*) _data;
  delete _0RL_t;
}

void operator<<=(CORBA::Any& _a, const CosNaming::NamingContext::CannotProceed& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mNamingContext_mCannotProceed(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNamingContext_mCannotProceed, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, const CosNaming::NamingContext::CannotProceed* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mNamingContext_mCannotProceed(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNamingContext_mCannotProceed, &_0RL_tcdesc);
  delete (CosNaming::NamingContext::CannotProceed *)_sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a,const CosNaming::NamingContext::CannotProceed*& _sp) {
  _sp = (CosNaming::NamingContext::CannotProceed *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CosNaming::NamingContext::CannotProceed;
    _0RL_buildDesc_cCosNaming_mNamingContext_mCannotProceed(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CosNaming_mNamingContext_mCannotProceed, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CosNaming_mNamingContext_mCannotProceed);
      return 1;
    } else {
      delete (CosNaming::NamingContext::CannotProceed *)_sp;_sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CosNaming_mNamingContext_mCannotProceed)) return 1;
    delete (CosNaming::NamingContext::CannotProceed *)_sp;_sp = 0;
    return 0;
  }
}

static void _0RL_insertToAny__cCosNaming_mNamingContext_mCannotProceed(CORBA::Any& _a,const CORBA::Exception& _e) {
  const CosNaming::NamingContext::CannotProceed & _ex = (const CosNaming::NamingContext::CannotProceed &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCosNaming_mNamingContext_mCannotProceed (CORBA::Any& _a,const CORBA::Exception* _e) {
  const CosNaming::NamingContext::CannotProceed * _ex = (const CosNaming::NamingContext::CannotProceed *) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mCannotProceed {
public:
  _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mCannotProceed() {
    CosNaming::NamingContext::CannotProceed::insertToAnyFn = _0RL_insertToAny__cCosNaming_mNamingContext_mCannotProceed;
    CosNaming::NamingContext::CannotProceed::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCosNaming_mNamingContext_mCannotProceed;
  }
};
static _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mCannotProceed _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mCannotProceed_;

 CORBA::Boolean
_0RL_tcParser_getMemberDesc_CosNaming_mNamingContext_mInvalidName(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  
  default:
    return 0;
  };
}
 CORBA::ULong

_0RL_tcParser_getMemberCount_CosNaming_mNamingContext_mInvalidName(tcStructDesc *_desc)
{
  return 0;
}

void _0RL_buildDesc_cCosNaming_mNamingContext_mInvalidName(tcDescriptor &_desc, const CosNaming::NamingContext::InvalidName& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CosNaming_mNamingContext_mInvalidName;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CosNaming_mNamingContext_mInvalidName;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void _0RL_delete_CosNaming_mNamingContext_mInvalidName(void* _data) {
  CosNaming::NamingContext::InvalidName* _0RL_t = (CosNaming::NamingContext::InvalidName*) _data;
  delete _0RL_t;
}

void operator<<=(CORBA::Any& _a, const CosNaming::NamingContext::InvalidName& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mNamingContext_mInvalidName(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNamingContext_mInvalidName, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, const CosNaming::NamingContext::InvalidName* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mNamingContext_mInvalidName(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNamingContext_mInvalidName, &_0RL_tcdesc);
  delete (CosNaming::NamingContext::InvalidName *)_sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a,const CosNaming::NamingContext::InvalidName*& _sp) {
  _sp = (CosNaming::NamingContext::InvalidName *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CosNaming::NamingContext::InvalidName;
    _0RL_buildDesc_cCosNaming_mNamingContext_mInvalidName(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CosNaming_mNamingContext_mInvalidName, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CosNaming_mNamingContext_mInvalidName);
      return 1;
    } else {
      delete (CosNaming::NamingContext::InvalidName *)_sp;_sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CosNaming_mNamingContext_mInvalidName)) return 1;
    delete (CosNaming::NamingContext::InvalidName *)_sp;_sp = 0;
    return 0;
  }
}

static void _0RL_insertToAny__cCosNaming_mNamingContext_mInvalidName(CORBA::Any& _a,const CORBA::Exception& _e) {
  const CosNaming::NamingContext::InvalidName & _ex = (const CosNaming::NamingContext::InvalidName &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCosNaming_mNamingContext_mInvalidName (CORBA::Any& _a,const CORBA::Exception* _e) {
  const CosNaming::NamingContext::InvalidName * _ex = (const CosNaming::NamingContext::InvalidName *) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mInvalidName {
public:
  _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mInvalidName() {
    CosNaming::NamingContext::InvalidName::insertToAnyFn = _0RL_insertToAny__cCosNaming_mNamingContext_mInvalidName;
    CosNaming::NamingContext::InvalidName::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCosNaming_mNamingContext_mInvalidName;
  }
};
static _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mInvalidName _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mInvalidName_;

 CORBA::Boolean
_0RL_tcParser_getMemberDesc_CosNaming_mNamingContext_mAlreadyBound(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  
  default:
    return 0;
  };
}
 CORBA::ULong

_0RL_tcParser_getMemberCount_CosNaming_mNamingContext_mAlreadyBound(tcStructDesc *_desc)
{
  return 0;
}

void _0RL_buildDesc_cCosNaming_mNamingContext_mAlreadyBound(tcDescriptor &_desc, const CosNaming::NamingContext::AlreadyBound& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CosNaming_mNamingContext_mAlreadyBound;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CosNaming_mNamingContext_mAlreadyBound;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void _0RL_delete_CosNaming_mNamingContext_mAlreadyBound(void* _data) {
  CosNaming::NamingContext::AlreadyBound* _0RL_t = (CosNaming::NamingContext::AlreadyBound*) _data;
  delete _0RL_t;
}

void operator<<=(CORBA::Any& _a, const CosNaming::NamingContext::AlreadyBound& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mNamingContext_mAlreadyBound(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNamingContext_mAlreadyBound, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, const CosNaming::NamingContext::AlreadyBound* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mNamingContext_mAlreadyBound(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNamingContext_mAlreadyBound, &_0RL_tcdesc);
  delete (CosNaming::NamingContext::AlreadyBound *)_sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a,const CosNaming::NamingContext::AlreadyBound*& _sp) {
  _sp = (CosNaming::NamingContext::AlreadyBound *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CosNaming::NamingContext::AlreadyBound;
    _0RL_buildDesc_cCosNaming_mNamingContext_mAlreadyBound(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CosNaming_mNamingContext_mAlreadyBound, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CosNaming_mNamingContext_mAlreadyBound);
      return 1;
    } else {
      delete (CosNaming::NamingContext::AlreadyBound *)_sp;_sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CosNaming_mNamingContext_mAlreadyBound)) return 1;
    delete (CosNaming::NamingContext::AlreadyBound *)_sp;_sp = 0;
    return 0;
  }
}

static void _0RL_insertToAny__cCosNaming_mNamingContext_mAlreadyBound(CORBA::Any& _a,const CORBA::Exception& _e) {
  const CosNaming::NamingContext::AlreadyBound & _ex = (const CosNaming::NamingContext::AlreadyBound &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCosNaming_mNamingContext_mAlreadyBound (CORBA::Any& _a,const CORBA::Exception* _e) {
  const CosNaming::NamingContext::AlreadyBound * _ex = (const CosNaming::NamingContext::AlreadyBound *) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mAlreadyBound {
public:
  _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mAlreadyBound() {
    CosNaming::NamingContext::AlreadyBound::insertToAnyFn = _0RL_insertToAny__cCosNaming_mNamingContext_mAlreadyBound;
    CosNaming::NamingContext::AlreadyBound::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCosNaming_mNamingContext_mAlreadyBound;
  }
};
static _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mAlreadyBound _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mAlreadyBound_;

 CORBA::Boolean
_0RL_tcParser_getMemberDesc_CosNaming_mNamingContext_mNotEmpty(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  
  default:
    return 0;
  };
}
 CORBA::ULong

_0RL_tcParser_getMemberCount_CosNaming_mNamingContext_mNotEmpty(tcStructDesc *_desc)
{
  return 0;
}

void _0RL_buildDesc_cCosNaming_mNamingContext_mNotEmpty(tcDescriptor &_desc, const CosNaming::NamingContext::NotEmpty& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CosNaming_mNamingContext_mNotEmpty;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CosNaming_mNamingContext_mNotEmpty;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void _0RL_delete_CosNaming_mNamingContext_mNotEmpty(void* _data) {
  CosNaming::NamingContext::NotEmpty* _0RL_t = (CosNaming::NamingContext::NotEmpty*) _data;
  delete _0RL_t;
}

void operator<<=(CORBA::Any& _a, const CosNaming::NamingContext::NotEmpty& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mNamingContext_mNotEmpty(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNamingContext_mNotEmpty, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, const CosNaming::NamingContext::NotEmpty* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mNamingContext_mNotEmpty(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNamingContext_mNotEmpty, &_0RL_tcdesc);
  delete (CosNaming::NamingContext::NotEmpty *)_sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a,const CosNaming::NamingContext::NotEmpty*& _sp) {
  _sp = (CosNaming::NamingContext::NotEmpty *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CosNaming::NamingContext::NotEmpty;
    _0RL_buildDesc_cCosNaming_mNamingContext_mNotEmpty(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CosNaming_mNamingContext_mNotEmpty, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CosNaming_mNamingContext_mNotEmpty);
      return 1;
    } else {
      delete (CosNaming::NamingContext::NotEmpty *)_sp;_sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CosNaming_mNamingContext_mNotEmpty)) return 1;
    delete (CosNaming::NamingContext::NotEmpty *)_sp;_sp = 0;
    return 0;
  }
}

static void _0RL_insertToAny__cCosNaming_mNamingContext_mNotEmpty(CORBA::Any& _a,const CORBA::Exception& _e) {
  const CosNaming::NamingContext::NotEmpty & _ex = (const CosNaming::NamingContext::NotEmpty &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCosNaming_mNamingContext_mNotEmpty (CORBA::Any& _a,const CORBA::Exception* _e) {
  const CosNaming::NamingContext::NotEmpty * _ex = (const CosNaming::NamingContext::NotEmpty *) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mNotEmpty {
public:
  _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mNotEmpty() {
    CosNaming::NamingContext::NotEmpty::insertToAnyFn = _0RL_insertToAny__cCosNaming_mNamingContext_mNotEmpty;
    CosNaming::NamingContext::NotEmpty::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCosNaming_mNamingContext_mNotEmpty;
  }
};
static _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mNotEmpty _0RL_insertToAny_Singleton__cCosNaming_mNamingContext_mNotEmpty_;

static void
_0RL_tcParser_setObjectPtr_CosNaming_mNamingContext(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CosNaming::NamingContext_ptr _p = CosNaming::NamingContext::_narrow(_ptr);
  CosNaming::NamingContext_ptr* pp = (CosNaming::NamingContext_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CosNaming_mNamingContext(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CosNaming::NamingContext_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCosNaming_mNamingContext(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CosNaming::_objref_NamingContext, CosNaming::NamingContext_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CosNaming_mNamingContext;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CosNaming_mNamingContext;
}

void _0RL_delete_CosNaming_mNamingContext(void* _data) {
  CORBA::release((CosNaming::NamingContext_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CosNaming::NamingContext_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CosNaming::_objref_NamingContext, CosNaming::NamingContext_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCosNaming_mNamingContext(tcd, tmp);
  _a.PR_packFrom(CosNaming::_tc_NamingContext, &tcd);
}

void operator<<=(CORBA::Any& _a, CosNaming::NamingContext_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CosNaming::NamingContext::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CosNaming::NamingContext_ptr& _s) {
  CosNaming::NamingContext_ptr sp = (CosNaming::NamingContext_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CosNaming::NamingContext_var tmp;
    _0RL_buildDesc_cCosNaming_mNamingContext(tcd, tmp);
    if( _a.PR_unpackTo(CosNaming::_tc_NamingContext, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CosNaming::NamingContext_ptr)tmp,_0RL_delete_CosNaming_mNamingContext);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CosNaming::NamingContext::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CosNaming::_tc_NamingContext)) {
    _s = sp; return 1;
    }
    else {
    _s = CosNaming::NamingContext::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CosNaming_mBindingIterator(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CosNaming::BindingIterator_ptr _p = CosNaming::BindingIterator::_narrow(_ptr);
  CosNaming::BindingIterator_ptr* pp = (CosNaming::BindingIterator_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CosNaming_mBindingIterator(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CosNaming::BindingIterator_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCosNaming_mBindingIterator(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CosNaming::_objref_BindingIterator, CosNaming::BindingIterator_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CosNaming_mBindingIterator;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CosNaming_mBindingIterator;
}

void _0RL_delete_CosNaming_mBindingIterator(void* _data) {
  CORBA::release((CosNaming::BindingIterator_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CosNaming::BindingIterator_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CosNaming::_objref_BindingIterator, CosNaming::BindingIterator_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCosNaming_mBindingIterator(tcd, tmp);
  _a.PR_packFrom(CosNaming::_tc_BindingIterator, &tcd);
}

void operator<<=(CORBA::Any& _a, CosNaming::BindingIterator_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CosNaming::BindingIterator::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CosNaming::BindingIterator_ptr& _s) {
  CosNaming::BindingIterator_ptr sp = (CosNaming::BindingIterator_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CosNaming::BindingIterator_var tmp;
    _0RL_buildDesc_cCosNaming_mBindingIterator(tcd, tmp);
    if( _a.PR_unpackTo(CosNaming::_tc_BindingIterator, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CosNaming::BindingIterator_ptr)tmp,_0RL_delete_CosNaming_mBindingIterator);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CosNaming::BindingIterator::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CosNaming::_tc_BindingIterator)) {
    _s = sp; return 1;
    }
    else {
    _s = CosNaming::BindingIterator::_nil(); return 0;
    }
  }
}

 CORBA::Boolean
_0RL_tcParser_getMemberDesc_CosNaming_mNamingContextExt_mInvalidAddress(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  
  default:
    return 0;
  };
}
 CORBA::ULong

_0RL_tcParser_getMemberCount_CosNaming_mNamingContextExt_mInvalidAddress(tcStructDesc *_desc)
{
  return 0;
}

void _0RL_buildDesc_cCosNaming_mNamingContextExt_mInvalidAddress(tcDescriptor &_desc, const CosNaming::NamingContextExt::InvalidAddress& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CosNaming_mNamingContextExt_mInvalidAddress;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CosNaming_mNamingContextExt_mInvalidAddress;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void _0RL_delete_CosNaming_mNamingContextExt_mInvalidAddress(void* _data) {
  CosNaming::NamingContextExt::InvalidAddress* _0RL_t = (CosNaming::NamingContextExt::InvalidAddress*) _data;
  delete _0RL_t;
}

void operator<<=(CORBA::Any& _a, const CosNaming::NamingContextExt::InvalidAddress& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mNamingContextExt_mInvalidAddress(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNamingContextExt_mInvalidAddress, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, const CosNaming::NamingContextExt::InvalidAddress* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCosNaming_mNamingContextExt_mInvalidAddress(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CosNaming_mNamingContextExt_mInvalidAddress, &_0RL_tcdesc);
  delete (CosNaming::NamingContextExt::InvalidAddress *)_sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a,const CosNaming::NamingContextExt::InvalidAddress*& _sp) {
  _sp = (CosNaming::NamingContextExt::InvalidAddress *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CosNaming::NamingContextExt::InvalidAddress;
    _0RL_buildDesc_cCosNaming_mNamingContextExt_mInvalidAddress(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CosNaming_mNamingContextExt_mInvalidAddress, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CosNaming_mNamingContextExt_mInvalidAddress);
      return 1;
    } else {
      delete (CosNaming::NamingContextExt::InvalidAddress *)_sp;_sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CosNaming_mNamingContextExt_mInvalidAddress)) return 1;
    delete (CosNaming::NamingContextExt::InvalidAddress *)_sp;_sp = 0;
    return 0;
  }
}

static void _0RL_insertToAny__cCosNaming_mNamingContextExt_mInvalidAddress(CORBA::Any& _a,const CORBA::Exception& _e) {
  const CosNaming::NamingContextExt::InvalidAddress & _ex = (const CosNaming::NamingContextExt::InvalidAddress &) _e;
  operator<<=(_a,_ex);
}

static void _0RL_insertToAnyNCP__cCosNaming_mNamingContextExt_mInvalidAddress (CORBA::Any& _a,const CORBA::Exception* _e) {
  const CosNaming::NamingContextExt::InvalidAddress * _ex = (const CosNaming::NamingContextExt::InvalidAddress *) _e;
  operator<<=(_a,_ex);
}

class _0RL_insertToAny_Singleton__cCosNaming_mNamingContextExt_mInvalidAddress {
public:
  _0RL_insertToAny_Singleton__cCosNaming_mNamingContextExt_mInvalidAddress() {
    CosNaming::NamingContextExt::InvalidAddress::insertToAnyFn = _0RL_insertToAny__cCosNaming_mNamingContextExt_mInvalidAddress;
    CosNaming::NamingContextExt::InvalidAddress::insertToAnyFnNCP = _0RL_insertToAnyNCP__cCosNaming_mNamingContextExt_mInvalidAddress;
  }
};
static _0RL_insertToAny_Singleton__cCosNaming_mNamingContextExt_mInvalidAddress _0RL_insertToAny_Singleton__cCosNaming_mNamingContextExt_mInvalidAddress_;

static void
_0RL_tcParser_setObjectPtr_CosNaming_mNamingContextExt(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CosNaming::NamingContextExt_ptr _p = CosNaming::NamingContextExt::_narrow(_ptr);
  CosNaming::NamingContextExt_ptr* pp = (CosNaming::NamingContextExt_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CosNaming_mNamingContextExt(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CosNaming::NamingContextExt_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCosNaming_mNamingContextExt(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CosNaming::_objref_NamingContextExt, CosNaming::NamingContextExt_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CosNaming_mNamingContextExt;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CosNaming_mNamingContextExt;
}

void _0RL_delete_CosNaming_mNamingContextExt(void* _data) {
  CORBA::release((CosNaming::NamingContextExt_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CosNaming::NamingContextExt_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CosNaming::_objref_NamingContextExt, CosNaming::NamingContextExt_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCosNaming_mNamingContextExt(tcd, tmp);
  _a.PR_packFrom(CosNaming::_tc_NamingContextExt, &tcd);
}

void operator<<=(CORBA::Any& _a, CosNaming::NamingContextExt_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CosNaming::NamingContextExt::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CosNaming::NamingContextExt_ptr& _s) {
  CosNaming::NamingContextExt_ptr sp = (CosNaming::NamingContextExt_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CosNaming::NamingContextExt_var tmp;
    _0RL_buildDesc_cCosNaming_mNamingContextExt(tcd, tmp);
    if( _a.PR_unpackTo(CosNaming::_tc_NamingContextExt, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CosNaming::NamingContextExt_ptr)tmp,_0RL_delete_CosNaming_mNamingContextExt);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CosNaming::NamingContextExt::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CosNaming::_tc_NamingContextExt)) {
    _s = sp; return 1;
    }
    else {
    _s = CosNaming::NamingContextExt::_nil(); return 0;
    }
  }
}

