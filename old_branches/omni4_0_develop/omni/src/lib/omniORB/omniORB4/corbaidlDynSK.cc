// This file is generated by omniidl (C++ backend)- omniORB_3_0. Do not edit.

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mIdentifier = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/Identifier:1.0", "Identifier", CORBA::TypeCode::PR_string_tc(0));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_Identifier = _0RL_tc_CORBA_mIdentifier;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_Identifier = _0RL_tc_CORBA_mIdentifier;
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mStructMember[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"type_def", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType")}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mStructMember = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/StructMember:1.0", "StructMember", _0RL_structmember_CORBA_mStructMember, 3);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_StructMember = _0RL_tc_CORBA_mStructMember;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_StructMember = _0RL_tc_CORBA_mStructMember;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mStructMemberSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/StructMemberSeq:1.0", "StructMemberSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mStructMember));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_StructMemberSeq = _0RL_tc_CORBA_mStructMemberSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_StructMemberSeq = _0RL_tc_CORBA_mStructMemberSeq;
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mUnionMember[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"label", CORBA::TypeCode::PR_any_tc()},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"type_def", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType")}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mUnionMember = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/UnionMember:1.0", "UnionMember", _0RL_structmember_CORBA_mUnionMember, 4);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_UnionMember = _0RL_tc_CORBA_mUnionMember;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_UnionMember = _0RL_tc_CORBA_mUnionMember;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mUnionMemberSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/UnionMemberSeq:1.0", "UnionMemberSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mUnionMember));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_UnionMemberSeq = _0RL_tc_CORBA_mUnionMemberSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_UnionMemberSeq = _0RL_tc_CORBA_mUnionMemberSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mEnumMemberSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/EnumMemberSeq:1.0", "EnumMemberSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mIdentifier));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_EnumMemberSeq = _0RL_tc_CORBA_mEnumMemberSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_EnumMemberSeq = _0RL_tc_CORBA_mEnumMemberSeq;
#endif

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mIDLType(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_IDLType, CORBA::IDLType_Helper> &);

void _0RL_delete_CORBA_mStructMember(void* _data) {
  CORBA::StructMember* _0RL_t = (CORBA::StructMember*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mStructMember(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::StructMember*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cTypeCode(_newdesc, ((CORBA::StructMember*)_desc->opq_struct)->type);
    return 1;
  case 2:
    _0RL_buildDesc_cCORBA_mIDLType(_newdesc, ((CORBA::StructMember*)_desc->opq_struct)->type_def);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mStructMember(tcStructDesc *_desc)
{
  return 3;
}

void _0RL_buildDesc_cCORBA_mStructMember(tcDescriptor &_desc, const CORBA::StructMember& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mStructMember;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mStructMember;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::StructMember& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mStructMember(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mStructMember, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::StructMember* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mStructMember(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mStructMember, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::StructMember*& _sp) {
  return _a >>= (const CORBA::StructMember*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::StructMember*& _sp) {
  _sp = (CORBA::StructMember *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::StructMember;
    _0RL_buildDesc_cCORBA_mStructMember(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mStructMember, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mStructMember);
      return 1;
    } else {
      delete (CORBA::StructMember *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mStructMember)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mStructMember__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mStructMember__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mStructMember(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< CORBA::StructMember> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mStructMember(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< CORBA::StructMember> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mStructMember(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mStructMember(_newdesc, (*((_CORBA_Unbounded_Sequence< CORBA::StructMember> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mStructMember(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< CORBA::StructMember> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mStructMember;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mStructMember;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mStructMember;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::StructMemberSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCORBA_mStructMember(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_StructMemberSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mStructMemberSeq(void* _data)
{
  delete (CORBA::StructMemberSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::StructMemberSeq*& _s_out)
{
  return _a >>= (const CORBA::StructMemberSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::StructMemberSeq*& _s_out)
{
  _s_out = 0;
  CORBA::StructMemberSeq* stmp = (CORBA::StructMemberSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::StructMemberSeq;
    _0RL_buildDesc_s0_cCORBA_mStructMember(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_StructMemberSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mStructMemberSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::StructMemberSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_StructMemberSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_CORBA_mUnionMember(void* _data) {
  CORBA::UnionMember* _0RL_t = (CORBA::UnionMember*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mUnionMember(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::UnionMember*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cany(_newdesc, ((CORBA::UnionMember*)_desc->opq_struct)->label);
    return 1;
  case 2:
    _0RL_buildDesc_cTypeCode(_newdesc, ((CORBA::UnionMember*)_desc->opq_struct)->type);
    return 1;
  case 3:
    _0RL_buildDesc_cCORBA_mIDLType(_newdesc, ((CORBA::UnionMember*)_desc->opq_struct)->type_def);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mUnionMember(tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_cCORBA_mUnionMember(tcDescriptor &_desc, const CORBA::UnionMember& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mUnionMember;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mUnionMember;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::UnionMember& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mUnionMember(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mUnionMember, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::UnionMember* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mUnionMember(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mUnionMember, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::UnionMember*& _sp) {
  return _a >>= (const CORBA::UnionMember*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::UnionMember*& _sp) {
  _sp = (CORBA::UnionMember *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::UnionMember;
    _0RL_buildDesc_cCORBA_mUnionMember(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mUnionMember, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mUnionMember);
      return 1;
    } else {
      delete (CORBA::UnionMember *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mUnionMember)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mUnionMember__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mUnionMember__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mUnionMember(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< CORBA::UnionMember> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mUnionMember(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< CORBA::UnionMember> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mUnionMember(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mUnionMember(_newdesc, (*((_CORBA_Unbounded_Sequence< CORBA::UnionMember> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mUnionMember(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< CORBA::UnionMember> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mUnionMember;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mUnionMember;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mUnionMember;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::UnionMemberSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCORBA_mUnionMember(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_UnionMemberSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mUnionMemberSeq(void* _data)
{
  delete (CORBA::UnionMemberSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::UnionMemberSeq*& _s_out)
{
  return _a >>= (const CORBA::UnionMemberSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::UnionMemberSeq*& _s_out)
{
  _s_out = 0;
  CORBA::UnionMemberSeq* stmp = (CORBA::UnionMemberSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::UnionMemberSeq;
    _0RL_buildDesc_s0_cCORBA_mUnionMember(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_UnionMemberSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mUnionMemberSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::UnionMemberSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_UnionMemberSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cstring__
#define __0RL_tcParser_buildDesc_s0_cstring__
static void
_0RL_tcParser_setElementCount_s0_cstring(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence__String*)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cstring(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence__String*)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cstring(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cstring(_newdesc, (*((_CORBA_Unbounded_Sequence__String*)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cstring(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence__String& _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cstring;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cstring;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cstring;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::EnumMemberSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cstring(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_EnumMemberSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mEnumMemberSeq(void* _data)
{
  delete (CORBA::EnumMemberSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::EnumMemberSeq*& _s_out)
{
  return _a >>= (const CORBA::EnumMemberSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::EnumMemberSeq*& _s_out)
{
  _s_out = 0;
  CORBA::EnumMemberSeq* stmp = (CORBA::EnumMemberSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::EnumMemberSeq;
    _0RL_buildDesc_s0_cstring(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_EnumMemberSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mEnumMemberSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::EnumMemberSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_EnumMemberSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

