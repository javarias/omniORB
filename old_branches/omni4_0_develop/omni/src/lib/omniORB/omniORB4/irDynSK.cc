// This file is generated by omniidl (C++ backend)- omniORB_3_0. Do not edit.

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mScopedName = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ScopedName:1.0", "ScopedName", CORBA::TypeCode::PR_string_tc(0));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ScopedName = _0RL_tc_CORBA_mScopedName;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ScopedName = _0RL_tc_CORBA_mScopedName;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mRepositoryId = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/RepositoryId:1.0", "RepositoryId", CORBA::TypeCode::PR_string_tc(0));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_RepositoryId = _0RL_tc_CORBA_mRepositoryId;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_RepositoryId = _0RL_tc_CORBA_mRepositoryId;
#endif

static const char* _0RL_enumMember_CORBA_mDefinitionKind[] = { "dk_none", "dk_all", "dk_Attribute", "dk_Constant", "dk_Exception", "dk_Interface", "dk_Module", "dk_Operation", "dk_Typedef", "dk_Alias", "dk_Struct", "dk_Union", "dk_Enum", "dk_Primitive", "dk_String", "dk_Sequence", "dk_Array", "dk_Repository", "dk_Wstring", "dk_Fixed", "dk_Value", "dk_ValueBox", "dk_Member", "dk_Native", "dk_AbstractInterface" };
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mDefinitionKind = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/CORBA/DefinitionKind:1.0", "DefinitionKind", _0RL_enumMember_CORBA_mDefinitionKind, 25);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_DefinitionKind = _0RL_tc_CORBA_mDefinitionKind;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_DefinitionKind = _0RL_tc_CORBA_mDefinitionKind;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_IRObject = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IRObject:1.0", "IRObject");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_IRObject = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IRObject:1.0", "IRObject");
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mVersionSpec = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/VersionSpec:1.0", "VersionSpec", CORBA::TypeCode::PR_string_tc(0));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_VersionSpec = _0RL_tc_CORBA_mVersionSpec;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_VersionSpec = _0RL_tc_CORBA_mVersionSpec;
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mContained_mDescription[] = {
  {"kind", _0RL_tc_CORBA_mDefinitionKind},
  {"value", CORBA::TypeCode::PR_any_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mContained_mDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/Contained/Description:1.0", "Description", _0RL_structmember_CORBA_mContained_mDescription, 2);
const CORBA::TypeCode_ptr CORBA::Contained::_tc_Description = _0RL_tc_CORBA_mContained_mDescription;

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_Contained = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Contained:1.0", "Contained");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_Contained = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Contained:1.0", "Contained");
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mInterfaceDefSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/InterfaceDefSeq:1.0", "InterfaceDefSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/InterfaceDef:1.0", "InterfaceDef")));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_InterfaceDefSeq = _0RL_tc_CORBA_mInterfaceDefSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_InterfaceDefSeq = _0RL_tc_CORBA_mInterfaceDefSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mValueDefSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ValueDefSeq:1.0", "ValueDefSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ValueDef:1.0", "ValueDef")));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ValueDefSeq = _0RL_tc_CORBA_mValueDefSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ValueDefSeq = _0RL_tc_CORBA_mValueDefSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mAbstractInterfaceDefSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/AbstractInterfaceDefSeq:1.0", "AbstractInterfaceDefSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/AbstractInterfaceDef:1.0", "AbstractInterfaceDef")));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_AbstractInterfaceDefSeq = _0RL_tc_CORBA_mAbstractInterfaceDefSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_AbstractInterfaceDefSeq = _0RL_tc_CORBA_mAbstractInterfaceDefSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mContainedSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ContainedSeq:1.0", "ContainedSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Contained:1.0", "Contained")));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ContainedSeq = _0RL_tc_CORBA_mContainedSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ContainedSeq = _0RL_tc_CORBA_mContainedSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mIdentifier = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/Identifier:1.0", "Identifier", CORBA::TypeCode::PR_string_tc(0));

static CORBA::PR_structMember _0RL_structmember_CORBA_mStructMember[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"type_def", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType")}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mStructMember = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/StructMember:1.0", "StructMember", _0RL_structmember_CORBA_mStructMember, 3);
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mStructMemberSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/StructMemberSeq:1.0", "StructMemberSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mStructMember));

static CORBA::PR_structMember _0RL_structmember_CORBA_mInitializer[] = {
  {"members", _0RL_tc_CORBA_mStructMemberSeq},
  {"name", _0RL_tc_CORBA_mIdentifier}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mInitializer = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/Initializer:1.0", "Initializer", _0RL_structmember_CORBA_mInitializer, 2);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_Initializer = _0RL_tc_CORBA_mInitializer;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_Initializer = _0RL_tc_CORBA_mInitializer;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mInitializerSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/InitializerSeq:1.0", "InitializerSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mInitializer));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_InitializerSeq = _0RL_tc_CORBA_mInitializerSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_InitializerSeq = _0RL_tc_CORBA_mInitializerSeq;
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mContainer_mDescription[] = {
  {"contained_object", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Contained:1.0", "Contained")},
  {"kind", _0RL_tc_CORBA_mDefinitionKind},
  {"value", CORBA::TypeCode::PR_any_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mContainer_mDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/Container/Description:1.0", "Description", _0RL_structmember_CORBA_mContainer_mDescription, 3);
const CORBA::TypeCode_ptr CORBA::Container::_tc_Description = _0RL_tc_CORBA_mContainer_mDescription;

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mContainer_mDescriptionSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/Container/DescriptionSeq:1.0", "DescriptionSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mContainer_mDescription));

const CORBA::TypeCode_ptr CORBA::Container::_tc_DescriptionSeq = _0RL_tc_CORBA_mContainer_mDescriptionSeq;

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_Container = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Container:1.0", "Container");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_Container = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Container:1.0", "Container");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_IDLType = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_IDLType = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType");
#endif

static const char* _0RL_enumMember_CORBA_mPrimitiveKind[] = { "pk_null", "pk_void", "pk_short", "pk_long", "pk_ushort", "pk_ulong", "pk_float", "pk_double", "pk_boolean", "pk_char", "pk_octet", "pk_any", "pk_TypeCode", "pk_Principal", "pk_string", "pk_objref", "pk_longlong", "pk_ulonglong", "pk_longdouble", "pk_wchar", "pk_wstring", "pk_value_base" };
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mPrimitiveKind = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/CORBA/PrimitiveKind:1.0", "PrimitiveKind", _0RL_enumMember_CORBA_mPrimitiveKind, 22);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_PrimitiveKind = _0RL_tc_CORBA_mPrimitiveKind;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_PrimitiveKind = _0RL_tc_CORBA_mPrimitiveKind;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_Repository = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Repository:1.0", "Repository");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_Repository = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/Repository:1.0", "Repository");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ModuleDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ModuleDef:1.0", "ModuleDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ModuleDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ModuleDef:1.0", "ModuleDef");
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mModuleDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mModuleDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ModuleDescription:1.0", "ModuleDescription", _0RL_structmember_CORBA_mModuleDescription, 4);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ModuleDescription = _0RL_tc_CORBA_mModuleDescription;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ModuleDescription = _0RL_tc_CORBA_mModuleDescription;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ConstantDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ConstantDef:1.0", "ConstantDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ConstantDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ConstantDef:1.0", "ConstantDef");
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mConstantDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"value", CORBA::TypeCode::PR_any_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mConstantDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ConstantDescription:1.0", "ConstantDescription", _0RL_structmember_CORBA_mConstantDescription, 6);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ConstantDescription = _0RL_tc_CORBA_mConstantDescription;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ConstantDescription = _0RL_tc_CORBA_mConstantDescription;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_TypedefDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/TypedefDef:1.0", "TypedefDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_TypedefDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/TypedefDef:1.0", "TypedefDef");
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mTypeDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mTypeDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/TypeDescription:1.0", "TypeDescription", _0RL_structmember_CORBA_mTypeDescription, 5);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_TypeDescription = _0RL_tc_CORBA_mTypeDescription;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_TypeDescription = _0RL_tc_CORBA_mTypeDescription;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_StructDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/StructDef:1.0", "StructDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_StructDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/StructDef:1.0", "StructDef");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_UnionDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/UnionDef:1.0", "UnionDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_UnionDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/UnionDef:1.0", "UnionDef");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_EnumDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/EnumDef:1.0", "EnumDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_EnumDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/EnumDef:1.0", "EnumDef");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_AliasDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/AliasDef:1.0", "AliasDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_AliasDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/AliasDef:1.0", "AliasDef");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_NativeDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/NativeDef:1.0", "NativeDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_NativeDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/NativeDef:1.0", "NativeDef");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_PrimitiveDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/PrimitiveDef:1.0", "PrimitiveDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_PrimitiveDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/PrimitiveDef:1.0", "PrimitiveDef");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_StringDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/StringDef:1.0", "StringDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_StringDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/StringDef:1.0", "StringDef");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_WstringDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/WstringDef:1.0", "WstringDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_WstringDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/WstringDef:1.0", "WstringDef");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_FixedDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/FixedDef:1.0", "FixedDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_FixedDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/FixedDef:1.0", "FixedDef");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_SequenceDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/SequenceDef:1.0", "SequenceDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_SequenceDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/SequenceDef:1.0", "SequenceDef");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ArrayDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ArrayDef:1.0", "ArrayDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ArrayDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ArrayDef:1.0", "ArrayDef");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ExceptionDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ExceptionDef:1.0", "ExceptionDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ExceptionDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ExceptionDef:1.0", "ExceptionDef");
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mExceptionDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mExceptionDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ExceptionDescription:1.0", "ExceptionDescription", _0RL_structmember_CORBA_mExceptionDescription, 5);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ExceptionDescription = _0RL_tc_CORBA_mExceptionDescription;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ExceptionDescription = _0RL_tc_CORBA_mExceptionDescription;
#endif

static const char* _0RL_enumMember_CORBA_mAttributeMode[] = { "ATTR_NORMAL", "ATTR_READONLY" };
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mAttributeMode = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/CORBA/AttributeMode:1.0", "AttributeMode", _0RL_enumMember_CORBA_mAttributeMode, 2);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_AttributeMode = _0RL_tc_CORBA_mAttributeMode;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_AttributeMode = _0RL_tc_CORBA_mAttributeMode;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_AttributeDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/AttributeDef:1.0", "AttributeDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_AttributeDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/AttributeDef:1.0", "AttributeDef");
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mAttributeDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"mode", _0RL_tc_CORBA_mAttributeMode}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mAttributeDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/AttributeDescription:1.0", "AttributeDescription", _0RL_structmember_CORBA_mAttributeDescription, 6);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_AttributeDescription = _0RL_tc_CORBA_mAttributeDescription;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_AttributeDescription = _0RL_tc_CORBA_mAttributeDescription;
#endif

static const char* _0RL_enumMember_CORBA_mOperationMode[] = { "OP_NORMAL", "OP_ONEWAY" };
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mOperationMode = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/CORBA/OperationMode:1.0", "OperationMode", _0RL_enumMember_CORBA_mOperationMode, 2);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_OperationMode = _0RL_tc_CORBA_mOperationMode;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_OperationMode = _0RL_tc_CORBA_mOperationMode;
#endif

static const char* _0RL_enumMember_CORBA_mParameterMode[] = { "PARAM_IN", "PARAM_OUT", "PARAM_INOUT" };
static CORBA::TypeCode_ptr _0RL_tc_CORBA_mParameterMode = CORBA::TypeCode::PR_enum_tc("IDL:omg.org/CORBA/ParameterMode:1.0", "ParameterMode", _0RL_enumMember_CORBA_mParameterMode, 3);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ParameterMode = _0RL_tc_CORBA_mParameterMode;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ParameterMode = _0RL_tc_CORBA_mParameterMode;
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mParameterDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"type_def", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType")},
  {"mode", _0RL_tc_CORBA_mParameterMode}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mParameterDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ParameterDescription:1.0", "ParameterDescription", _0RL_structmember_CORBA_mParameterDescription, 4);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ParameterDescription = _0RL_tc_CORBA_mParameterDescription;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ParameterDescription = _0RL_tc_CORBA_mParameterDescription;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mParDescriptionSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ParDescriptionSeq:1.0", "ParDescriptionSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mParameterDescription));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ParDescriptionSeq = _0RL_tc_CORBA_mParDescriptionSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ParDescriptionSeq = _0RL_tc_CORBA_mParDescriptionSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mContextIdentifier = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ContextIdentifier:1.0", "ContextIdentifier", _0RL_tc_CORBA_mIdentifier);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ContextIdentifier = _0RL_tc_CORBA_mContextIdentifier;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ContextIdentifier = _0RL_tc_CORBA_mContextIdentifier;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mContextIdSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ContextIdSeq:1.0", "ContextIdSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mContextIdentifier));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ContextIdSeq = _0RL_tc_CORBA_mContextIdSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ContextIdSeq = _0RL_tc_CORBA_mContextIdSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mExceptionDefSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ExceptionDefSeq:1.0", "ExceptionDefSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ExceptionDef:1.0", "ExceptionDef")));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ExceptionDefSeq = _0RL_tc_CORBA_mExceptionDefSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ExceptionDefSeq = _0RL_tc_CORBA_mExceptionDefSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mExcDescriptionSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ExcDescriptionSeq:1.0", "ExcDescriptionSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mExceptionDescription));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ExcDescriptionSeq = _0RL_tc_CORBA_mExcDescriptionSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ExcDescriptionSeq = _0RL_tc_CORBA_mExcDescriptionSeq;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_OperationDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/OperationDef:1.0", "OperationDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_OperationDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/OperationDef:1.0", "OperationDef");
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mOperationDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"result", CORBA::TypeCode::PR_TypeCode_tc()},
  {"mode", _0RL_tc_CORBA_mOperationMode},
  {"contexts", _0RL_tc_CORBA_mContextIdSeq},
  {"parameters", _0RL_tc_CORBA_mParDescriptionSeq},
  {"exceptions", _0RL_tc_CORBA_mExcDescriptionSeq}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mOperationDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/OperationDescription:1.0", "OperationDescription", _0RL_structmember_CORBA_mOperationDescription, 9);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_OperationDescription = _0RL_tc_CORBA_mOperationDescription;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_OperationDescription = _0RL_tc_CORBA_mOperationDescription;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mRepositoryIdSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/RepositoryIdSeq:1.0", "RepositoryIdSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mRepositoryId));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_RepositoryIdSeq = _0RL_tc_CORBA_mRepositoryIdSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_RepositoryIdSeq = _0RL_tc_CORBA_mRepositoryIdSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mOpDescriptionSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/OpDescriptionSeq:1.0", "OpDescriptionSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mOperationDescription));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_OpDescriptionSeq = _0RL_tc_CORBA_mOpDescriptionSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_OpDescriptionSeq = _0RL_tc_CORBA_mOpDescriptionSeq;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mAttrDescriptionSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/AttrDescriptionSeq:1.0", "AttrDescriptionSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mAttributeDescription));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_AttrDescriptionSeq = _0RL_tc_CORBA_mAttrDescriptionSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_AttrDescriptionSeq = _0RL_tc_CORBA_mAttrDescriptionSeq;
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mInterfaceDef_mFullInterfaceDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"operations", _0RL_tc_CORBA_mOpDescriptionSeq},
  {"attributes", _0RL_tc_CORBA_mAttrDescriptionSeq},
  {"base_interfaces", _0RL_tc_CORBA_mRepositoryIdSeq},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mInterfaceDef_mFullInterfaceDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/InterfaceDef/FullInterfaceDescription:1.0", "FullInterfaceDescription", _0RL_structmember_CORBA_mInterfaceDef_mFullInterfaceDescription, 8);

const CORBA::TypeCode_ptr CORBA::InterfaceDef::_tc_FullInterfaceDescription = _0RL_tc_CORBA_mInterfaceDef_mFullInterfaceDescription;

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_InterfaceDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/InterfaceDef:1.0", "InterfaceDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_InterfaceDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/InterfaceDef:1.0", "InterfaceDef");
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mInterfaceDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"base_interfaces", _0RL_tc_CORBA_mRepositoryIdSeq}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mInterfaceDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/InterfaceDescription:1.0", "InterfaceDescription", _0RL_structmember_CORBA_mInterfaceDescription, 5);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_InterfaceDescription = _0RL_tc_CORBA_mInterfaceDescription;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_InterfaceDescription = _0RL_tc_CORBA_mInterfaceDescription;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mVisibility = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/Visibility:1.0", "Visibility", CORBA::TypeCode::PR_short_tc());

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_Visibility = _0RL_tc_CORBA_mVisibility;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_Visibility = _0RL_tc_CORBA_mVisibility;
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mValueMember[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()},
  {"type_def", CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/IDLType:1.0", "IDLType")},
  {"access", _0RL_tc_CORBA_mVisibility}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mValueMember = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ValueMember:1.0", "ValueMember", _0RL_structmember_CORBA_mValueMember, 7);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ValueMember = _0RL_tc_CORBA_mValueMember;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ValueMember = _0RL_tc_CORBA_mValueMember;
#endif

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mValueMemberSeq = CORBA::TypeCode::PR_alias_tc("IDL:omg.org/CORBA/ValueMemberSeq:1.0", "ValueMemberSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_CORBA_mValueMember));

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ValueMemberSeq = _0RL_tc_CORBA_mValueMemberSeq;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ValueMemberSeq = _0RL_tc_CORBA_mValueMemberSeq;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ValueMemberDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ValueMemberDef:1.0", "ValueMemberDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ValueMemberDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ValueMemberDef:1.0", "ValueMemberDef");
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mValueDef_mFullValueDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"is_abstract", CORBA::TypeCode::PR_boolean_tc()},
  {"is_custom", CORBA::TypeCode::PR_boolean_tc()},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"operations", _0RL_tc_CORBA_mOpDescriptionSeq},
  {"attributes", _0RL_tc_CORBA_mAttrDescriptionSeq},
  {"members", _0RL_tc_CORBA_mValueMemberSeq},
  {"initializers", _0RL_tc_CORBA_mInitializerSeq},
  {"supported_interfaces", _0RL_tc_CORBA_mRepositoryIdSeq},
  {"abstract_base_values", _0RL_tc_CORBA_mRepositoryIdSeq},
  {"is_truncatable", CORBA::TypeCode::PR_boolean_tc()},
  {"base_value", _0RL_tc_CORBA_mRepositoryId},
  {"type", CORBA::TypeCode::PR_TypeCode_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mValueDef_mFullValueDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ValueDef/FullValueDescription:1.0", "FullValueDescription", _0RL_structmember_CORBA_mValueDef_mFullValueDescription, 15);

const CORBA::TypeCode_ptr CORBA::ValueDef::_tc_FullValueDescription = _0RL_tc_CORBA_mValueDef_mFullValueDescription;

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ValueDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ValueDef:1.0", "ValueDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ValueDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ValueDef:1.0", "ValueDef");
#endif

static CORBA::PR_structMember _0RL_structmember_CORBA_mValueDescription[] = {
  {"name", _0RL_tc_CORBA_mIdentifier},
  {"id", _0RL_tc_CORBA_mRepositoryId},
  {"is_abstract", CORBA::TypeCode::PR_boolean_tc()},
  {"is_custom", CORBA::TypeCode::PR_boolean_tc()},
  {"defined_in", _0RL_tc_CORBA_mRepositoryId},
  {"version", _0RL_tc_CORBA_mVersionSpec},
  {"supported_interfaces", _0RL_tc_CORBA_mRepositoryIdSeq},
  {"abstract_base_values", _0RL_tc_CORBA_mRepositoryIdSeq},
  {"is_truncatable", CORBA::TypeCode::PR_boolean_tc()},
  {"base_value", _0RL_tc_CORBA_mRepositoryId}
};

static CORBA::TypeCode_ptr _0RL_tc_CORBA_mValueDescription = CORBA::TypeCode::PR_struct_tc("IDL:omg.org/CORBA/ValueDescription:1.0", "ValueDescription", _0RL_structmember_CORBA_mValueDescription, 10);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ValueDescription = _0RL_tc_CORBA_mValueDescription;
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ValueDescription = _0RL_tc_CORBA_mValueDescription;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_ValueBoxDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ValueBoxDef:1.0", "ValueBoxDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_ValueBoxDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/ValueBoxDef:1.0", "ValueBoxDef");
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.

namespace CORBA {
  const CORBA::TypeCode_ptr _tc_AbstractInterfaceDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/AbstractInterfaceDef:1.0", "AbstractInterfaceDef");
}
#else
const CORBA::TypeCode_ptr CORBA::_tc_AbstractInterfaceDef = CORBA::TypeCode::PR_interface_tc("IDL:omg.org/CORBA/AbstractInterfaceDef:1.0", "AbstractInterfaceDef");
#endif

void _0RL_buildDesc_cCORBA_mDefinitionKind(tcDescriptor& _desc, const CORBA::DefinitionKind& _data)
{
  _desc.p_enum = (CORBA::ULong*)&_data;
}

void operator<<=(CORBA::Any& _a, CORBA::DefinitionKind _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cCORBA_mDefinitionKind(_0RL_tcd, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mDefinitionKind, &_0RL_tcd);
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::DefinitionKind& _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cCORBA_mDefinitionKind(_0RL_tcd, _s);
  return _a.PR_unpackTo(_0RL_tc_CORBA_mDefinitionKind, &_0RL_tcd);
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mIRObject(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::IRObject_ptr _p = CORBA::IRObject::_narrow(_ptr);
  CORBA::IRObject_ptr* pp = (CORBA::IRObject_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mIRObject(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::IRObject_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mIRObject(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_IRObject, CORBA::IRObject_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mIRObject;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mIRObject;
}

void _0RL_delete_CORBA_mIRObject(void* _data) {
  CORBA::release((CORBA::IRObject_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::IRObject_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_IRObject, CORBA::IRObject_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mIRObject(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_IRObject, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::IRObject_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::IRObject::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::IRObject_ptr& _s) {
  CORBA::IRObject_ptr sp = (CORBA::IRObject_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::IRObject_var tmp;
    _0RL_buildDesc_cCORBA_mIRObject(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_IRObject, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::IRObject_ptr)tmp,_0RL_delete_CORBA_mIRObject);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::IRObject::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_IRObject)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::IRObject::_nil(); return 0;
    }
  }
}

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mContained(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_Contained, CORBA::Contained_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mRepository(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_Repository, CORBA::Repository_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mContainer(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_Container, CORBA::Container_Helper> &);

void _0RL_delete_CORBA_mContained_mDescription(void* _data) {
  CORBA::Contained::Description* _0RL_t = (CORBA::Contained::Description*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mContained_mDescription(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cCORBA_mDefinitionKind(_newdesc, ((CORBA::Contained::Description*)_desc->opq_struct)->kind);
    return 1;
  case 1:
    _0RL_buildDesc_cany(_newdesc, ((CORBA::Contained::Description*)_desc->opq_struct)->value);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mContained_mDescription(tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_cCORBA_mContained_mDescription(tcDescriptor &_desc, const CORBA::Contained::Description& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mContained_mDescription;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mContained_mDescription;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::Contained::Description& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mContained_mDescription(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mContained_mDescription, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::Contained::Description* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mContained_mDescription(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mContained_mDescription, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::Contained::Description*& _sp) {
  return _a >>= (const CORBA::Contained::Description*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::Contained::Description*& _sp) {
  _sp = (CORBA::Contained::Description *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::Contained::Description;
    _0RL_buildDesc_cCORBA_mContained_mDescription(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mContained_mDescription, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mContained_mDescription);
      return 1;
    } else {
      delete (CORBA::Contained::Description *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mContained_mDescription)) return 1;
    _sp = 0;
    return 0;
  }
}
static void
_0RL_tcParser_setObjectPtr_CORBA_mContained(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::Contained_ptr _p = CORBA::Contained::_narrow(_ptr);
  CORBA::Contained_ptr* pp = (CORBA::Contained_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mContained(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::Contained_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mContained(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_Contained, CORBA::Contained_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mContained;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mContained;
}

void _0RL_delete_CORBA_mContained(void* _data) {
  CORBA::release((CORBA::Contained_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::Contained_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_Contained, CORBA::Contained_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mContained(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_Contained, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::Contained_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::Contained::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::Contained_ptr& _s) {
  CORBA::Contained_ptr sp = (CORBA::Contained_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::Contained_var tmp;
    _0RL_buildDesc_cCORBA_mContained(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_Contained, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::Contained_ptr)tmp,_0RL_delete_CORBA_mContained);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::Contained::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_Contained)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::Contained::_nil(); return 0;
    }
  }
}

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mModuleDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ModuleDef, CORBA::ModuleDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mConstantDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ConstantDef, CORBA::ConstantDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mIDLType(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_IDLType, CORBA::IDLType_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mStructDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_StructDef, CORBA::StructDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mUnionDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_UnionDef, CORBA::UnionDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mEnumDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_EnumDef, CORBA::EnumDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mAliasDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_AliasDef, CORBA::AliasDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mInterfaceDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_InterfaceDef, CORBA::InterfaceDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mValueDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ValueDef, CORBA::ValueDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mValueBoxDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ValueBoxDef, CORBA::ValueBoxDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mExceptionDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ExceptionDef, CORBA::ExceptionDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mNativeDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_NativeDef, CORBA::NativeDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mAbstractInterfaceDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_AbstractInterfaceDef, CORBA::AbstractInterfaceDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mWstringDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_WstringDef, CORBA::WstringDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mFixedDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_FixedDef, CORBA::FixedDef_Helper> &);

#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mInterfaceDef__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mInterfaceDef__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mInterfaceDef(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_InterfaceDef, _CORBA_ObjRef_Element< CORBA::_objref_InterfaceDef, CORBA::InterfaceDef_Helper> , CORBA::InterfaceDef_Helper> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mInterfaceDef(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_InterfaceDef, _CORBA_ObjRef_Element< CORBA::_objref_InterfaceDef, CORBA::InterfaceDef_Helper> , CORBA::InterfaceDef_Helper> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mInterfaceDef(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mInterfaceDef(_newdesc, (*((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_InterfaceDef, _CORBA_ObjRef_Element< CORBA::_objref_InterfaceDef, CORBA::InterfaceDef_Helper> , CORBA::InterfaceDef_Helper> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mInterfaceDef(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_InterfaceDef, _CORBA_ObjRef_Element< CORBA::_objref_InterfaceDef, CORBA::InterfaceDef_Helper> , CORBA::InterfaceDef_Helper> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mInterfaceDef;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mInterfaceDef;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mInterfaceDef;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::InterfaceDefSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCORBA_mInterfaceDef(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_InterfaceDefSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mInterfaceDefSeq(void* _data)
{
  delete (CORBA::InterfaceDefSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::InterfaceDefSeq*& _s_out)
{
  return _a >>= (const CORBA::InterfaceDefSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::InterfaceDefSeq*& _s_out)
{
  _s_out = 0;
  CORBA::InterfaceDefSeq* stmp = (CORBA::InterfaceDefSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::InterfaceDefSeq;
    _0RL_buildDesc_s0_cCORBA_mInterfaceDef(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_InterfaceDefSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mInterfaceDefSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::InterfaceDefSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_InterfaceDefSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mValueDef__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mValueDef__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mValueDef(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_ValueDef, _CORBA_ObjRef_Element< CORBA::_objref_ValueDef, CORBA::ValueDef_Helper> , CORBA::ValueDef_Helper> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mValueDef(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_ValueDef, _CORBA_ObjRef_Element< CORBA::_objref_ValueDef, CORBA::ValueDef_Helper> , CORBA::ValueDef_Helper> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mValueDef(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mValueDef(_newdesc, (*((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_ValueDef, _CORBA_ObjRef_Element< CORBA::_objref_ValueDef, CORBA::ValueDef_Helper> , CORBA::ValueDef_Helper> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mValueDef(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_ValueDef, _CORBA_ObjRef_Element< CORBA::_objref_ValueDef, CORBA::ValueDef_Helper> , CORBA::ValueDef_Helper> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mValueDef;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mValueDef;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mValueDef;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::ValueDefSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCORBA_mValueDef(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_ValueDefSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mValueDefSeq(void* _data)
{
  delete (CORBA::ValueDefSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::ValueDefSeq*& _s_out)
{
  return _a >>= (const CORBA::ValueDefSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::ValueDefSeq*& _s_out)
{
  _s_out = 0;
  CORBA::ValueDefSeq* stmp = (CORBA::ValueDefSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::ValueDefSeq;
    _0RL_buildDesc_s0_cCORBA_mValueDef(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_ValueDefSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mValueDefSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::ValueDefSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_ValueDefSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mAbstractInterfaceDef__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mAbstractInterfaceDef__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mAbstractInterfaceDef(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_AbstractInterfaceDef, _CORBA_ObjRef_Element< CORBA::_objref_AbstractInterfaceDef, CORBA::AbstractInterfaceDef_Helper> , CORBA::AbstractInterfaceDef_Helper> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mAbstractInterfaceDef(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_AbstractInterfaceDef, _CORBA_ObjRef_Element< CORBA::_objref_AbstractInterfaceDef, CORBA::AbstractInterfaceDef_Helper> , CORBA::AbstractInterfaceDef_Helper> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mAbstractInterfaceDef(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mAbstractInterfaceDef(_newdesc, (*((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_AbstractInterfaceDef, _CORBA_ObjRef_Element< CORBA::_objref_AbstractInterfaceDef, CORBA::AbstractInterfaceDef_Helper> , CORBA::AbstractInterfaceDef_Helper> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mAbstractInterfaceDef(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_AbstractInterfaceDef, _CORBA_ObjRef_Element< CORBA::_objref_AbstractInterfaceDef, CORBA::AbstractInterfaceDef_Helper> , CORBA::AbstractInterfaceDef_Helper> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mAbstractInterfaceDef;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mAbstractInterfaceDef;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mAbstractInterfaceDef;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::AbstractInterfaceDefSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCORBA_mAbstractInterfaceDef(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_AbstractInterfaceDefSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mAbstractInterfaceDefSeq(void* _data)
{
  delete (CORBA::AbstractInterfaceDefSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::AbstractInterfaceDefSeq*& _s_out)
{
  return _a >>= (const CORBA::AbstractInterfaceDefSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::AbstractInterfaceDefSeq*& _s_out)
{
  _s_out = 0;
  CORBA::AbstractInterfaceDefSeq* stmp = (CORBA::AbstractInterfaceDefSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::AbstractInterfaceDefSeq;
    _0RL_buildDesc_s0_cCORBA_mAbstractInterfaceDef(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_AbstractInterfaceDefSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mAbstractInterfaceDefSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::AbstractInterfaceDefSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_AbstractInterfaceDefSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mContained__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mContained__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mContained(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_Contained, _CORBA_ObjRef_Element< CORBA::_objref_Contained, CORBA::Contained_Helper> , CORBA::Contained_Helper> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mContained(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_Contained, _CORBA_ObjRef_Element< CORBA::_objref_Contained, CORBA::Contained_Helper> , CORBA::Contained_Helper> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mContained(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mContained(_newdesc, (*((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_Contained, _CORBA_ObjRef_Element< CORBA::_objref_Contained, CORBA::Contained_Helper> , CORBA::Contained_Helper> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mContained(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_Contained, _CORBA_ObjRef_Element< CORBA::_objref_Contained, CORBA::Contained_Helper> , CORBA::Contained_Helper> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mContained;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mContained;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mContained;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::ContainedSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCORBA_mContained(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_ContainedSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mContainedSeq(void* _data)
{
  delete (CORBA::ContainedSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::ContainedSeq*& _s_out)
{
  return _a >>= (const CORBA::ContainedSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::ContainedSeq*& _s_out)
{
  _s_out = 0;
  CORBA::ContainedSeq* stmp = (CORBA::ContainedSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::ContainedSeq;
    _0RL_buildDesc_s0_cCORBA_mContained(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_ContainedSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mContainedSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::ContainedSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_ContainedSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_CORBA_mInitializer(void* _data) {
  CORBA::Initializer* _0RL_t = (CORBA::Initializer*) _data;
  delete _0RL_t;
}

extern void _0RL_buildDesc_cCORBA_mStructMember(tcDescriptor &, const CORBA::StructMember&);

#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mStructMember__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mStructMember__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mStructMember(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< CORBA::StructMember> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mStructMember(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< CORBA::StructMember> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mStructMember(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mStructMember(_newdesc, (*((_CORBA_Unbounded_Sequence< CORBA::StructMember> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mStructMember(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< CORBA::StructMember> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mStructMember;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mStructMember;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mStructMember;
  }
#endif

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mInitializer(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_s0_cCORBA_mStructMember(_newdesc, ((CORBA::Initializer*)_desc->opq_struct)->members);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::Initializer*)_desc->opq_struct)->name);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mInitializer(tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_cCORBA_mInitializer(tcDescriptor &_desc, const CORBA::Initializer& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mInitializer;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mInitializer;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::Initializer& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mInitializer(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mInitializer, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::Initializer* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mInitializer(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mInitializer, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::Initializer*& _sp) {
  return _a >>= (const CORBA::Initializer*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::Initializer*& _sp) {
  _sp = (CORBA::Initializer *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::Initializer;
    _0RL_buildDesc_cCORBA_mInitializer(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mInitializer, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mInitializer);
      return 1;
    } else {
      delete (CORBA::Initializer *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mInitializer)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mInitializer__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mInitializer__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mInitializer(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< CORBA::Initializer> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mInitializer(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< CORBA::Initializer> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mInitializer(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mInitializer(_newdesc, (*((_CORBA_Unbounded_Sequence< CORBA::Initializer> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mInitializer(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< CORBA::Initializer> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mInitializer;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mInitializer;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mInitializer;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::InitializerSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCORBA_mInitializer(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_InitializerSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mInitializerSeq(void* _data)
{
  delete (CORBA::InitializerSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::InitializerSeq*& _s_out)
{
  return _a >>= (const CORBA::InitializerSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::InitializerSeq*& _s_out)
{
  _s_out = 0;
  CORBA::InitializerSeq* stmp = (CORBA::InitializerSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::InitializerSeq;
    _0RL_buildDesc_s0_cCORBA_mInitializer(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_InitializerSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mInitializerSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::InitializerSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_InitializerSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_CORBA_mContainer_mDescription(void* _data) {
  CORBA::Container::Description* _0RL_t = (CORBA::Container::Description*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mContainer_mDescription(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cCORBA_mContained(_newdesc, ((CORBA::Container::Description*)_desc->opq_struct)->contained_object);
    return 1;
  case 1:
    _0RL_buildDesc_cCORBA_mDefinitionKind(_newdesc, ((CORBA::Container::Description*)_desc->opq_struct)->kind);
    return 1;
  case 2:
    _0RL_buildDesc_cany(_newdesc, ((CORBA::Container::Description*)_desc->opq_struct)->value);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mContainer_mDescription(tcStructDesc *_desc)
{
  return 3;
}

void _0RL_buildDesc_cCORBA_mContainer_mDescription(tcDescriptor &_desc, const CORBA::Container::Description& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mContainer_mDescription;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mContainer_mDescription;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::Container::Description& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mContainer_mDescription(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mContainer_mDescription, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::Container::Description* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mContainer_mDescription(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mContainer_mDescription, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::Container::Description*& _sp) {
  return _a >>= (const CORBA::Container::Description*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::Container::Description*& _sp) {
  _sp = (CORBA::Container::Description *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::Container::Description;
    _0RL_buildDesc_cCORBA_mContainer_mDescription(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mContainer_mDescription, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mContainer_mDescription);
      return 1;
    } else {
      delete (CORBA::Container::Description *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mContainer_mDescription)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mContainer_mDescription__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mContainer_mDescription__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mContainer_mDescription(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< CORBA::Container::Description> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mContainer_mDescription(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< CORBA::Container::Description> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mContainer_mDescription(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mContainer_mDescription(_newdesc, (*((_CORBA_Unbounded_Sequence< CORBA::Container::Description> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mContainer_mDescription(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< CORBA::Container::Description> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mContainer_mDescription;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mContainer_mDescription;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mContainer_mDescription;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::Container::DescriptionSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCORBA_mContainer_mDescription(tcdesc, _s);
  _a.PR_packFrom(CORBA::Container::_tc_DescriptionSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mContainer_mDescriptionSeq(void* _data)
{
  delete (CORBA::Container::DescriptionSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::Container::DescriptionSeq*& _s_out)
{
  return _a >>= (const CORBA::Container::DescriptionSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::Container::DescriptionSeq*& _s_out)
{
  _s_out = 0;
  CORBA::Container::DescriptionSeq* stmp = (CORBA::Container::DescriptionSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::Container::DescriptionSeq;
    _0RL_buildDesc_s0_cCORBA_mContainer_mDescription(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::Container::_tc_DescriptionSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mContainer_mDescriptionSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::Container::DescriptionSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::Container::_tc_DescriptionSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mContainer(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::Container_ptr _p = CORBA::Container::_narrow(_ptr);
  CORBA::Container_ptr* pp = (CORBA::Container_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mContainer(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::Container_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mContainer(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_Container, CORBA::Container_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mContainer;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mContainer;
}

void _0RL_delete_CORBA_mContainer(void* _data) {
  CORBA::release((CORBA::Container_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::Container_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_Container, CORBA::Container_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mContainer(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_Container, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::Container_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::Container::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::Container_ptr& _s) {
  CORBA::Container_ptr sp = (CORBA::Container_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::Container_var tmp;
    _0RL_buildDesc_cCORBA_mContainer(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_Container, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::Container_ptr)tmp,_0RL_delete_CORBA_mContainer);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::Container::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_Container)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::Container::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mIDLType(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::IDLType_ptr _p = CORBA::IDLType::_narrow(_ptr);
  CORBA::IDLType_ptr* pp = (CORBA::IDLType_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mIDLType(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::IDLType_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mIDLType(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_IDLType, CORBA::IDLType_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mIDLType;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mIDLType;
}

void _0RL_delete_CORBA_mIDLType(void* _data) {
  CORBA::release((CORBA::IDLType_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::IDLType_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_IDLType, CORBA::IDLType_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mIDLType(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_IDLType, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::IDLType_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::IDLType::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::IDLType_ptr& _s) {
  CORBA::IDLType_ptr sp = (CORBA::IDLType_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::IDLType_var tmp;
    _0RL_buildDesc_cCORBA_mIDLType(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_IDLType, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::IDLType_ptr)tmp,_0RL_delete_CORBA_mIDLType);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::IDLType::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_IDLType)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::IDLType::_nil(); return 0;
    }
  }
}

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mPrimitiveDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_PrimitiveDef, CORBA::PrimitiveDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mStringDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_StringDef, CORBA::StringDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mSequenceDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_SequenceDef, CORBA::SequenceDef_Helper> &);

// forward declaration of interface
 void _0RL_buildDesc_cCORBA_mArrayDef(tcDescriptor &, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ArrayDef, CORBA::ArrayDef_Helper> &);

void _0RL_buildDesc_cCORBA_mPrimitiveKind(tcDescriptor& _desc, const CORBA::PrimitiveKind& _data)
{
  _desc.p_enum = (CORBA::ULong*)&_data;
}

void operator<<=(CORBA::Any& _a, CORBA::PrimitiveKind _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cCORBA_mPrimitiveKind(_0RL_tcd, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mPrimitiveKind, &_0RL_tcd);
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::PrimitiveKind& _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cCORBA_mPrimitiveKind(_0RL_tcd, _s);
  return _a.PR_unpackTo(_0RL_tc_CORBA_mPrimitiveKind, &_0RL_tcd);
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mRepository(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::Repository_ptr _p = CORBA::Repository::_narrow(_ptr);
  CORBA::Repository_ptr* pp = (CORBA::Repository_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mRepository(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::Repository_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mRepository(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_Repository, CORBA::Repository_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mRepository;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mRepository;
}

void _0RL_delete_CORBA_mRepository(void* _data) {
  CORBA::release((CORBA::Repository_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::Repository_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_Repository, CORBA::Repository_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mRepository(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_Repository, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::Repository_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::Repository::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::Repository_ptr& _s) {
  CORBA::Repository_ptr sp = (CORBA::Repository_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::Repository_var tmp;
    _0RL_buildDesc_cCORBA_mRepository(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_Repository, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::Repository_ptr)tmp,_0RL_delete_CORBA_mRepository);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::Repository::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_Repository)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::Repository::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mModuleDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::ModuleDef_ptr _p = CORBA::ModuleDef::_narrow(_ptr);
  CORBA::ModuleDef_ptr* pp = (CORBA::ModuleDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mModuleDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::ModuleDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mModuleDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ModuleDef, CORBA::ModuleDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mModuleDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mModuleDef;
}

void _0RL_delete_CORBA_mModuleDef(void* _data) {
  CORBA::release((CORBA::ModuleDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::ModuleDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ModuleDef, CORBA::ModuleDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mModuleDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_ModuleDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::ModuleDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::ModuleDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ModuleDef_ptr& _s) {
  CORBA::ModuleDef_ptr sp = (CORBA::ModuleDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::ModuleDef_var tmp;
    _0RL_buildDesc_cCORBA_mModuleDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_ModuleDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::ModuleDef_ptr)tmp,_0RL_delete_CORBA_mModuleDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::ModuleDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_ModuleDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::ModuleDef::_nil(); return 0;
    }
  }
}

void _0RL_delete_CORBA_mModuleDescription(void* _data) {
  CORBA::ModuleDescription* _0RL_t = (CORBA::ModuleDescription*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mModuleDescription(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ModuleDescription*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ModuleDescription*)_desc->opq_struct)->id);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ModuleDescription*)_desc->opq_struct)->defined_in);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ModuleDescription*)_desc->opq_struct)->version);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mModuleDescription(tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_cCORBA_mModuleDescription(tcDescriptor &_desc, const CORBA::ModuleDescription& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mModuleDescription;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mModuleDescription;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::ModuleDescription& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mModuleDescription(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mModuleDescription, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::ModuleDescription* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mModuleDescription(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mModuleDescription, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ModuleDescription*& _sp) {
  return _a >>= (const CORBA::ModuleDescription*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::ModuleDescription*& _sp) {
  _sp = (CORBA::ModuleDescription *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::ModuleDescription;
    _0RL_buildDesc_cCORBA_mModuleDescription(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mModuleDescription, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mModuleDescription);
      return 1;
    } else {
      delete (CORBA::ModuleDescription *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mModuleDescription)) return 1;
    _sp = 0;
    return 0;
  }
}
static void
_0RL_tcParser_setObjectPtr_CORBA_mConstantDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::ConstantDef_ptr _p = CORBA::ConstantDef::_narrow(_ptr);
  CORBA::ConstantDef_ptr* pp = (CORBA::ConstantDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mConstantDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::ConstantDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mConstantDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ConstantDef, CORBA::ConstantDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mConstantDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mConstantDef;
}

void _0RL_delete_CORBA_mConstantDef(void* _data) {
  CORBA::release((CORBA::ConstantDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::ConstantDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ConstantDef, CORBA::ConstantDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mConstantDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_ConstantDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::ConstantDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::ConstantDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ConstantDef_ptr& _s) {
  CORBA::ConstantDef_ptr sp = (CORBA::ConstantDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::ConstantDef_var tmp;
    _0RL_buildDesc_cCORBA_mConstantDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_ConstantDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::ConstantDef_ptr)tmp,_0RL_delete_CORBA_mConstantDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::ConstantDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_ConstantDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::ConstantDef::_nil(); return 0;
    }
  }
}

void _0RL_delete_CORBA_mConstantDescription(void* _data) {
  CORBA::ConstantDescription* _0RL_t = (CORBA::ConstantDescription*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mConstantDescription(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ConstantDescription*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ConstantDescription*)_desc->opq_struct)->id);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ConstantDescription*)_desc->opq_struct)->defined_in);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ConstantDescription*)_desc->opq_struct)->version);
    return 1;
  case 4:
    _0RL_buildDesc_cTypeCode(_newdesc, ((CORBA::ConstantDescription*)_desc->opq_struct)->type);
    return 1;
  case 5:
    _0RL_buildDesc_cany(_newdesc, ((CORBA::ConstantDescription*)_desc->opq_struct)->value);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mConstantDescription(tcStructDesc *_desc)
{
  return 6;
}

void _0RL_buildDesc_cCORBA_mConstantDescription(tcDescriptor &_desc, const CORBA::ConstantDescription& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mConstantDescription;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mConstantDescription;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::ConstantDescription& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mConstantDescription(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mConstantDescription, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::ConstantDescription* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mConstantDescription(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mConstantDescription, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ConstantDescription*& _sp) {
  return _a >>= (const CORBA::ConstantDescription*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::ConstantDescription*& _sp) {
  _sp = (CORBA::ConstantDescription *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::ConstantDescription;
    _0RL_buildDesc_cCORBA_mConstantDescription(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mConstantDescription, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mConstantDescription);
      return 1;
    } else {
      delete (CORBA::ConstantDescription *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mConstantDescription)) return 1;
    _sp = 0;
    return 0;
  }
}
static void
_0RL_tcParser_setObjectPtr_CORBA_mTypedefDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::TypedefDef_ptr _p = CORBA::TypedefDef::_narrow(_ptr);
  CORBA::TypedefDef_ptr* pp = (CORBA::TypedefDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mTypedefDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::TypedefDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mTypedefDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_TypedefDef, CORBA::TypedefDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mTypedefDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mTypedefDef;
}

void _0RL_delete_CORBA_mTypedefDef(void* _data) {
  CORBA::release((CORBA::TypedefDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::TypedefDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_TypedefDef, CORBA::TypedefDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mTypedefDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_TypedefDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::TypedefDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::TypedefDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::TypedefDef_ptr& _s) {
  CORBA::TypedefDef_ptr sp = (CORBA::TypedefDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::TypedefDef_var tmp;
    _0RL_buildDesc_cCORBA_mTypedefDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_TypedefDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::TypedefDef_ptr)tmp,_0RL_delete_CORBA_mTypedefDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::TypedefDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_TypedefDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::TypedefDef::_nil(); return 0;
    }
  }
}

void _0RL_delete_CORBA_mTypeDescription(void* _data) {
  CORBA::TypeDescription* _0RL_t = (CORBA::TypeDescription*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mTypeDescription(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::TypeDescription*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::TypeDescription*)_desc->opq_struct)->id);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::TypeDescription*)_desc->opq_struct)->defined_in);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::TypeDescription*)_desc->opq_struct)->version);
    return 1;
  case 4:
    _0RL_buildDesc_cTypeCode(_newdesc, ((CORBA::TypeDescription*)_desc->opq_struct)->type);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mTypeDescription(tcStructDesc *_desc)
{
  return 5;
}

void _0RL_buildDesc_cCORBA_mTypeDescription(tcDescriptor &_desc, const CORBA::TypeDescription& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mTypeDescription;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mTypeDescription;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::TypeDescription& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mTypeDescription(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mTypeDescription, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::TypeDescription* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mTypeDescription(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mTypeDescription, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::TypeDescription*& _sp) {
  return _a >>= (const CORBA::TypeDescription*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::TypeDescription*& _sp) {
  _sp = (CORBA::TypeDescription *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::TypeDescription;
    _0RL_buildDesc_cCORBA_mTypeDescription(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mTypeDescription, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mTypeDescription);
      return 1;
    } else {
      delete (CORBA::TypeDescription *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mTypeDescription)) return 1;
    _sp = 0;
    return 0;
  }
}
static void
_0RL_tcParser_setObjectPtr_CORBA_mStructDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::StructDef_ptr _p = CORBA::StructDef::_narrow(_ptr);
  CORBA::StructDef_ptr* pp = (CORBA::StructDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mStructDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::StructDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mStructDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_StructDef, CORBA::StructDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mStructDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mStructDef;
}

void _0RL_delete_CORBA_mStructDef(void* _data) {
  CORBA::release((CORBA::StructDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::StructDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_StructDef, CORBA::StructDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mStructDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_StructDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::StructDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::StructDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::StructDef_ptr& _s) {
  CORBA::StructDef_ptr sp = (CORBA::StructDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::StructDef_var tmp;
    _0RL_buildDesc_cCORBA_mStructDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_StructDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::StructDef_ptr)tmp,_0RL_delete_CORBA_mStructDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::StructDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_StructDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::StructDef::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mUnionDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::UnionDef_ptr _p = CORBA::UnionDef::_narrow(_ptr);
  CORBA::UnionDef_ptr* pp = (CORBA::UnionDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mUnionDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::UnionDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mUnionDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_UnionDef, CORBA::UnionDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mUnionDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mUnionDef;
}

void _0RL_delete_CORBA_mUnionDef(void* _data) {
  CORBA::release((CORBA::UnionDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::UnionDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_UnionDef, CORBA::UnionDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mUnionDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_UnionDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::UnionDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::UnionDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::UnionDef_ptr& _s) {
  CORBA::UnionDef_ptr sp = (CORBA::UnionDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::UnionDef_var tmp;
    _0RL_buildDesc_cCORBA_mUnionDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_UnionDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::UnionDef_ptr)tmp,_0RL_delete_CORBA_mUnionDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::UnionDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_UnionDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::UnionDef::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mEnumDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::EnumDef_ptr _p = CORBA::EnumDef::_narrow(_ptr);
  CORBA::EnumDef_ptr* pp = (CORBA::EnumDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mEnumDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::EnumDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mEnumDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_EnumDef, CORBA::EnumDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mEnumDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mEnumDef;
}

void _0RL_delete_CORBA_mEnumDef(void* _data) {
  CORBA::release((CORBA::EnumDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::EnumDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_EnumDef, CORBA::EnumDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mEnumDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_EnumDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::EnumDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::EnumDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::EnumDef_ptr& _s) {
  CORBA::EnumDef_ptr sp = (CORBA::EnumDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::EnumDef_var tmp;
    _0RL_buildDesc_cCORBA_mEnumDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_EnumDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::EnumDef_ptr)tmp,_0RL_delete_CORBA_mEnumDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::EnumDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_EnumDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::EnumDef::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mAliasDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::AliasDef_ptr _p = CORBA::AliasDef::_narrow(_ptr);
  CORBA::AliasDef_ptr* pp = (CORBA::AliasDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mAliasDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::AliasDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mAliasDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_AliasDef, CORBA::AliasDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mAliasDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mAliasDef;
}

void _0RL_delete_CORBA_mAliasDef(void* _data) {
  CORBA::release((CORBA::AliasDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::AliasDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_AliasDef, CORBA::AliasDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mAliasDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_AliasDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::AliasDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::AliasDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::AliasDef_ptr& _s) {
  CORBA::AliasDef_ptr sp = (CORBA::AliasDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::AliasDef_var tmp;
    _0RL_buildDesc_cCORBA_mAliasDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_AliasDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::AliasDef_ptr)tmp,_0RL_delete_CORBA_mAliasDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::AliasDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_AliasDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::AliasDef::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mNativeDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::NativeDef_ptr _p = CORBA::NativeDef::_narrow(_ptr);
  CORBA::NativeDef_ptr* pp = (CORBA::NativeDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mNativeDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::NativeDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mNativeDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_NativeDef, CORBA::NativeDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mNativeDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mNativeDef;
}

void _0RL_delete_CORBA_mNativeDef(void* _data) {
  CORBA::release((CORBA::NativeDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::NativeDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_NativeDef, CORBA::NativeDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mNativeDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_NativeDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::NativeDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::NativeDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::NativeDef_ptr& _s) {
  CORBA::NativeDef_ptr sp = (CORBA::NativeDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::NativeDef_var tmp;
    _0RL_buildDesc_cCORBA_mNativeDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_NativeDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::NativeDef_ptr)tmp,_0RL_delete_CORBA_mNativeDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::NativeDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_NativeDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::NativeDef::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mPrimitiveDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::PrimitiveDef_ptr _p = CORBA::PrimitiveDef::_narrow(_ptr);
  CORBA::PrimitiveDef_ptr* pp = (CORBA::PrimitiveDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mPrimitiveDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::PrimitiveDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mPrimitiveDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_PrimitiveDef, CORBA::PrimitiveDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mPrimitiveDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mPrimitiveDef;
}

void _0RL_delete_CORBA_mPrimitiveDef(void* _data) {
  CORBA::release((CORBA::PrimitiveDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::PrimitiveDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_PrimitiveDef, CORBA::PrimitiveDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mPrimitiveDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_PrimitiveDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::PrimitiveDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::PrimitiveDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::PrimitiveDef_ptr& _s) {
  CORBA::PrimitiveDef_ptr sp = (CORBA::PrimitiveDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::PrimitiveDef_var tmp;
    _0RL_buildDesc_cCORBA_mPrimitiveDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_PrimitiveDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::PrimitiveDef_ptr)tmp,_0RL_delete_CORBA_mPrimitiveDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::PrimitiveDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_PrimitiveDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::PrimitiveDef::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mStringDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::StringDef_ptr _p = CORBA::StringDef::_narrow(_ptr);
  CORBA::StringDef_ptr* pp = (CORBA::StringDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mStringDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::StringDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mStringDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_StringDef, CORBA::StringDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mStringDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mStringDef;
}

void _0RL_delete_CORBA_mStringDef(void* _data) {
  CORBA::release((CORBA::StringDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::StringDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_StringDef, CORBA::StringDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mStringDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_StringDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::StringDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::StringDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::StringDef_ptr& _s) {
  CORBA::StringDef_ptr sp = (CORBA::StringDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::StringDef_var tmp;
    _0RL_buildDesc_cCORBA_mStringDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_StringDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::StringDef_ptr)tmp,_0RL_delete_CORBA_mStringDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::StringDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_StringDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::StringDef::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mWstringDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::WstringDef_ptr _p = CORBA::WstringDef::_narrow(_ptr);
  CORBA::WstringDef_ptr* pp = (CORBA::WstringDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mWstringDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::WstringDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mWstringDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_WstringDef, CORBA::WstringDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mWstringDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mWstringDef;
}

void _0RL_delete_CORBA_mWstringDef(void* _data) {
  CORBA::release((CORBA::WstringDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::WstringDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_WstringDef, CORBA::WstringDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mWstringDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_WstringDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::WstringDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::WstringDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::WstringDef_ptr& _s) {
  CORBA::WstringDef_ptr sp = (CORBA::WstringDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::WstringDef_var tmp;
    _0RL_buildDesc_cCORBA_mWstringDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_WstringDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::WstringDef_ptr)tmp,_0RL_delete_CORBA_mWstringDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::WstringDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_WstringDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::WstringDef::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mFixedDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::FixedDef_ptr _p = CORBA::FixedDef::_narrow(_ptr);
  CORBA::FixedDef_ptr* pp = (CORBA::FixedDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mFixedDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::FixedDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mFixedDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_FixedDef, CORBA::FixedDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mFixedDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mFixedDef;
}

void _0RL_delete_CORBA_mFixedDef(void* _data) {
  CORBA::release((CORBA::FixedDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::FixedDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_FixedDef, CORBA::FixedDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mFixedDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_FixedDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::FixedDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::FixedDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::FixedDef_ptr& _s) {
  CORBA::FixedDef_ptr sp = (CORBA::FixedDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::FixedDef_var tmp;
    _0RL_buildDesc_cCORBA_mFixedDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_FixedDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::FixedDef_ptr)tmp,_0RL_delete_CORBA_mFixedDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::FixedDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_FixedDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::FixedDef::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mSequenceDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::SequenceDef_ptr _p = CORBA::SequenceDef::_narrow(_ptr);
  CORBA::SequenceDef_ptr* pp = (CORBA::SequenceDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mSequenceDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::SequenceDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mSequenceDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_SequenceDef, CORBA::SequenceDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mSequenceDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mSequenceDef;
}

void _0RL_delete_CORBA_mSequenceDef(void* _data) {
  CORBA::release((CORBA::SequenceDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::SequenceDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_SequenceDef, CORBA::SequenceDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mSequenceDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_SequenceDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::SequenceDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::SequenceDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::SequenceDef_ptr& _s) {
  CORBA::SequenceDef_ptr sp = (CORBA::SequenceDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::SequenceDef_var tmp;
    _0RL_buildDesc_cCORBA_mSequenceDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_SequenceDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::SequenceDef_ptr)tmp,_0RL_delete_CORBA_mSequenceDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::SequenceDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_SequenceDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::SequenceDef::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mArrayDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::ArrayDef_ptr _p = CORBA::ArrayDef::_narrow(_ptr);
  CORBA::ArrayDef_ptr* pp = (CORBA::ArrayDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mArrayDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::ArrayDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mArrayDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ArrayDef, CORBA::ArrayDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mArrayDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mArrayDef;
}

void _0RL_delete_CORBA_mArrayDef(void* _data) {
  CORBA::release((CORBA::ArrayDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::ArrayDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ArrayDef, CORBA::ArrayDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mArrayDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_ArrayDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::ArrayDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::ArrayDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ArrayDef_ptr& _s) {
  CORBA::ArrayDef_ptr sp = (CORBA::ArrayDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::ArrayDef_var tmp;
    _0RL_buildDesc_cCORBA_mArrayDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_ArrayDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::ArrayDef_ptr)tmp,_0RL_delete_CORBA_mArrayDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::ArrayDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_ArrayDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::ArrayDef::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mExceptionDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::ExceptionDef_ptr _p = CORBA::ExceptionDef::_narrow(_ptr);
  CORBA::ExceptionDef_ptr* pp = (CORBA::ExceptionDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mExceptionDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::ExceptionDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mExceptionDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ExceptionDef, CORBA::ExceptionDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mExceptionDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mExceptionDef;
}

void _0RL_delete_CORBA_mExceptionDef(void* _data) {
  CORBA::release((CORBA::ExceptionDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::ExceptionDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ExceptionDef, CORBA::ExceptionDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mExceptionDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_ExceptionDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::ExceptionDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::ExceptionDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ExceptionDef_ptr& _s) {
  CORBA::ExceptionDef_ptr sp = (CORBA::ExceptionDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::ExceptionDef_var tmp;
    _0RL_buildDesc_cCORBA_mExceptionDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_ExceptionDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::ExceptionDef_ptr)tmp,_0RL_delete_CORBA_mExceptionDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::ExceptionDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_ExceptionDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::ExceptionDef::_nil(); return 0;
    }
  }
}

void _0RL_delete_CORBA_mExceptionDescription(void* _data) {
  CORBA::ExceptionDescription* _0RL_t = (CORBA::ExceptionDescription*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mExceptionDescription(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ExceptionDescription*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ExceptionDescription*)_desc->opq_struct)->id);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ExceptionDescription*)_desc->opq_struct)->defined_in);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ExceptionDescription*)_desc->opq_struct)->version);
    return 1;
  case 4:
    _0RL_buildDesc_cTypeCode(_newdesc, ((CORBA::ExceptionDescription*)_desc->opq_struct)->type);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mExceptionDescription(tcStructDesc *_desc)
{
  return 5;
}

void _0RL_buildDesc_cCORBA_mExceptionDescription(tcDescriptor &_desc, const CORBA::ExceptionDescription& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mExceptionDescription;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mExceptionDescription;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::ExceptionDescription& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mExceptionDescription(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mExceptionDescription, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::ExceptionDescription* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mExceptionDescription(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mExceptionDescription, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ExceptionDescription*& _sp) {
  return _a >>= (const CORBA::ExceptionDescription*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::ExceptionDescription*& _sp) {
  _sp = (CORBA::ExceptionDescription *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::ExceptionDescription;
    _0RL_buildDesc_cCORBA_mExceptionDescription(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mExceptionDescription, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mExceptionDescription);
      return 1;
    } else {
      delete (CORBA::ExceptionDescription *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mExceptionDescription)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_buildDesc_cCORBA_mAttributeMode(tcDescriptor& _desc, const CORBA::AttributeMode& _data)
{
  _desc.p_enum = (CORBA::ULong*)&_data;
}

void operator<<=(CORBA::Any& _a, CORBA::AttributeMode _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cCORBA_mAttributeMode(_0RL_tcd, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mAttributeMode, &_0RL_tcd);
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::AttributeMode& _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cCORBA_mAttributeMode(_0RL_tcd, _s);
  return _a.PR_unpackTo(_0RL_tc_CORBA_mAttributeMode, &_0RL_tcd);
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mAttributeDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::AttributeDef_ptr _p = CORBA::AttributeDef::_narrow(_ptr);
  CORBA::AttributeDef_ptr* pp = (CORBA::AttributeDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mAttributeDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::AttributeDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mAttributeDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_AttributeDef, CORBA::AttributeDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mAttributeDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mAttributeDef;
}

void _0RL_delete_CORBA_mAttributeDef(void* _data) {
  CORBA::release((CORBA::AttributeDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::AttributeDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_AttributeDef, CORBA::AttributeDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mAttributeDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_AttributeDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::AttributeDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::AttributeDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::AttributeDef_ptr& _s) {
  CORBA::AttributeDef_ptr sp = (CORBA::AttributeDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::AttributeDef_var tmp;
    _0RL_buildDesc_cCORBA_mAttributeDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_AttributeDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::AttributeDef_ptr)tmp,_0RL_delete_CORBA_mAttributeDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::AttributeDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_AttributeDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::AttributeDef::_nil(); return 0;
    }
  }
}

void _0RL_delete_CORBA_mAttributeDescription(void* _data) {
  CORBA::AttributeDescription* _0RL_t = (CORBA::AttributeDescription*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mAttributeDescription(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::AttributeDescription*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::AttributeDescription*)_desc->opq_struct)->id);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::AttributeDescription*)_desc->opq_struct)->defined_in);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::AttributeDescription*)_desc->opq_struct)->version);
    return 1;
  case 4:
    _0RL_buildDesc_cTypeCode(_newdesc, ((CORBA::AttributeDescription*)_desc->opq_struct)->type);
    return 1;
  case 5:
    _0RL_buildDesc_cCORBA_mAttributeMode(_newdesc, ((CORBA::AttributeDescription*)_desc->opq_struct)->mode);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mAttributeDescription(tcStructDesc *_desc)
{
  return 6;
}

void _0RL_buildDesc_cCORBA_mAttributeDescription(tcDescriptor &_desc, const CORBA::AttributeDescription& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mAttributeDescription;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mAttributeDescription;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::AttributeDescription& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mAttributeDescription(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mAttributeDescription, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::AttributeDescription* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mAttributeDescription(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mAttributeDescription, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::AttributeDescription*& _sp) {
  return _a >>= (const CORBA::AttributeDescription*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::AttributeDescription*& _sp) {
  _sp = (CORBA::AttributeDescription *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::AttributeDescription;
    _0RL_buildDesc_cCORBA_mAttributeDescription(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mAttributeDescription, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mAttributeDescription);
      return 1;
    } else {
      delete (CORBA::AttributeDescription *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mAttributeDescription)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_buildDesc_cCORBA_mOperationMode(tcDescriptor& _desc, const CORBA::OperationMode& _data)
{
  _desc.p_enum = (CORBA::ULong*)&_data;
}

void operator<<=(CORBA::Any& _a, CORBA::OperationMode _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cCORBA_mOperationMode(_0RL_tcd, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mOperationMode, &_0RL_tcd);
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::OperationMode& _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cCORBA_mOperationMode(_0RL_tcd, _s);
  return _a.PR_unpackTo(_0RL_tc_CORBA_mOperationMode, &_0RL_tcd);
}

void _0RL_buildDesc_cCORBA_mParameterMode(tcDescriptor& _desc, const CORBA::ParameterMode& _data)
{
  _desc.p_enum = (CORBA::ULong*)&_data;
}

void operator<<=(CORBA::Any& _a, CORBA::ParameterMode _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cCORBA_mParameterMode(_0RL_tcd, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mParameterMode, &_0RL_tcd);
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ParameterMode& _s)
{
  tcDescriptor _0RL_tcd;
  _0RL_buildDesc_cCORBA_mParameterMode(_0RL_tcd, _s);
  return _a.PR_unpackTo(_0RL_tc_CORBA_mParameterMode, &_0RL_tcd);
}

void _0RL_delete_CORBA_mParameterDescription(void* _data) {
  CORBA::ParameterDescription* _0RL_t = (CORBA::ParameterDescription*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mParameterDescription(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ParameterDescription*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cTypeCode(_newdesc, ((CORBA::ParameterDescription*)_desc->opq_struct)->type);
    return 1;
  case 2:
    _0RL_buildDesc_cCORBA_mIDLType(_newdesc, ((CORBA::ParameterDescription*)_desc->opq_struct)->type_def);
    return 1;
  case 3:
    _0RL_buildDesc_cCORBA_mParameterMode(_newdesc, ((CORBA::ParameterDescription*)_desc->opq_struct)->mode);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mParameterDescription(tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_cCORBA_mParameterDescription(tcDescriptor &_desc, const CORBA::ParameterDescription& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mParameterDescription;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mParameterDescription;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::ParameterDescription& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mParameterDescription(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mParameterDescription, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::ParameterDescription* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mParameterDescription(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mParameterDescription, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ParameterDescription*& _sp) {
  return _a >>= (const CORBA::ParameterDescription*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::ParameterDescription*& _sp) {
  _sp = (CORBA::ParameterDescription *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::ParameterDescription;
    _0RL_buildDesc_cCORBA_mParameterDescription(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mParameterDescription, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mParameterDescription);
      return 1;
    } else {
      delete (CORBA::ParameterDescription *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mParameterDescription)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mParameterDescription__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mParameterDescription__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mParameterDescription(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< CORBA::ParameterDescription> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mParameterDescription(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< CORBA::ParameterDescription> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mParameterDescription(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mParameterDescription(_newdesc, (*((_CORBA_Unbounded_Sequence< CORBA::ParameterDescription> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mParameterDescription(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< CORBA::ParameterDescription> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mParameterDescription;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mParameterDescription;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mParameterDescription;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::ParDescriptionSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCORBA_mParameterDescription(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_ParDescriptionSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mParDescriptionSeq(void* _data)
{
  delete (CORBA::ParDescriptionSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::ParDescriptionSeq*& _s_out)
{
  return _a >>= (const CORBA::ParDescriptionSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::ParDescriptionSeq*& _s_out)
{
  _s_out = 0;
  CORBA::ParDescriptionSeq* stmp = (CORBA::ParDescriptionSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::ParDescriptionSeq;
    _0RL_buildDesc_s0_cCORBA_mParameterDescription(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_ParDescriptionSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mParDescriptionSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::ParDescriptionSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_ParDescriptionSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cstring__
#define __0RL_tcParser_buildDesc_s0_cstring__
static void
_0RL_tcParser_setElementCount_s0_cstring(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence__String*)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cstring(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence__String*)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cstring(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cstring(_newdesc, (*((_CORBA_Unbounded_Sequence__String*)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cstring(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence__String& _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cstring;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cstring;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cstring;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::ContextIdSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cstring(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_ContextIdSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mContextIdSeq(void* _data)
{
  delete (CORBA::ContextIdSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::ContextIdSeq*& _s_out)
{
  return _a >>= (const CORBA::ContextIdSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::ContextIdSeq*& _s_out)
{
  _s_out = 0;
  CORBA::ContextIdSeq* stmp = (CORBA::ContextIdSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::ContextIdSeq;
    _0RL_buildDesc_s0_cstring(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_ContextIdSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mContextIdSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::ContextIdSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_ContextIdSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mExceptionDef__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mExceptionDef__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mExceptionDef(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_ExceptionDef, _CORBA_ObjRef_Element< CORBA::_objref_ExceptionDef, CORBA::ExceptionDef_Helper> , CORBA::ExceptionDef_Helper> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mExceptionDef(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_ExceptionDef, _CORBA_ObjRef_Element< CORBA::_objref_ExceptionDef, CORBA::ExceptionDef_Helper> , CORBA::ExceptionDef_Helper> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mExceptionDef(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mExceptionDef(_newdesc, (*((_CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_ExceptionDef, _CORBA_ObjRef_Element< CORBA::_objref_ExceptionDef, CORBA::ExceptionDef_Helper> , CORBA::ExceptionDef_Helper> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mExceptionDef(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_ObjRef< CORBA::_objref_ExceptionDef, _CORBA_ObjRef_Element< CORBA::_objref_ExceptionDef, CORBA::ExceptionDef_Helper> , CORBA::ExceptionDef_Helper> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mExceptionDef;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mExceptionDef;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mExceptionDef;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::ExceptionDefSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCORBA_mExceptionDef(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_ExceptionDefSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mExceptionDefSeq(void* _data)
{
  delete (CORBA::ExceptionDefSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::ExceptionDefSeq*& _s_out)
{
  return _a >>= (const CORBA::ExceptionDefSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::ExceptionDefSeq*& _s_out)
{
  _s_out = 0;
  CORBA::ExceptionDefSeq* stmp = (CORBA::ExceptionDefSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::ExceptionDefSeq;
    _0RL_buildDesc_s0_cCORBA_mExceptionDef(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_ExceptionDefSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mExceptionDefSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::ExceptionDefSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_ExceptionDefSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mExceptionDescription__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mExceptionDescription__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mExceptionDescription(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< CORBA::ExceptionDescription> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mExceptionDescription(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< CORBA::ExceptionDescription> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mExceptionDescription(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mExceptionDescription(_newdesc, (*((_CORBA_Unbounded_Sequence< CORBA::ExceptionDescription> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mExceptionDescription(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< CORBA::ExceptionDescription> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mExceptionDescription;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mExceptionDescription;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mExceptionDescription;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::ExcDescriptionSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCORBA_mExceptionDescription(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_ExcDescriptionSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mExcDescriptionSeq(void* _data)
{
  delete (CORBA::ExcDescriptionSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::ExcDescriptionSeq*& _s_out)
{
  return _a >>= (const CORBA::ExcDescriptionSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::ExcDescriptionSeq*& _s_out)
{
  _s_out = 0;
  CORBA::ExcDescriptionSeq* stmp = (CORBA::ExcDescriptionSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::ExcDescriptionSeq;
    _0RL_buildDesc_s0_cCORBA_mExceptionDescription(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_ExcDescriptionSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mExcDescriptionSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::ExcDescriptionSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_ExcDescriptionSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mOperationDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::OperationDef_ptr _p = CORBA::OperationDef::_narrow(_ptr);
  CORBA::OperationDef_ptr* pp = (CORBA::OperationDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mOperationDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::OperationDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mOperationDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_OperationDef, CORBA::OperationDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mOperationDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mOperationDef;
}

void _0RL_delete_CORBA_mOperationDef(void* _data) {
  CORBA::release((CORBA::OperationDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::OperationDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_OperationDef, CORBA::OperationDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mOperationDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_OperationDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::OperationDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::OperationDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::OperationDef_ptr& _s) {
  CORBA::OperationDef_ptr sp = (CORBA::OperationDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::OperationDef_var tmp;
    _0RL_buildDesc_cCORBA_mOperationDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_OperationDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::OperationDef_ptr)tmp,_0RL_delete_CORBA_mOperationDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::OperationDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_OperationDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::OperationDef::_nil(); return 0;
    }
  }
}

void _0RL_delete_CORBA_mOperationDescription(void* _data) {
  CORBA::OperationDescription* _0RL_t = (CORBA::OperationDescription*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mOperationDescription(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::OperationDescription*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::OperationDescription*)_desc->opq_struct)->id);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::OperationDescription*)_desc->opq_struct)->defined_in);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::OperationDescription*)_desc->opq_struct)->version);
    return 1;
  case 4:
    _0RL_buildDesc_cTypeCode(_newdesc, ((CORBA::OperationDescription*)_desc->opq_struct)->result);
    return 1;
  case 5:
    _0RL_buildDesc_cCORBA_mOperationMode(_newdesc, ((CORBA::OperationDescription*)_desc->opq_struct)->mode);
    return 1;
  case 6:
    _0RL_buildDesc_s0_cstring(_newdesc, ((CORBA::OperationDescription*)_desc->opq_struct)->contexts);
    return 1;
  case 7:
    _0RL_buildDesc_s0_cCORBA_mParameterDescription(_newdesc, ((CORBA::OperationDescription*)_desc->opq_struct)->parameters);
    return 1;
  case 8:
    _0RL_buildDesc_s0_cCORBA_mExceptionDescription(_newdesc, ((CORBA::OperationDescription*)_desc->opq_struct)->exceptions);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mOperationDescription(tcStructDesc *_desc)
{
  return 9;
}

void _0RL_buildDesc_cCORBA_mOperationDescription(tcDescriptor &_desc, const CORBA::OperationDescription& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mOperationDescription;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mOperationDescription;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::OperationDescription& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mOperationDescription(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mOperationDescription, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::OperationDescription* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mOperationDescription(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mOperationDescription, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::OperationDescription*& _sp) {
  return _a >>= (const CORBA::OperationDescription*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::OperationDescription*& _sp) {
  _sp = (CORBA::OperationDescription *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::OperationDescription;
    _0RL_buildDesc_cCORBA_mOperationDescription(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mOperationDescription, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mOperationDescription);
      return 1;
    } else {
      delete (CORBA::OperationDescription *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mOperationDescription)) return 1;
    _sp = 0;
    return 0;
  }
}
void operator <<= (CORBA::Any& _a, const CORBA::RepositoryIdSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cstring(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_RepositoryIdSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mRepositoryIdSeq(void* _data)
{
  delete (CORBA::RepositoryIdSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::RepositoryIdSeq*& _s_out)
{
  return _a >>= (const CORBA::RepositoryIdSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::RepositoryIdSeq*& _s_out)
{
  _s_out = 0;
  CORBA::RepositoryIdSeq* stmp = (CORBA::RepositoryIdSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::RepositoryIdSeq;
    _0RL_buildDesc_s0_cstring(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_RepositoryIdSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mRepositoryIdSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::RepositoryIdSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_RepositoryIdSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mOperationDescription__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mOperationDescription__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mOperationDescription(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< CORBA::OperationDescription> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mOperationDescription(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< CORBA::OperationDescription> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mOperationDescription(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mOperationDescription(_newdesc, (*((_CORBA_Unbounded_Sequence< CORBA::OperationDescription> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mOperationDescription(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< CORBA::OperationDescription> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mOperationDescription;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mOperationDescription;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mOperationDescription;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::OpDescriptionSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCORBA_mOperationDescription(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_OpDescriptionSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mOpDescriptionSeq(void* _data)
{
  delete (CORBA::OpDescriptionSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::OpDescriptionSeq*& _s_out)
{
  return _a >>= (const CORBA::OpDescriptionSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::OpDescriptionSeq*& _s_out)
{
  _s_out = 0;
  CORBA::OpDescriptionSeq* stmp = (CORBA::OpDescriptionSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::OpDescriptionSeq;
    _0RL_buildDesc_s0_cCORBA_mOperationDescription(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_OpDescriptionSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mOpDescriptionSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::OpDescriptionSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_OpDescriptionSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mAttributeDescription__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mAttributeDescription__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mAttributeDescription(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< CORBA::AttributeDescription> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mAttributeDescription(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< CORBA::AttributeDescription> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mAttributeDescription(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mAttributeDescription(_newdesc, (*((_CORBA_Unbounded_Sequence< CORBA::AttributeDescription> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mAttributeDescription(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< CORBA::AttributeDescription> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mAttributeDescription;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mAttributeDescription;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mAttributeDescription;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::AttrDescriptionSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCORBA_mAttributeDescription(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_AttrDescriptionSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mAttrDescriptionSeq(void* _data)
{
  delete (CORBA::AttrDescriptionSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::AttrDescriptionSeq*& _s_out)
{
  return _a >>= (const CORBA::AttrDescriptionSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::AttrDescriptionSeq*& _s_out)
{
  _s_out = 0;
  CORBA::AttrDescriptionSeq* stmp = (CORBA::AttrDescriptionSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::AttrDescriptionSeq;
    _0RL_buildDesc_s0_cCORBA_mAttributeDescription(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_AttrDescriptionSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mAttrDescriptionSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::AttrDescriptionSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_AttrDescriptionSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_CORBA_mInterfaceDef_mFullInterfaceDescription(void* _data) {
  CORBA::InterfaceDef::FullInterfaceDescription* _0RL_t = (CORBA::InterfaceDef::FullInterfaceDescription*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mInterfaceDef_mFullInterfaceDescription(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::InterfaceDef::FullInterfaceDescription*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::InterfaceDef::FullInterfaceDescription*)_desc->opq_struct)->id);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::InterfaceDef::FullInterfaceDescription*)_desc->opq_struct)->defined_in);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::InterfaceDef::FullInterfaceDescription*)_desc->opq_struct)->version);
    return 1;
  case 4:
    _0RL_buildDesc_s0_cCORBA_mOperationDescription(_newdesc, ((CORBA::InterfaceDef::FullInterfaceDescription*)_desc->opq_struct)->operations);
    return 1;
  case 5:
    _0RL_buildDesc_s0_cCORBA_mAttributeDescription(_newdesc, ((CORBA::InterfaceDef::FullInterfaceDescription*)_desc->opq_struct)->attributes);
    return 1;
  case 6:
    _0RL_buildDesc_s0_cstring(_newdesc, ((CORBA::InterfaceDef::FullInterfaceDescription*)_desc->opq_struct)->base_interfaces);
    return 1;
  case 7:
    _0RL_buildDesc_cTypeCode(_newdesc, ((CORBA::InterfaceDef::FullInterfaceDescription*)_desc->opq_struct)->type);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mInterfaceDef_mFullInterfaceDescription(tcStructDesc *_desc)
{
  return 8;
}

void _0RL_buildDesc_cCORBA_mInterfaceDef_mFullInterfaceDescription(tcDescriptor &_desc, const CORBA::InterfaceDef::FullInterfaceDescription& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mInterfaceDef_mFullInterfaceDescription;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mInterfaceDef_mFullInterfaceDescription;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::InterfaceDef::FullInterfaceDescription& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mInterfaceDef_mFullInterfaceDescription(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mInterfaceDef_mFullInterfaceDescription, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::InterfaceDef::FullInterfaceDescription* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mInterfaceDef_mFullInterfaceDescription(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mInterfaceDef_mFullInterfaceDescription, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::InterfaceDef::FullInterfaceDescription*& _sp) {
  return _a >>= (const CORBA::InterfaceDef::FullInterfaceDescription*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::InterfaceDef::FullInterfaceDescription*& _sp) {
  _sp = (CORBA::InterfaceDef::FullInterfaceDescription *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::InterfaceDef::FullInterfaceDescription;
    _0RL_buildDesc_cCORBA_mInterfaceDef_mFullInterfaceDescription(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mInterfaceDef_mFullInterfaceDescription, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mInterfaceDef_mFullInterfaceDescription);
      return 1;
    } else {
      delete (CORBA::InterfaceDef::FullInterfaceDescription *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mInterfaceDef_mFullInterfaceDescription)) return 1;
    _sp = 0;
    return 0;
  }
}
static void
_0RL_tcParser_setObjectPtr_CORBA_mInterfaceDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::InterfaceDef_ptr _p = CORBA::InterfaceDef::_narrow(_ptr);
  CORBA::InterfaceDef_ptr* pp = (CORBA::InterfaceDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mInterfaceDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::InterfaceDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mInterfaceDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_InterfaceDef, CORBA::InterfaceDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mInterfaceDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mInterfaceDef;
}

void _0RL_delete_CORBA_mInterfaceDef(void* _data) {
  CORBA::release((CORBA::InterfaceDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::InterfaceDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_InterfaceDef, CORBA::InterfaceDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mInterfaceDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_InterfaceDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::InterfaceDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::InterfaceDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::InterfaceDef_ptr& _s) {
  CORBA::InterfaceDef_ptr sp = (CORBA::InterfaceDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::InterfaceDef_var tmp;
    _0RL_buildDesc_cCORBA_mInterfaceDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_InterfaceDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::InterfaceDef_ptr)tmp,_0RL_delete_CORBA_mInterfaceDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::InterfaceDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_InterfaceDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::InterfaceDef::_nil(); return 0;
    }
  }
}

void _0RL_delete_CORBA_mInterfaceDescription(void* _data) {
  CORBA::InterfaceDescription* _0RL_t = (CORBA::InterfaceDescription*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mInterfaceDescription(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::InterfaceDescription*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::InterfaceDescription*)_desc->opq_struct)->id);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::InterfaceDescription*)_desc->opq_struct)->defined_in);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::InterfaceDescription*)_desc->opq_struct)->version);
    return 1;
  case 4:
    _0RL_buildDesc_s0_cstring(_newdesc, ((CORBA::InterfaceDescription*)_desc->opq_struct)->base_interfaces);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mInterfaceDescription(tcStructDesc *_desc)
{
  return 5;
}

void _0RL_buildDesc_cCORBA_mInterfaceDescription(tcDescriptor &_desc, const CORBA::InterfaceDescription& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mInterfaceDescription;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mInterfaceDescription;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::InterfaceDescription& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mInterfaceDescription(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mInterfaceDescription, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::InterfaceDescription* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mInterfaceDescription(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mInterfaceDescription, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::InterfaceDescription*& _sp) {
  return _a >>= (const CORBA::InterfaceDescription*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::InterfaceDescription*& _sp) {
  _sp = (CORBA::InterfaceDescription *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::InterfaceDescription;
    _0RL_buildDesc_cCORBA_mInterfaceDescription(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mInterfaceDescription, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mInterfaceDescription);
      return 1;
    } else {
      delete (CORBA::InterfaceDescription *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mInterfaceDescription)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_CORBA_mValueMember(void* _data) {
  CORBA::ValueMember* _0RL_t = (CORBA::ValueMember*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mValueMember(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ValueMember*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ValueMember*)_desc->opq_struct)->id);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ValueMember*)_desc->opq_struct)->defined_in);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ValueMember*)_desc->opq_struct)->version);
    return 1;
  case 4:
    _0RL_buildDesc_cTypeCode(_newdesc, ((CORBA::ValueMember*)_desc->opq_struct)->type);
    return 1;
  case 5:
    _0RL_buildDesc_cCORBA_mIDLType(_newdesc, ((CORBA::ValueMember*)_desc->opq_struct)->type_def);
    return 1;
  case 6:
    _0RL_buildDesc_cshort(_newdesc, ((CORBA::ValueMember*)_desc->opq_struct)->access);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mValueMember(tcStructDesc *_desc)
{
  return 7;
}

void _0RL_buildDesc_cCORBA_mValueMember(tcDescriptor &_desc, const CORBA::ValueMember& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mValueMember;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mValueMember;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::ValueMember& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mValueMember(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mValueMember, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::ValueMember* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mValueMember(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mValueMember, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ValueMember*& _sp) {
  return _a >>= (const CORBA::ValueMember*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::ValueMember*& _sp) {
  _sp = (CORBA::ValueMember *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::ValueMember;
    _0RL_buildDesc_cCORBA_mValueMember(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mValueMember, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mValueMember);
      return 1;
    } else {
      delete (CORBA::ValueMember *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mValueMember)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_cCORBA_mValueMember__
#define __0RL_tcParser_buildDesc_s0_cCORBA_mValueMember__
static void
_0RL_tcParser_setElementCount_s0_cCORBA_mValueMember(tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< CORBA::ValueMember> *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cCORBA_mValueMember(tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< CORBA::ValueMember> *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cCORBA_mValueMember(tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cCORBA_mValueMember(_newdesc, (*((_CORBA_Unbounded_Sequence< CORBA::ValueMember> *)_desc->opq_seq))[_index]);
  
  return 1;
}

static void
_0RL_buildDesc_s0_cCORBA_mValueMember(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< CORBA::ValueMember> & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cCORBA_mValueMember;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cCORBA_mValueMember;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cCORBA_mValueMember;
  }
#endif

void operator <<= (CORBA::Any& _a, const CORBA::ValueMemberSeq& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cCORBA_mValueMember(tcdesc, _s);
  _a.PR_packFrom(CORBA::_tc_ValueMemberSeq, &tcdesc);
}

void _0RL_seq_delete_CORBA_mValueMemberSeq(void* _data)
{
  delete (CORBA::ValueMemberSeq*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, CORBA::ValueMemberSeq*& _s_out)
{
  return _a >>= (const CORBA::ValueMemberSeq*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const CORBA::ValueMemberSeq*& _s_out)
{
  _s_out = 0;
  CORBA::ValueMemberSeq* stmp = (CORBA::ValueMemberSeq*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new CORBA::ValueMemberSeq;
    _0RL_buildDesc_s0_cCORBA_mValueMember(tcdesc, *stmp);
    if( _a.PR_unpackTo(CORBA::_tc_ValueMemberSeq, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_CORBA_mValueMemberSeq);
      _s_out = stmp;
      return 1;
    } else {
      delete (CORBA::ValueMemberSeq *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(CORBA::_tc_ValueMemberSeq) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mValueMemberDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::ValueMemberDef_ptr _p = CORBA::ValueMemberDef::_narrow(_ptr);
  CORBA::ValueMemberDef_ptr* pp = (CORBA::ValueMemberDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mValueMemberDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::ValueMemberDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mValueMemberDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ValueMemberDef, CORBA::ValueMemberDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mValueMemberDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mValueMemberDef;
}

void _0RL_delete_CORBA_mValueMemberDef(void* _data) {
  CORBA::release((CORBA::ValueMemberDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::ValueMemberDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ValueMemberDef, CORBA::ValueMemberDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mValueMemberDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_ValueMemberDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::ValueMemberDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::ValueMemberDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ValueMemberDef_ptr& _s) {
  CORBA::ValueMemberDef_ptr sp = (CORBA::ValueMemberDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::ValueMemberDef_var tmp;
    _0RL_buildDesc_cCORBA_mValueMemberDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_ValueMemberDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::ValueMemberDef_ptr)tmp,_0RL_delete_CORBA_mValueMemberDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::ValueMemberDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_ValueMemberDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::ValueMemberDef::_nil(); return 0;
    }
  }
}

void _0RL_delete_CORBA_mValueDef_mFullValueDescription(void* _data) {
  CORBA::ValueDef::FullValueDescription* _0RL_t = (CORBA::ValueDef::FullValueDescription*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mValueDef_mFullValueDescription(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->id);
    return 1;
  case 2:
    _0RL_buildDesc_cboolean(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->is_abstract);
    return 1;
  case 3:
    _0RL_buildDesc_cboolean(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->is_custom);
    return 1;
  case 4:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->defined_in);
    return 1;
  case 5:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->version);
    return 1;
  case 6:
    _0RL_buildDesc_s0_cCORBA_mOperationDescription(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->operations);
    return 1;
  case 7:
    _0RL_buildDesc_s0_cCORBA_mAttributeDescription(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->attributes);
    return 1;
  case 8:
    _0RL_buildDesc_s0_cCORBA_mValueMember(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->members);
    return 1;
  case 9:
    _0RL_buildDesc_s0_cCORBA_mInitializer(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->initializers);
    return 1;
  case 10:
    _0RL_buildDesc_s0_cstring(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->supported_interfaces);
    return 1;
  case 11:
    _0RL_buildDesc_s0_cstring(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->abstract_base_values);
    return 1;
  case 12:
    _0RL_buildDesc_cboolean(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->is_truncatable);
    return 1;
  case 13:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->base_value);
    return 1;
  case 14:
    _0RL_buildDesc_cTypeCode(_newdesc, ((CORBA::ValueDef::FullValueDescription*)_desc->opq_struct)->type);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mValueDef_mFullValueDescription(tcStructDesc *_desc)
{
  return 15;
}

void _0RL_buildDesc_cCORBA_mValueDef_mFullValueDescription(tcDescriptor &_desc, const CORBA::ValueDef::FullValueDescription& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mValueDef_mFullValueDescription;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mValueDef_mFullValueDescription;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::ValueDef::FullValueDescription& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mValueDef_mFullValueDescription(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mValueDef_mFullValueDescription, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::ValueDef::FullValueDescription* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mValueDef_mFullValueDescription(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mValueDef_mFullValueDescription, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ValueDef::FullValueDescription*& _sp) {
  return _a >>= (const CORBA::ValueDef::FullValueDescription*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::ValueDef::FullValueDescription*& _sp) {
  _sp = (CORBA::ValueDef::FullValueDescription *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::ValueDef::FullValueDescription;
    _0RL_buildDesc_cCORBA_mValueDef_mFullValueDescription(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mValueDef_mFullValueDescription, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mValueDef_mFullValueDescription);
      return 1;
    } else {
      delete (CORBA::ValueDef::FullValueDescription *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mValueDef_mFullValueDescription)) return 1;
    _sp = 0;
    return 0;
  }
}
static void
_0RL_tcParser_setObjectPtr_CORBA_mValueDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::ValueDef_ptr _p = CORBA::ValueDef::_narrow(_ptr);
  CORBA::ValueDef_ptr* pp = (CORBA::ValueDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mValueDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::ValueDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mValueDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ValueDef, CORBA::ValueDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mValueDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mValueDef;
}

void _0RL_delete_CORBA_mValueDef(void* _data) {
  CORBA::release((CORBA::ValueDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::ValueDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ValueDef, CORBA::ValueDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mValueDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_ValueDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::ValueDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::ValueDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ValueDef_ptr& _s) {
  CORBA::ValueDef_ptr sp = (CORBA::ValueDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::ValueDef_var tmp;
    _0RL_buildDesc_cCORBA_mValueDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_ValueDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::ValueDef_ptr)tmp,_0RL_delete_CORBA_mValueDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::ValueDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_ValueDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::ValueDef::_nil(); return 0;
    }
  }
}

void _0RL_delete_CORBA_mValueDescription(void* _data) {
  CORBA::ValueDescription* _0RL_t = (CORBA::ValueDescription*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_CORBA_mValueDescription(tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ValueDescription*)_desc->opq_struct)->name);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ValueDescription*)_desc->opq_struct)->id);
    return 1;
  case 2:
    _0RL_buildDesc_cboolean(_newdesc, ((CORBA::ValueDescription*)_desc->opq_struct)->is_abstract);
    return 1;
  case 3:
    _0RL_buildDesc_cboolean(_newdesc, ((CORBA::ValueDescription*)_desc->opq_struct)->is_custom);
    return 1;
  case 4:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ValueDescription*)_desc->opq_struct)->defined_in);
    return 1;
  case 5:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ValueDescription*)_desc->opq_struct)->version);
    return 1;
  case 6:
    _0RL_buildDesc_s0_cstring(_newdesc, ((CORBA::ValueDescription*)_desc->opq_struct)->supported_interfaces);
    return 1;
  case 7:
    _0RL_buildDesc_s0_cstring(_newdesc, ((CORBA::ValueDescription*)_desc->opq_struct)->abstract_base_values);
    return 1;
  case 8:
    _0RL_buildDesc_cboolean(_newdesc, ((CORBA::ValueDescription*)_desc->opq_struct)->is_truncatable);
    return 1;
  case 9:
    _0RL_buildDesc_cstring(_newdesc, ((CORBA::ValueDescription*)_desc->opq_struct)->base_value);
    return 1;
  
  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_CORBA_mValueDescription(tcStructDesc *_desc)
{
  return 10;
}

void _0RL_buildDesc_cCORBA_mValueDescription(tcDescriptor &_desc, const CORBA::ValueDescription& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_CORBA_mValueDescription;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_CORBA_mValueDescription;
  _desc.p_struct.opq_struct = (void *)&_data;
}

void operator<<=(CORBA::Any& _a, const CORBA::ValueDescription& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mValueDescription(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_CORBA_mValueDescription, &_0RL_tcdesc);
}

void operator<<=(CORBA::Any& _a, CORBA::ValueDescription* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cCORBA_mValueDescription(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_CORBA_mValueDescription, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ValueDescription*& _sp) {
  return _a >>= (const CORBA::ValueDescription*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const CORBA::ValueDescription*& _sp) {
  _sp = (CORBA::ValueDescription *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new CORBA::ValueDescription;
    _0RL_buildDesc_cCORBA_mValueDescription(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_CORBA_mValueDescription, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_CORBA_mValueDescription);
      return 1;
    } else {
      delete (CORBA::ValueDescription *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_CORBA_mValueDescription)) return 1;
    _sp = 0;
    return 0;
  }
}
static void
_0RL_tcParser_setObjectPtr_CORBA_mValueBoxDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::ValueBoxDef_ptr _p = CORBA::ValueBoxDef::_narrow(_ptr);
  CORBA::ValueBoxDef_ptr* pp = (CORBA::ValueBoxDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mValueBoxDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::ValueBoxDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mValueBoxDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ValueBoxDef, CORBA::ValueBoxDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mValueBoxDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mValueBoxDef;
}

void _0RL_delete_CORBA_mValueBoxDef(void* _data) {
  CORBA::release((CORBA::ValueBoxDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::ValueBoxDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_ValueBoxDef, CORBA::ValueBoxDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mValueBoxDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_ValueBoxDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::ValueBoxDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::ValueBoxDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::ValueBoxDef_ptr& _s) {
  CORBA::ValueBoxDef_ptr sp = (CORBA::ValueBoxDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::ValueBoxDef_var tmp;
    _0RL_buildDesc_cCORBA_mValueBoxDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_ValueBoxDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::ValueBoxDef_ptr)tmp,_0RL_delete_CORBA_mValueBoxDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::ValueBoxDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_ValueBoxDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::ValueBoxDef::_nil(); return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_CORBA_mAbstractInterfaceDef(tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  CORBA::AbstractInterfaceDef_ptr _p = CORBA::AbstractInterfaceDef::_narrow(_ptr);
  CORBA::AbstractInterfaceDef_ptr* pp = (CORBA::AbstractInterfaceDef_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_CORBA_mAbstractInterfaceDef(tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((CORBA::AbstractInterfaceDef_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_cCORBA_mAbstractInterfaceDef(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_AbstractInterfaceDef, CORBA::AbstractInterfaceDef_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_CORBA_mAbstractInterfaceDef;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_CORBA_mAbstractInterfaceDef;
}

void _0RL_delete_CORBA_mAbstractInterfaceDef(void* _data) {
  CORBA::release((CORBA::AbstractInterfaceDef_ptr) _data);
}

void operator<<=(CORBA::Any& _a, CORBA::AbstractInterfaceDef_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< CORBA::_objref_AbstractInterfaceDef, CORBA::AbstractInterfaceDef_Helper>  tmp(_s,0);
  _0RL_buildDesc_cCORBA_mAbstractInterfaceDef(tcd, tmp);
  _a.PR_packFrom(CORBA::_tc_AbstractInterfaceDef, &tcd);
}

void operator<<=(CORBA::Any& _a, CORBA::AbstractInterfaceDef_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = CORBA::AbstractInterfaceDef::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, CORBA::AbstractInterfaceDef_ptr& _s) {
  CORBA::AbstractInterfaceDef_ptr sp = (CORBA::AbstractInterfaceDef_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    CORBA::AbstractInterfaceDef_var tmp;
    _0RL_buildDesc_cCORBA_mAbstractInterfaceDef(tcd, tmp);
    if( _a.PR_unpackTo(CORBA::_tc_AbstractInterfaceDef, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(CORBA::AbstractInterfaceDef_ptr)tmp,_0RL_delete_CORBA_mAbstractInterfaceDef);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = CORBA::AbstractInterfaceDef::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(CORBA::_tc_AbstractInterfaceDef)) {
    _s = sp; return 1;
    }
    else {
    _s = CORBA::AbstractInterfaceDef::_nil(); return 0;
    }
  }
}

