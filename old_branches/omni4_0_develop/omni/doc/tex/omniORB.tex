\documentclass[11pt,twoside,a4paper]{book}
\usepackage[T1]{fontenc}
\usepackage{palatino}

% To make the PostScript version:
%
%  $ latex omniORB
%  $ bibtex omniORB
%  $ latex omniORB
%  $ latex omniORB
%  $ latex omniORB
%  $ dvips omniORB
%
% To make the PDF version (having already made the PS version):
%
%  $ pdflatex omniORB
%  $ pdflatex omniORB
%
% To make the HTML version, you need HeVeA 1.05.
%
%  $ hevea omniORB
%  $ hacha omniORB.html
%
% HeVeA and HaChA come from http://pauillac.inria.fr/~maranget/hevea/


\bibliographystyle{alpha}

% Semantic mark-up:
\newcommand{\type}[1]{\texttt{#1}}
\newcommand{\intf}[1]{\texttt{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\op}[1]{\texttt{#1()}}
\newcommand{\cmdline}[1]{\texttt{#1}}
\newcommand{\term}[1]{\textit{#1}}

\hyphenation{omni-ORB}

% Environment to make important statements stand out:
\newenvironment{statement}%
 {\noindent\begin{minipage}{\textwidth}%
  \vspace{.5\baselineskip}%
  \noindent\rule{\textwidth}{2pt}%
  \vspace{.25\baselineskip}%
  \begin{list}{}{\setlength{\listparindent}{0em}%
                 \setlength{\itemindent}{0em}%
                 \setlength{\leftmargin}{1.5em}%
                 \setlength{\rightmargin}{\leftmargin}%
                 \setlength{\topsep}{0pt}%
                 \setlength{\partopsep}{0pt}}
  \item\relax}
 {\end{list}%
  \vspace{-.25\baselineskip}%
  \noindent\rule{\textwidth}{2pt}%
  \vspace{.5\baselineskip}%
  \end{minipage}}

% Itemize with no itemsep:
\newenvironment{nsitemize}%
 {\begin{itemize}\setlength{\itemsep}{0pt}}%
 {\end{itemize}}

% URL-like things:
\usepackage[T1]{url}
\newcommand{\weburl}{\url}
\newcommand{\email}{\begingroup \urlstyle{rm}\Url}
\newcommand{\file}{\begingroup \urlstyle{tt}\Url}
\newcommand{\envvar}{\begingroup \urlstyle{tt}\Url}
\newcommand{\makevar}{\begingroup \urlstyle{tt}\Url}
\newcommand{\corbauri}{\begingroup \urlstyle{tt}\Url}

% Mark-up for configuration options
\makeatletter
\newcommand{\confopt}[2]
  {\vspace{\baselineskip}\par\noindent\code{#1} ~~ \textit{default} =
   \code{#2}\\[-1ex]\@afterheading}
\makeatother

% HeVeA barfs at the following:

%BEGIN LATEX

\addtolength{\oddsidemargin}{-0.2in}
\addtolength{\evensidemargin}{-0.6in}
\addtolength{\textwidth}{0.5in}

\newcommand{\dsc}{\discretionary{}{}{}}

\pagestyle{headings}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\usepackage{listings}
\lstdefinelanguage{idl}%
  {keywords={any,attribute,boolean,case,char,const,context,default,double,enum,exception,FALSE,float,in,inout,interface,long,module,Object,octet,oneway,out,raises,readonly,sequence,short,string,struct,switch,TRUE,typedef,unsigned,union,void},%
  sensitive,%
  singlecomment={/*}{*/},%
  commentline=//,%
  stringizer=[b]",%
  directives={define,elif,else,endif,error,if,ifdef,ifndef,line,include,pragma,undef,warning}%
  }[keywords,comments,strings,directives]

\lstset{basicstyle=\ttfamily\small,
        keywordstyle=,
        commentstyle=\itshape,
        labelstyle=\tiny,
        stringspaces=false,
        abovecaptionskip=0pt,
        belowcaptionskip=0pt,
        indent=\parindent,
        fontadjust}

\lstnewenvironment{idllisting}{\lstset{language=idl}}{}
\lstnewenvironment{cxxlisting}{\lstset{language=C++}}{}
\lstnewenvironment{makelisting}{\lstset{language=[gnu]make}}{}

%END LATEX

% These things make up for HeVeA's lack of understanding:

%HEVEA\newcommand{\dsc}{}
%HEVEA\newcommand{\vfill}{}
%HEVEA\newcommand{\mainmatter}{}
%HEVEA\newcommand{\backmatter}{}
%HEVEA\newcommand{\lstset}[1]{}
%HEVEA\newcommand{\textbackslash}{$\backslash$}
%HEVEA\usepackage{verbatim}
%HEVEA\newenvironment{idllisting}{\verbatim}{\endverbatim}
%HEVEA\newenvironment{cxxlisting}{\verbatim}{\endverbatim}
%HEVEA\newenvironment{makelisting}{\verbatim}{\endverbatim}


% Hyperref things for pdf and html:
\usepackage{hyperref}

\newif\ifpdf
\ifx\pdfoutput\undefined
  \pdffalse
\else
  \pdfoutput=1
  \pdftrue
\fi
\ifpdf
  \hypersetup{colorlinks,citecolor=red,urlcolor=blue}
\fi


% Finally, the set-up is almost over, and we can start the document:

\begin{document}

\pagenumbering{roman}
\pagestyle{empty}


\begin{center}

\vfill

{ \Huge
The omniORB version 4.0\\[4mm]
User's Guide
}

\vfill

{ \Large
Duncan Grisby\\
{\normalsize (\textit{email: \href{mailto:dgrisby@apasphere.com}%
                                  {\email{dgrisby@apasphere.com}}})}%
                                  \\[2ex]
%
Apasphere Ltd.\\[4ex]
%
Sai-Lai Lo\\[2ex]
%
David Riddoch\\[2ex]
%
AT\&T Laboratories Cambridge\\
}


\vfill
\vfill
August 2002
\vfill

\end{center}

\clearpage

{\Large \bf Changes and Additions, June 2002}
\begin{itemize}
\item Updated to omniORB 4.0.
\end{itemize}


\cleardoublepage

%HEVEA{\Large \bf Contents}
%BEGIN LATEX
\tableofcontents
%END LATEX

\cleardoublepage

\pagestyle{headings}

\pagenumbering{arabic}

\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

omniORB is an Object Request Broker (ORB) that implements the 2.6
specification of the Common Object Request Broker Architecture
(CORBA)~\cite{corba26-spec}\footnote{Most of the 2.6 features have
been implemented. The features still missing in this release are
listed in section~\ref{sec:missing}. Where possible, backward
compatibility has been maintained up to specification 2.0.}. It has
passed the Open Group CORBA compliant testsuite (for CORBA 2.1) and
was one of the three ORBs to be granted the CORBA brand in June
1999\footnote{More information can be found at
\weburl{http://www.opengroup.org/press/7jun99_b.htm}}.

This user guide tells you how to use omniORB to develop CORBA
applications. It assumes a basic understanding of CORBA.

In this chapter, we give an overview of the main features of omniORB
and what you need to do to setup your environment to run omniORB.

\section{Features}

\subsection{Multithreading}

omniORB is fully multithreaded. To achieve low call overhead,
unnecessary call-multiplexing is eliminated. With the default
policies, there is at most one call in-flight in each communication
channel between two address spaces at any one time. To do this without
limiting the level of concurrency, new channels connecting the two
address spaces are created on demand and cached when there are
concurrent calls in progress. Each channel is served by a dedicated
thread. This arrangement provides maximal concurrency and eliminates
any thread switching in either of the address spaces to process a
call. Furthermore, to maximise the throughput in processing large call
arguments, large data elements are sent as soon as they are processed
while the other arguments are being marshalled. With GIOP 1.2, large
messages are fragmented, so the marshaller can start transmission
before it knows how large the entire message will be.

New in version 4.0, omniORB also supports a flexible thread pooling
policy, and supports sending multiple interleaved calls on a single
connection. This policy leads to a small amount of additional call
overhead, compared to the default thread per connection model, but
allows omniORB to scale to extremely large numbers of concurrent
clients.

\subsection{Portability}

omniORB has always been designed to be portable. It runs on many
flavours of Unix, Windows, several embedded operating systems, and
relatively obscure systems such as OpenVMS, Fujitsu-Siemens BS2000.
It is designed to be easy to port to new platforms. The IDL to C++
mapping for all target platforms is the same.

omniORB uses real C++ exceptions and nested classes. It keeps to the
CORBA specification's standard mapping as much as possible and does
not use the alternative mappings for C++ dialects. The only exception
is the mapping of IDL modules, which can use either namespaces or
nested classes.

omniORB relies on native thread libraries to provide multithreading
capability. A small class library (omnithread~\cite{tjr96a}) is used
to encapsulate the APIs of the native thread libraries. In application
code, it is recommended but not mandatory to use this class library
for thread management. It should be easy to port omnithread to any
platform that either supports the POSIX thread standard or has a
thread package that supports similar capabilities.

\subsection{Missing features}
\label{sec:missing}

omniORB is not (yet) a complete implementation of the CORBA 2.6 core.
The following is a list of the missing features.

\begin{itemize}

\item omniORB does not have its own Interface Repository. However, it
can act as a client to an IfR. The omniifr project
(\weburl{http://omniifr.sourceforge.net/}) aims to create an IfR for
omniORB.

\item Objects by value (IDL valuetype) is not supported in this
release.

\item omniORB supports interceptors, but not the standard Portable
Interceptor API.

\end{itemize}

These features may be implemented in the short to medium term. It is
best to check out the latest status on the omniORB home page
(\weburl{http://omniorb.sourceforge.net/}).


\section{Setting Up Your Environment}
\label{sec:setup}

To get omniORB running, you first need to install omniORB according to
the instructions in the installation notes for your platform. Most
Unix platforms can use the Autoconf \file{configure} script to
automate the configuration process.

Once omniORB is installed in a suitable location, you must configure
it according to your required set-up. The configuration can be set
with a configuration file, environment variables, command-line
arguments or, on Windows, the Windows registry.

\begin{itemize}

\item On Unix platforms, the omniORB runtime looks for the environment
variable \envvar{OMNIORB_CONFIG}. If this variable is defined, it
contains the pathname of the omniORB configuration file. If the
variable is not set, omniORB will use the compiled-in pathname to
locate the file (by default \file{/etc/omniORB.cfg}).

\item On Win32 platforms (Windows NT, 2000, 95, 98), omniORB first
checks the environment variable \envvar{OMNIORB_CONFIG} to obtain the
pathname of the configuration file. If this is not set, it then
attempts to obtain configuration data in the system registry. It
searches for the data under the key
%BEGIN LATEX
\file{HKEY_LOCAL_MACHINE\SOFTWARE\omniORB}.
%END LATEX
%HEVEA \verb|HKEY_LOCAL_MACHINE\SOFTWARE\omniORB|.

\end{itemize}

omniORB has a large number of parameters than can be configured. See
chapter~\ref{chap:config} for full details. The files
\file{sample.cfg} and \file{sample.reg} contain an example
configuration file and set of registry entries respectively.

To get all the omniORB examples running, the main thing you need to
configure is the Naming service, omniNames. To do that, the
configuration file or registry should contain an entry of the form

\begin{verbatim}
  InitRef = NameService=corbaname::my.host.name
\end{verbatim}

See section~\ref{sec:corbaname} for full details of corbaname URIs.


\section{Platform specific variables}

To compile omniORB programs correctly, several C++ preprocessor defines
\textbf{must} be specified to identify the target platform. On Unix
platforms where omniORB was configured with Autoconf, the
\file{omniconfig.h} file sets these for you. On other platforms, and
Unix platforms when Autoconf is not used, you must specify the
following defines:

\begin{flushleft}
\begin{tabular}{|l|l|}
\hline
Platform            & CPP defines \\
\hline
Windows NT 4.0,2000,XP & \verb|__x86__     __NT__       __OSVERSION__=4  __WIN32__| \\

Windows NT 3.5      & \verb|__x86__     __NT__       __OSVERSION__=3  __WIN32__| \\

Windows 95          & \verb|__x86__     __WIN32__| \\

Sun Solaris 2.5     & \verb|__sparc__   __sunos__    __OSVERSION__=5| \\

HPUX 10.x           & \verb|__hppa__    __hpux__     __OSVERSION__=10| \\

HPUX 11.x           & \verb|__hppa__    __hpux__     __OSVERSION__=11| \\

IBM AIX 4.x         & \verb|__aix__     __powerpc__  __OSVERSION__=4| \\

Digital Unix 3.2    & \verb|__alpha__   __osf1__     __OSVERSION__=3| \\

Linux 2.x (x86)     & \verb|__x86__     __linux__    __OSVERSION__=2| \\

Linux 2.x (powerpc) & \verb|__powerpc__ __linux__    __OSVERSION__=2| \\

OpenVMS 6.x (alpha) & \verb|__alpha__   __vms        __OSVERSION__=6 | \\

OpenVMS 6.x (vax)   & \verb|__vax__     __vms        __OSVERSION__=6 | \\

SGI Irix 6.x        & \verb|__mips__    __irix__     __OSVERSION__=6 | \\

Reliant Unix 5.43   & \verb|__mips__    __SINIX__    __OSVERSION__=5 | \\

ATMos 4.0           & \verb|__arm__     __atmos__    __OSVERSION__=4| \\

NextStep 3.x        & \verb|__m68k__    __nextstep__ __OSVERSION__=3| \\

Unixware 7          & \verb|__x86__     __uw7__      __OSVERSION__=5| \\
\hline
\end{tabular}
\end{flushleft}

The preprocessor defines for new platform ports not listed above can
be found in the corresponding platform configuration files. For
instance, the platform configuration file for Sun Solaris 2.6 is in
\file{mk/platforms/sun4_sosV_5.6.mk}. The preprocessor defines to
identify a platform are in the make variable
\makevar{IMPORT_CPPFLAGS}.

In a single source multi-target environment, you can put the
preprocessor defines as the command-line arguments for the compiler.
If you are building for a single platform, you can edit
include/omniconfig.h to add the definitions.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{The Basics}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:basic}

In this chapter, we go through three examples to illustrate the
practical steps to use omniORB. By going through the source code of
each example, the essential concepts and APIs are introduced. If you
have no previous experience with using CORBA, you should study this
chapter in detail. There are pointers to other essential documents you
should be familiar with.

If you have experience with using other ORBs, you should still go
through this chapter because it provides important information about
the features and APIs that are necessarily omniORB specific. With the
Portable Object Adapter, there are very few omniORB specific details.


\section{The Echo Object Example}

Our example is an object which has only one method. The method simply
echos the argument string. We have to:

\begin{enumerate}

\item define the object interface in IDL;
\item use the IDL compiler to generate the stub code\footnote{The stub
code is the C++ code that provides the object mapping as defined in
the CORBA specification.};
\item provide the \term{servant} object implementation;
\item write the client code.

\end{enumerate}

These examples are in the \file{src/examples/echo} directory of the
omniORB distribution; there are several other examples one directory
above that in \file{src/examples}.


\section{Specifying the Echo interface in IDL}

We define an object interface, called \intf{Echo}, as follows:

\begin{idllisting}
interface Echo {
    string echoString(in string mesg);
};
\end{idllisting}


If you are new to IDL, you can learn about its syntax in Chapter 3 of
the CORBA 2.6 specification~\cite{corba26-spec}. For the moment, you
only need to know that the interface consists of a single operation,
\op{echoString}, which takes a string as an input argument and returns
a copy of the same string.

The interface is written in a file, called \file{echo.idl}. It is part
of the CORBA standard that all IDL files should have the extension
`\file{.idl}', although omniORB does not enforce this.

For simplicity, the interface is defined in the global IDL namespace.
You should avoid this practice for the sake of object reusability.  If
every CORBA developer defines their interfaces in the global IDL
namespace, there is a danger of name clashes between two independently
defined interfaces. Therefore, it is better to qualify your interfaces
by defining them inside \code{module} names. Of course, this does not
eliminate the chance of a name clash unless some form of naming
convention is agreed globally. Nevertheless, a well-chosen module name
can help a lot.

\section{Generating the C++ stubs}

From the IDL file, we use the IDL compiler to produce the C++ mapping
of the interface. The IDL compiler for omniORB is called omniidl.
Given the IDL file, omniidl produces two stub files: a C++ header file
and a C++ source file. For example, from the file \file{echo.idl}, the
following files are produced:

\begin{nsitemize}
\item\file{echo.hh}
\item\file{echoSK.cc}
\end{nsitemize}

\noindent omniidl must be invoked with the \cmdline{-bcxx} argument to
tell it to generate C++ stubs. The following command line generates
the stubs for \file{echo.idl}:

\begin{makelisting}
omniidl -bcxx echo.idl
\end{makelisting}

\noindent If you are using our make environment (ODE), you don't need
to invoke omniidl explicitly. In the example file \file{dir.mk}, we
have the following line:

\begin{makelisting}
CORBA_INTERFACES = echo
\end{makelisting}

\noindent That is all we need to instruct ODE to generate the stubs.
Remember, you won't find the stubs in your working directory because
all stubs are written into the \file{stub} directory at the top level
of your build tree.

The full arguments to omniidl are detailed in
chapter~\ref{chap:omniidl}.


\section{Object References and Servants}

We contact a CORBA object through an \term{object reference}. The
actual implementation of a CORBA object is termed a \term{servant}.

Object references and servants are quite separate entities, and it is
important not to confuse the two. Client code deals purely with object
references, so there can be no confusion; object implementation code
must deal with both object references and servants. omniORB 4 uses
distinct C++ types for object references and servants, so the C++
compiler will complain if you use a servant when an object reference
is expected, or vice-versa.

\begin{statement}
\centerline{\textbf{Warning}}

omniORB 2.x \emph{did not} use distinct types for object references
and servants, and often accepted a pointer to a servant when the CORBA
specification says it should only accept an object reference. If you
have code which relies on this, it will not compile with omniORB 3.x
or 4.x, even under the BOA compatibility mode.
\end{statement}



\section{A Quick Tour of the C++ stubs}

The C++ stubs conform to the mapping defined in the CORBA
specification~\cite{cxxmapping}. It is important to understand the
mapping before you start writing any serious CORBA applications.
Before going any further, it is worth knowing what the mapping looks
like.

For the example interface \intf{Echo}, the C++ mapping for its object
reference is \type{Echo\_ptr}. The type is defined in \file{echo.hh}.
The relevant section of the code is reproduced below. The stub code
produced by other ORBs will be functionally equivalent to omniORB's,
but will almost certainly look very different.

\begin{cxxlisting}
class Echo;
class _objref_Echo;
class _impl_Echo;
typedef _objref_Echo* Echo_ptr;

class Echo {
public:
  // Declarations for this interface type.
  typedef Echo_ptr _ptr_type;
  typedef Echo_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  // ... methods generated for internal use
};

class _objref_Echo :
  public virtual CORBA::Object, public virtual omniObjRef {
public:
  char * echoString(const char* mesg);

  // ... methods generated for internal use
};
\end{cxxlisting}

In a compliant application, the operations defined in an object
interface should \textbf{only} be invoked via an object reference.
This is done by using arrow (`\code{->}') on an object reference.
For example, the call to the operation \op{echoString} would be
written as \code{obj->echoString(mesg)}.

It should be noted that the concrete type of an object reference is
opaque, i.e.\ you must not make any assumption about how an object
reference is implemented. In our example, even though \type{Echo\_ptr}
is implemented as a pointer to the class \type{\_objref\_Echo}, it
should not be used as a C++ pointer, i.e.\ conversion to \type{void*},
arithmetic operations, and relational operations including testing for
equality using \code{operator==}, must not be performed on the type.

In addition to class \type{\_objref\_Echo}, the mapping defines three
static member functions in the class \type{Echo}: \op{\_nil},
\op{\_duplicate}, and \op{\_narrow}.

The \op{\_nil} function returns a nil object reference of the Echo
interface. The following call is guaranteed to return TRUE:

\begin{cxxlisting}
CORBA::Boolean true_result = CORBA::is_nil(Echo::_nil());
\end{cxxlisting}

Remember, \op{CORBA::is\_nil} is the only compliant way to check if an
object reference is nil. You should not use the equality
\code{operator==}. Many C++ ORBs use the null pointer to represent a
nil object reference; \emph{omniORB does not}.

The \op{\_duplicate} function returns a new object reference of the
\intf{Echo} interface. The new object reference can be used
interchangeably with the old object reference to perform an operation
on the same object. Duplications are required to satisfy the C++
mapping's reference counting memory management.

All CORBA objects inherit from the generic object
\type{CORBA::Object}.  \type{CORBA::\dsc{}Object\_ptr} is the object
reference type for \type{CORBA::Object}.  Any \type{\_ptr} object
reference is therefore conceptually inherited from
\type{CORBA::Object\_ptr}. In other words, an object reference such as
\type{Echo\_ptr} can be used in places where a
\type{CORBA::Object\_ptr} is expected.

The \op{\_narrow} function takes an argument of type
\type{CORBA::Object\_ptr} and returns a new object reference of the
\intf{Echo} interface.  If the actual (runtime) type of the argument
object reference can be narrowed to \type{Echo\_ptr}, \op{\_narrow}
will return a valid object reference. Otherwise it will return a nil
object reference. Note that \op{\_narrow} performs an implicit
duplication of the object reference, so the result must be released.
Note also that \op{\_narrow} may involve a remote call to check the
type of the object, so it may throw CORBA system exceptions such as
\code{COMM\_FAILURE} or \code{OBJECT\_NOT\_EXIST}.

To indicate that an object reference will no longer be accessed, you
must call the \op{CORBA::release} operation. Its signature is as
follows:

\begin{cxxlisting}
namespaceCORBA {
  void release(CORBA::Object_ptr obj);
  ... // other methods
};
\end{cxxlisting}

Once you have called \op{CORBA::release} on an object reference, you
must no longer use that reference. This is because the associated
resources may have been deallocated. Notice that we are referring to
the resources associated with the object reference and \textbf{not the
servant object}. Servant objects are not affected by the lifetimes of
object references. In particular, servants are not deleted when all
references to them have been released---CORBA does not perform
distributed garbage collection.

As described above, the equality \code{operator==} should not be used
on object references. To test if two object references are equivalent,
the member function \op{\_is\_equivalent} of the generic object
\type{CORBA::Object} can be used. Here is an example of its usage:

\begin{cxxlisting}
Echo_ptr A;
...            // initialise A to a valid object reference 
Echo_ptr B = A;
CORBA::Boolean true_result = A->_is_equivalent(B); 
// Note: the above call is guaranteed to be TRUE
\end{cxxlisting}

You have now been introduced to most of the operations that can be
invoked via \type{Echo\_ptr}. The generic object \type{CORBA::Object}
provides a few more operations and all of them can be invoked via
\type{Echo\_ptr}. These operations deal mainly with CORBA's dynamic
interfaces. You do not have to understand them in order to use the C++
mapping provided via the stubs.

Since object references must be released explicitly, their usage is
prone to error and can lead to memory leakage. The mapping defines the
\term{object reference variable} type to make life easier. In our
example, the variable type \type{Echo\_var} is defined\footnote{In
omniORB, all object reference variable types are instantiated from the
template type \type{\_CORBA\_ObjRef\_Var}.}.

The \type{Echo\_var} is more convenient to use because it will
automatically release its object reference when it is deallocated or
when assigned a new object reference. For many operations, mixing data
of type \type{Echo\_var} and \type{Echo\_ptr} is possible without any
explicit operations or castings\footnote{However, the implementation
of the type conversion operator between \type{Echo\_var} and
\type{Echo\_ptr} varies slightly among different C++ compilers; you
may need to do an explicit cast if the compiler complains about the
conversion being ambiguous.}. For instance, the operation
\op{echoString} can be called using the arrow (`\code{->}') on a
\type{Echo\_var}, as one can do with a \type{Echo\_ptr}.

The usage of \type{Echo\_var} is illustrated below:


\begin{cxxlisting}
Echo_var a;
Echo_ptr p = ... // somehow obtain an object reference

a = p;           // a assumes ownership of p, must not use p any more

Echo_var b = a;  // implicit _duplicate

p = ...          // somehow obtain another object reference

a = Echo::_duplicate(p);     // release old object reference
                             // a now holds a copy of p.
\end{cxxlisting}



\subsection{Servant Object Implementation}
\label{stubobjimpl}

Before the Portable Object Adapter (POA) specification, many of the
details of how servant objects should be implemented and registered
with the system were unspecified, so server-side code was not portable
between ORBs. The POA specification rectifies that. omniORB 4 still
supports the old omniORB 2.x BOA mapping, but you should always use
the POA mapping for new code. BOA code and POA code can coexist within
a single program. See section~\ref{sec:BOAcompat} for details of the
BOA compatibility, and problems you may encounter.

For each object interface, a \term{skeleton} class is generated.  In
our example, the POA specification says that the skeleton class for
interface \intf{Echo} is named \type{POA\_Echo}. A servant
implementation can be written by creating an implementation class that
derives from the skeleton class.

The skeleton class \type{POA\_Echo} is defined in \file{echo.hh}. The
relevant section of the code is reproduced below.

\begin{cxxlisting}
class POA_Echo :
  public virtual PortableServer::ServantBase
{
public:
  Echo_ptr _this();

  virtual char * echoString(const char*  mesg) = 0;
  // ...
};
\end{cxxlisting}

The code fragment shows the only member functions that can be used in
the object implementation code. Other member functions are generated
for internal use only. As with the code generated for object
references, other POA-based ORBs will generate code which looks
different, but is functionally equivalent to this.


\begin{description}

\item[\op{echoString}]\mbox{}\\
%
It is through this abstract function that an implementation class
provides the implementation of the \op{echoString} operation. Notice
that its signature is the same as the \op{echoString} function that
can be invoked via the \type{Echo\_ptr} object reference.

\item[\op{\_this}]\mbox{}\\
%
This function returns an object reference for the target object,
provided the POA policies permit it. The returned value must be
deallocated via \op{CORBA::\dsc{}release}.  See section~\ref{objeg1}
for an example of how this function is used.

\end{description}

\section{Writing the servant implementation}
\label{objimpl}

You define an implementation class to provide the servant
implementation. There is little constraint on how you design your
implementation class except that it has to inherit from the stubs'
skeleton class and to implement all the abstract functions defined in
the skeleton class. Each of these abstract functions corresponds to an
operation of the interface. They are the hooks for the ORB to perform
upcalls to your implementation.

Here is a simple implementation of the Echo object.

\begin{cxxlisting}
class Echo_i : public POA_Echo,
	       public PortableServer::RefCountServantBase
{
public:
  inline Echo_i() {}
  virtual ~Echo_i() {}
  virtual char* echoString(const char* mesg);
};

char* Echo_i::echoString(const char* mesg)
{
  return CORBA::string_dup(mesg);
}
\end{cxxlisting}

There are four points to note here:

\begin{description}

\item[Storage Responsibilities]\mbox{}\\
%
A string, which is used both as an in argument and the return value of
\op{echoString}, is a variable size data type. Other examples of
variable size data types include sequences, type `any', etc. For these
data types, you must be clear about whose responsibility it is to
allocate and release the associated storage. As a rule of thumb, the
client (or the caller to the implementation functions) owns the
storage of all IN arguments, the object implementation (or the callee)
must copy the data if it wants to retain a copy. For OUT arguments and
return values, the object implementation allocates the storage and
passes the ownership to the client. The client must release the
storage when the variables will no longer be used.  For details,
please refer to the C++ mapping specification.

\item[Multi-threading]\mbox{}\\
%
As omniORB is fully multithreaded, multiple threads may perform the
same upcall to your implementation concurrently. It is up to your
implementation to synchronise the threads' accesses to shared data.
In our simple example, we have no shared data to protect so no thread
synchronisation is necessary.

Alternatively, you can create a POA which has the
\code{SINGLE\_THREAD\_MODEL} Thread Policy. This guarantees that all
calls to that POA are processed sequentially.

\item[Reference Counting]\mbox{}\\
%
As well as inheriting from the Echo skeleton class, the servant class
is also derived from \type{PortableServer::RefCountServantBase} which,
as the name suggests, is a mixin class which provides reference
counting for the servant object. This means that an \type{Echo\_i}
instance will be deleted when no more references to it are held by
application code or the POA itself. Note that this is totally separate
from the reference counting which is associated with object
references---a servant object is \emph{never} deleted due to a CORBA
object reference being released.

\item[Instantiation]\mbox{}\\
%
Servants that derive from \type{PortableServer::RefCountServantBase}
must not be instantiated as automatic variables (i.e.\ on the stack).
Instead, you should always instantiate them using the \code{new}
operator, i.e.\ their storage is allocated on the heap. Otherwise, the
POA may attempt to delete an object on the stack.

\end{description}

\section{Writing the client}

Here is an example of how an \type{Echo\_ptr} object reference is
used.

\lstset{labelstep=1,gobble=4}
\begin{cxxlisting}
 1  void
 2  hello(CORBA::Object_ptr obj)
 3  {
 4    Echo_var e = Echo::_narrow(obj);
 5
 6    if (CORBA::is_nil(e)) {
 7      cerr << "cannot invoke on a nil object reference."
 8           << endl;
 9      return;
10    }
11
12    CORBA::String_var src = (const char*) "Hello!";
13    CORBA::String_var dest;
14
15    dest = e->echoString(src);
16
17    cerr << "I said,\"" << src << "\"."
18         << " The Object said,\"" << dest <<"\"" << endl;
19  }
\end{cxxlisting}
\lstset{labelstep=0,gobble=0}

Briefly, the \op{hello} function accepts a generic object reference.
The object reference (\code{obj}) is narrowed to \type{Echo\_ptr}. If
the object reference returned by \op{Echo::\_narrow} is not nil, the
operation \op{echoString} is invoked. Finally, both the argument to
and the return value of \op{echoString} are printed to \code{cerr}.

The example also illustrates how \type{T\_var} types are used. As was
explained in the previous section, \type{T\_var} types take care of
storage allocation and release automatically when variables are
reassigned or when the variables go out of scope.

In line 4, the variable \code{e} takes over the storage responsibility
of the object reference returned by \op{Echo::\_narrow}. The object
reference is released by the destructor of \code{e}. It is called
automatically when the function returns. Lines 6 and 15 show how a
\type{Echo\_var} variable is used. As explained earlier, the
\type{Echo\_var} type can be used interchangeably with the
\type{Echo\_ptr} type.

The argument and the return value of \op{echoString} are stored in
\type{CORBA::\dsc{}String\_var} variables \code{src} and \code{dest}
respectively. The strings managed by the variables are deallocated by
the destructor of \type{CORBA::String\_var}. It is called
automatically when the variable goes out of scope (as the function
returns). Line 15 shows how \type{CORBA::String\_var} variables are
used. They can be used in place of a string (for which the mapping is
\type{char*})\footnote{A conversion operator of
\type{CORBA::String\_var} converts a \type{CORBA::\dsc{}String\_var}
to a \type{char*}.}. As used in line 12, assigning a constant string
(\type{const char*}) to a \type{CORBA::String\_var} causes the string
to be copied. On the other hand, assigning a \type{char*} to a
\type{CORBA::String\_var}, as used in line 15, causes the latter to
assume the ownership of the string\footnote{Please refer to the C++
mapping specification for details of the String\_var mapping.}.

Under the C++ mapping, \type{T\_var} types are provided for all the
non-basic data types.  It is obvious that one should use automatic
variables whenever possible both to avoid memory leaks and to maximise
performance. However, when one has to allocate data items on the heap,
it is a good practice to use the \type{T\_var} types to manage the
heap storage.

\section{Example 1 --- Colocated Client and Implementation}
\label{objeg1}

Having introduced the client and the object implementation, we can now
describe how to link up the two via the ORB and POA. In this section,
we describe an example in which both the client and the object
implementation are in the same address space. In the next two
sections, we shall describe the case where the two are in different
address spaces.

The code for this example is reproduced below:


\lstset{labelstep=1,gobble=4}
\begin{cxxlisting}
 1  int
 2  main(int argc, char **argv)
 3  {
 4    CORBA::ORB_ptr orb = CORBA::ORB_init(argc,argv,"omniORB4");
 5
 6    CORBA::Object_var       obj = orb->resolve_initial_references("RootPOA");
 7    PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);
 8
 9    Echo_i *myecho = new Echo_i();
10    PortableServer::ObjectId_var myechoid = poa->activate_object(myecho);
11
12    Echo_var myechoref = myecho->_this();
13    myecho->_remove_ref();
14
15    PortableServer::POAManager_var pman = poa->the_POAManager();
16    pman->activate();
17
18    hello(myechoref);
19
20    orb->destroy();
21    return 0;
22  }
\end{cxxlisting}
\lstset{labelstep=0,gobble=0}

The example illustrates several important interactions among the ORB,
the POA, the servant, and the client. Here are the details:

\subsection{ORB initialisation}

\begin{description}

\item[Line 4]\mbox{}\\
%
The ORB is initialised by calling the \op{CORBA::ORB\_init}
function. The function uses the optional 3rd argument to determine
which ORB should be returned. Unless you are using omniORB specific
features, it is usually best to leave it out, and get the default
ORB. To explicitly ask for omniORB 4.0, this argument must be
`omniORB4'\footnote{For backwards compatibility, the ORB identifiers
`omniORB2' and `omniORB3' are also accepted.}.

\op{CORBA::ORB\_init} takes the list of command line arguments and
processes any that start `\code{-ORB}'. It removes these arguments
from the list, so application code does not have to deal with them.

If any error occurs during ORB initialisation, such as invalid ORB
arguments, or an invalid configuration file, the
\code{CORBA::INITIALIZE} system exception is raised.

\end{description}


\subsection{Obtaining the Root POA}

\begin{description}

\item[Lines 6--7]\mbox{}\\
%
To activate our servant object and make it available to clients, we
must register it with a POA. In this example, we use the \term{Root
POA}, rather than creating any child POAs. The Root POA is found with
\op{orb->resolve\_initial\_\dsc{}references}, which returns a plain
\type{CORBA::Object}. In line 7, we narrow the reference to the right
type for a POA.

A POA's behaviour is governed by its \term{policies}. The Root POA has
suitable policies for many simple servers, and closely matches the
`policies' used by omniORB 2's BOA. See Chapter 11 of the CORBA 2.6
specification\cite{corba26-spec} for details of all the POA policies
which are available.

\end{description}


\subsection{Object initialisation}

\begin{description}

\item[Line 9]\mbox{}\\
%
An instance of the Echo servant is initialised using the \code{new}
operator.

\item[Line 10]\mbox{}\\
%
The servant object is activated in the Root POA using
\op{poa->activate\_\dsc{}object}, which returns an object identifier
(of type \type{PortableServer::\dsc{}ObjectId*}). The object id must
be passed back to various POA operations. The caller is responsible
for freeing the object id, so it is assigned to a \type{\_var} type.

\item[Line 12]\mbox{}\\
%
The object reference is obtained from the servant object by calling
\op{\_this}. Like all object references, the return value of
\op{\_this} must be released by \op{CORBA::release} when it is no
longer needed. In this case, we assign it to a \type{\_var} type, so
the release is implicit at the end of the function.

One of the important characteristics of an object reference is that it
is completely location transparent. A client can invoke on the object
using its object reference without any need to know whether the
servant object is colocated in the same address space or is in a
different address space.

In the case of colocated client and servant, omniORB is able to
short-circuit the client calls so they do not involve IIOP. The calls
still go through the POA, however, so the various POA policies affect
local calls in the same way as remote ones. This optimisation is
applicable not only to object references returned by \op{\_this}, but
to any object references that are passed around within the same
address space or received from other address spaces via remote calls.

\item[Line 13]\mbox{}\\
%
The server code releases the reference it holds to the servant
object. The only reference to that object is now held by the POA (it
gained the reference on the call to \op{activate\_object}), so when
the object is deactivated (or the POA is destroyed), the servant
object will be deleted automatically. After this point, the code must
no longer use the \code{myecho} pointer.

\end{description}


\subsection{Activating the POA}

\begin{description}

\item[Lines 15--16]\mbox{}\\
%
POAs are initially in the \term{holding} state, meaning that incoming
requests are blocked. Lines 15 and 16 acquire a reference to the POA's
POA manager, and use it to put the POA into the \term{active} state.
Incoming requests are now served. \textbf{Failing to activate the POA
is one of the most common programming mistakes. If your program
appears deadlocked, make sure you activated the POA!}

\end{description}


\subsection{Performing a call}

\begin{description}

\item[Line 18]\mbox{}\\
%
At long last, we can call \op{hello} with this object reference. The
argument is widened implicitly to the generic object reference
\type{CORBA::Object\_ptr}.

\end{description}


\subsection{ORB destruction}

\begin{description}

\item[Line 20]\mbox{}\\
%
Shutdown the ORB permanently. This call causes the ORB to release all
its resources, e.g.\ internal threads, and also to deactivate any
servant objects which are currently active. When it deactivates the
\type{Echo\_i} instance, the servant's reference count drops to zero,
so the servant is deleted.

This call is particularly important when writing a CORBA DLL on
Windows NT that is to be used from ActiveX. If this call is absent,
the application will hang when the CORBA DLL is unloaded.

\end{description}



\section{Example 2 --- Different Address Spaces}

In this example, the client and the object implementation reside in
two different address spaces. The code of this example is almost the
same as the previous example. The only difference is the extra work
which needs to be done to pass the object reference from the object
implementation to the client.

The simplest (and quite primitive) way to pass an object reference
between two address spaces is to produce a \term{stringified} version
of the object reference and to pass this string to the client as a
command-line argument.  The string is then converted by the client
into a proper object reference.  This method is used in this
example. In the next example, we shall introduce a better way of
passing the object reference using the CORBA Naming Service.

\subsection{Object Implementation: Generating a Stringified Object Reference}

The \op{main} function of the server side is reproduced below. The
full listing (\file{eg2_impl.cc}) can be found at the end of this
chapter.

\lstset{labelstep=1,gobble=4}
\begin{cxxlisting}
 1  int main(int argc, char** argv)
 2  {
 3    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);
 4
 5    CORBA::Object_var       obj = orb->resolve_initial_references("RootPOA");
 6    PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);
 7
 8    Echo_i* myecho = new Echo_i();
 9
10    PortableServer::ObjectId_var myechoid = poa->activate_object(myecho);
11
12    obj = myecho->_this();
13    CORBA::String_var sior(orb->object_to_string(obj));
14    cerr << "'" << (char*)sior << "'" << endl;
15
16    myecho->_remove_ref();
17
18    PortableServer::POAManager_var pman = poa->the_POAManager();
19    pman->activate();
20
21    orb->run();
22    orb->destroy();
23    return 0;
24  }
\end{cxxlisting}
\lstset{labelstep=0,gobble=0}

The stringified object reference is obtained by calling the ORB's
\op{object\_to\_\dsc{}string} function (line 13). This results in a
string starting with the signature `IOR:' and followed by some
hexadecimal digits. All CORBA 2 compliant ORBs are able to convert the
string into its internal representation of a so-called Interoperable
Object Reference (IOR). The IOR contains the location information and
a key to uniquely identify the object implementation in its own
address space. From the IOR, an object reference can be constructed.

\subsection{Client: Using a Stringified Object Reference}
\label{clnt2}

The stringified object reference is passed to the client as a
command-line argument. The client uses the ORB's
\op{string\_to\_object} function to convert the string into a generic
object reference (\type{CORBA::Object\_ptr}). The relevant section of
the code is reproduced below. The full listing (\file{eg2_clt.cc}) can
be found at the end of this chapter.

\begin{cxxlisting}
try {
  CORBA::Object_var obj = orb->string_to_object(argv[1]);
  hello(obj);
}
catch(CORBA::COMM_FAILURE& ex) {
  ... // code to handle communication failure
}
\end{cxxlisting}


\subsection{Catching System Exceptions}

When omniORB detects an error condition, it may raise a system
exception.  The CORBA specification defines a series of exceptions
covering most of the error conditions that an ORB may encounter. The
client may choose to catch these exceptions and recover from the error
condition\footnote{If a system exception is not caught, the C++
runtime will call the \op{terminate} function. This function is
defaulted to abort the whole process and on some systems will cause a
core file to be produced.}. For instance, the code fragment, shown in
section~\ref{clnt2}, catches the \code{COMM\_FAILURE} system exception
which indicates that communication with the object implementation in
another address space has failed.

All system exceptions inherit from \type{CORBA::SystemException}. With
compilers that properly support RTTI\footnote{Run Time Type
Identification}, a single catch of \code{CORBA::SystemException} will
catch all the different system exceptions thrown by omniORB.

When omniORB detects an internal error such as corrupt data or invalid
conditions, it raises the exception \type{omniORB::fatalException}.
When this exception is raised, it is not sensible to proceed with any
operation that involves the ORB's runtime. It is best to exit the
program immediately. The exception structure carried by
\type{omniORB::fatalException} contains the exact location (the file
name and the line number) where the exception is raised. In most
cases, \type{fatalException}s occur due to incorrect behaviour by the
application code, but they may be caused by bugs in omniORB.


\subsection{Lifetime of a CORBA object}

CORBA objects are either \term{transient} or \term{persistent}. The
majority are transient, meaning that the lifetime of the CORBA object
(as contacted through an object reference) is the same as the lifetime
of its servant object. Persistent objects can live beyond the
destruction of their servant object, the POA they were created in, and
even their process. Persistent objects are, of course, only
contactable when their associated servants are active, or can be
activated by their POA with a servant manager\footnote{The POA itself
can be activated on demand with an adapter activator.}. A reference to
a persistent object can be published, and will remain valid even if
the server process is restarted.

A POA's Lifespan Policy determines whether objects created within it
are transient or persistent. The Root POA has the \code{TRANSIENT}
policy.

An alternative to creating persistent objects is to register object
references in a \term{naming service} and bind them to fixed path
names. Clients can bind to the object implementations at run time by
asking the naming service to resolve the path names to the object
references. CORBA defines a standard naming service, which is a
component of the Common Object Services (COS)~\cite{corbaservices},
that can be used for this purpose. The next section describes an
example of how to use the COS Naming Service.


\section{Example 3 --- Using the Naming Service}

In this example, the object implementation uses the Naming
Service~\cite{corbaservices} to pass on the object reference to the
client.  This method is far more practical than using stringified
object references. The full listing of the object implementation
(\file{eg3_impl.cc}) and the client (\file{eg3_clt.cc}) can be found
at the end of this chapter.

The names used by the Naming service consist of a sequence of
\term{name components}. Each name component has an \term{id} and a
\term{kind} field, both of which are strings. All name components
except the last one are bound to a naming context. A naming context is
analogous to a directory in a filing system: it can contain names of
object references or other naming contexts. The last name component is
bound to an object reference.

Sequences of name components can be represented as a flat string,
using `.' to separate the id and kind fields, and `/' to separate name
components from each other\footnote{There are escaping rules to cope
with id and kind fields which contain `.' and `/' characters. See
chapter~\ref{chap:ins} of this manual, and chapter 3 of the CORBA
services specification, as updated for the Interoperable Naming
Service~\cite{inschapters}.}. In our example, the Echo object
reference is bound to the stringified name
`\file{test.my_context/Echo.Object}'.

The kind field is intended to describe the name in a
syntax-independent way. The naming service does not interpret, assign,
or manage these values. However, both the name and the kind attribute
must match for a name lookup to succeed. In this example, the kind
values for \file{test} and \file{Echo} are chosen to be
`\file{my_context}' and `\file{Object}' respectively. This is an
arbitrary choice as there is no standardised set of kind values.



\subsection{Obtaining the Root Context Object Reference}
\label{resolveinit}

The initial contact with the Naming Service can be established via the
\term{root} context. The object reference to the root context is
provided by the ORB and can be obtained by calling
\op{resolve\_initial\_references}. The following code fragment shows
how it is used:

\begin{cxxlisting}
CORBA::ORB_ptr orb = CORBA::ORB_init(argc,argv);

CORBA::Object_var initServ;
initServ = orb->resolve_initial_references("NameService");

CosNaming::NamingContext_var rootContext;
rootContext = CosNaming::NamingContext::_narrow(initServ);
\end{cxxlisting}

Remember, omniORB constructs its internal list of initial references
at initialisation time using the information provided in the
configuration file \file{omniORB.cfg}, or given on the command
line. If this file is not present, the internal list will be empty and
\op{resolve\_initial\_references} will raise a
\code{CORBA::ORB::\dsc{}InvalidName} exception.

\subsection{The Naming Service Interface}

It is beyond the scope of this chapter to describe in detail the
Naming Service interface. You should consult the CORBA services
specification~\cite{corbaservices} (chapter 3). The code listed in
\file{eg3_impl.cc} and \file{eg3_clt.cc} are good examples of how the
service can be used. Please spend time to study the examples
carefully.


\section{Example 4 --- Using tie implementation templates}

omniORB supports \term{tie} implementation templates as an alternative
way of providing servant classes. If you use the \texttt{-Wbtp} option
to omniidl, it generates an extra template class for each interface.
This template class can be used to tie a C++ class to the skeleton
class of the interface.

The source code in \file{eg3_tieimpl.cc} at the end of this chapter
illustrates how the template class can be used. The code is almost
identical to \file{eg3_impl.cc} with only a few changes.

Firstly, the servant class \type{Echo\_i} does not inherit from any
stub classes. This is the main benefit of using the template class
because there are applications in which it is difficult to require
every servant class to derive from CORBA classes.

Secondly, the instantiation of a CORBA object now involves creating an
instance of the implementation class \emph{and} an instance of the
template.  Here is the relevant code fragment:

\begin{cxxlisting}
class Echo_i { ... };

Echo_i *myimpl = new Echo_i();
POA_Echo_tie<Echo_i> myecho(myimpl);

PortableServer::ObjectId_var myechoid = poa->activate_object(&myecho);
\end{cxxlisting}


For interface \intf{Echo}, the name of its tie implementation template
is \type{POA\_Echo\_\dsc{}tie}. The template parameter is the servant
class that contains an implementation of each of the operations
defined in the interface. As used above, the tie template takes
ownership of the \type{Echo\_i} instance, and deletes it when the tie
object goes out of scope. The tie constructor has an optional boolean
argument (defaulted to true) which indicates whether or not it should
delete the servant object. For full details of using tie templates,
see the CORBA C++ mapping specification.


\clearpage
\section{Source Listings}

\subsection{eg1.cc}

\begin{cxxlisting}
// eg1.cc - This is the source code of example 1 used in Chapter 2
//          "The Basics" of the omniORB user guide.
//
//          In this example, both the object implementation and the
//          client are in the same process.
//
// Usage: eg1
//

#include <iostream.h>
#include <echo.hh>


// This is the object implementation.

class Echo_i : public POA_Echo,
	       public PortableServer::RefCountServantBase
{
public:
  inline Echo_i() {}
  virtual ~Echo_i() {}
  virtual char* echoString(const char* mesg);
};


char* Echo_i::echoString(const char* mesg)
{
  return CORBA::string_dup(mesg);
}

//////////////////////////////////////////////////////////////////////

// This function acts as a client to the object.

static void hello(Echo_ptr e)
{
  if( CORBA::is_nil(e) ) {
    cerr << "hello: The object reference is nil!\n" << endl;
    return;
  }

  CORBA::String_var src = (const char*) "Hello!";
  // String literals are (char*) rather than (const char*) on some
  // old compilers.  Thus it is essential to cast to (const char*)
  // here to ensure that the string is copied, so that the
  // CORBA::String_var does not attempt to 'delete' the string
  // literal.

  CORBA::String_var dest = e->echoString(src);

  cerr << "I said, \"" << (char*)src << "\"." << endl
       << "The Echo object replied, \"" << (char*)dest <<"\"." << endl;
}

//////////////////////////////////////////////////////////////////////

int main(int argc, char** argv)
{


  try {
    // Initialise the ORB.
    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);

    // Obtain a reference to the root POA.
    CORBA::Object_var obj = orb->resolve_initial_references("RootPOA");
    PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);

      // We allocate the object on the heap.  Since this is a reference
      // counted object, it will be deleted by the POA when it is no
      // longer needed.
    Echo_i* myecho = new Echo_i();

    // Activate the object.  This tells the POA that this object is
    // ready to accept requests.
    PortableServer::ObjectId_var myechoid = poa->activate_object(myecho);

      // Obtain a reference to the object.
    Echo_var myechoref = myecho->_this();

    // Decrement the reference count of the object implementation, so
    // that it will be properly cleaned up when the POA has determined
    // that it is no longer needed.
    myecho->_remove_ref();

    // Obtain a POAManager, and tell the POA to start accepting
    // requests on its objects.
    PortableServer::POAManager_var pman = poa->the_POAManager();
    pman->activate();

    // Do the client-side call.
    hello(myechoref);

    // Clean up all the resources.
    orb->destroy();
  }
  catch(CORBA::COMM_FAILURE& ex) {
    cerr << "Caught system exception COMM_FAILURE -- unable to contact the "
         << "object." << endl;
  }
  catch(CORBA::SystemException&) {
    cerr << "Caught CORBA::SystemException." << endl;
  }
  catch(CORBA::Exception&) {
    cerr << "Caught CORBA::Exception." << endl;
  }
  catch(omniORB::fatalException& fe) {
    cerr << "Caught omniORB::fatalException:" << endl;
    cerr << "  file: " << fe.file() << endl;
    cerr << "  line: " << fe.line() << endl;
    cerr << "  mesg: " << fe.errmsg() << endl;
  }
  catch(...) {
    cerr << "Caught unknown exception." << endl;
  }

  return 0;
}
\end{cxxlisting}


\clearpage
\subsection{eg2\_impl.cc}

\begin{cxxlisting}
// eg2_impl.cc - This is the source code of example 2 used in Chapter 2
//               "The Basics" of the omniORB user guide.
//
//               This is the object implementation.
//
// Usage: eg2_impl
//
//        On startup, the object reference is printed to cerr as a
//        stringified IOR. This string should be used as the argument to 
//        eg2_clt.
//

#include <iostream.h>
#include <echo.hh>


class Echo_i : public POA_Echo,
	       public PortableServer::RefCountServantBase
{
public:
  inline Echo_i() {}
  virtual ~Echo_i() {}
  virtual char* echoString(const char* mesg);
};


char* Echo_i::echoString(const char* mesg)
{
  cerr << "Upcall " << mesg << endl;
  return CORBA::string_dup(mesg);
}

//////////////////////////////////////////////////////////////////////

int main(int argc, char** argv)
{
  try {
    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);

    CORBA::Object_var obj = orb->resolve_initial_references("RootPOA");
    PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);

    Echo_i* myecho = new Echo_i();
      
    PortableServer::ObjectId_var myechoid = poa->activate_object(myecho);

    // Obtain a reference to the object, and print it out as a
    // stringified IOR.
    obj = myecho->_this();
    CORBA::String_var sior(orb->object_to_string(obj));
    cerr << "'" << (char*)sior << "'" << endl;

    myecho->_remove_ref();

    PortableServer::POAManager_var pman = poa->the_POAManager();
    pman->activate();

    orb->run();
  }
  catch(CORBA::SystemException&) {
    cerr << "Caught CORBA::SystemException." << endl;
  }
  catch(CORBA::Exception&) {
    cerr << "Caught CORBA::Exception." << endl;
  }
  catch(omniORB::fatalException& fe) {
    cerr << "Caught omniORB::fatalException:" << endl;
    cerr << "  file: " << fe.file() << endl;
    cerr << "  line: " << fe.line() << endl;
    cerr << "  mesg: " << fe.errmsg() << endl;
  }
  catch(...) {
    cerr << "Caught unknown exception." << endl;
  }

  return 0;
}
\end{cxxlisting}


\clearpage
\subsection{eg2\_clt.cc}

\begin{cxxlisting}
// eg2_clt.cc - This is the source code of example 2 used in Chapter 2
//              "The Basics" of the omniORB user guide.
//
//              This is the client. The object reference is given as a
//              stringified IOR on the command line.
//
// Usage: eg2_clt <object reference>
//

#include <iostream.h>
#include <echo.hh>


static void hello(Echo_ptr e)
{
  CORBA::String_var src = (const char*) "Hello!";

  CORBA::String_var dest = e->echoString(src);

  cerr << "I said, \"" << (char*)src << "\"." << endl
       << "The Echo object replied, \"" << (char*)dest <<"\"." << endl;
}

//////////////////////////////////////////////////////////////////////

int main(int argc, char** argv)
{


  try {
    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);

    if( argc != 2 ) {
      cerr << "usage:  eg2_clt <object reference>" << endl;
      return 1;
    }

    CORBA::Object_var obj = orb->string_to_object(argv[1]);
    Echo_var echoref = Echo::_narrow(obj);
    if( CORBA::is_nil(echoref) ) {
      cerr << "Can't narrow reference to type Echo (or it was nil)." << endl;
      return 1;
    }
    for (CORBA::ULong count=0; count<10; count++) 
      hello(echoref);

    orb->destroy();
  }
  catch(CORBA::COMM_FAILURE& ex) {
    cerr << "Caught system exception COMM_FAILURE -- unable to contact the "
         << "object." << endl;
  }
  catch(CORBA::SystemException&) {
    cerr << "Caught a CORBA::SystemException." << endl;
  }
  catch(CORBA::Exception&) {
    cerr << "Caught CORBA::Exception." << endl;
  }
  catch(omniORB::fatalException& fe) {
    cerr << "Caught omniORB::fatalException:" << endl;
    cerr << "  file: " << fe.file() << endl;
    cerr << "  line: " << fe.line() << endl;
    cerr << "  mesg: " << fe.errmsg() << endl;
  }
  catch(...) {
    cerr << "Caught unknown exception." << endl;
  }
  return 0;
}
\end{cxxlisting}


\clearpage
\subsection{eg3\_impl.cc}

\begin{cxxlisting}
// eg3_impl.cc - This is the source code of example 3 used in Chapter 2
//               "The Basics" of the omniORB user guide.
//
//               This is the object implementation.
//
// Usage: eg3_impl
//
//        On startup, the object reference is registered with the
//        COS naming service. The client uses the naming service to
//        locate this object.
//
//        The name which the object is bound to is as follows:
//              root  [context]
//               |
//              test  [context] kind [my_context]
//               |
//              Echo  [object]  kind [Object]
//

#include <iostream.h>
#include <echo.hh>


static CORBA::Boolean bindObjectToName(CORBA::ORB_ptr, CORBA::Object_ptr);


class Echo_i : public POA_Echo,
	       public PortableServer::RefCountServantBase
{
public:
  inline Echo_i() {}
  virtual ~Echo_i() {}
  virtual char* echoString(const char* mesg);
};


char* Echo_i::echoString(const char* mesg)
{
  return CORBA::string_dup(mesg);
}

//////////////////////////////////////////////////////////////////////

int
main(int argc, char **argv)
{
  try {
    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);

    CORBA::Object_var obj = orb->resolve_initial_references("RootPOA");
    PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);

    Echo_i* myecho = new Echo_i();

    PortableServer::ObjectId_var myechoid = poa->activate_object(myecho);

    // Obtain a reference to the object, and register it in
    // the naming service.
    obj = myecho->_this();

    CORBA::String_var x;
    x = orb->object_to_string(obj);
    cerr << x << "\n";

    if( !bindObjectToName(orb, obj) )
      return 1;

    myecho->_remove_ref();

    PortableServer::POAManager_var pman = poa->the_POAManager();
    pman->activate();

    orb->run();
  }
  catch(CORBA::SystemException&) {
    cerr << "Caught CORBA::SystemException." << endl;
  }
  catch(CORBA::Exception&) {
    cerr << "Caught CORBA::Exception." << endl;
  }
  catch(omniORB::fatalException& fe) {
    cerr << "Caught omniORB::fatalException:" << endl;
    cerr << "  file: " << fe.file() << endl;
    cerr << "  line: " << fe.line() << endl;
    cerr << "  mesg: " << fe.errmsg() << endl;
  }
  catch(...) {
    cerr << "Caught unknown exception." << endl;
  }

  return 0;
}

//////////////////////////////////////////////////////////////////////

static CORBA::Boolean
bindObjectToName(CORBA::ORB_ptr orb, CORBA::Object_ptr objref)
{
  CosNaming::NamingContext_var rootContext;

  try {
    // Obtain a reference to the root context of the Name service:
    CORBA::Object_var obj;
    obj = orb->resolve_initial_references("NameService");

    // Narrow the reference returned.
    rootContext = CosNaming::NamingContext::_narrow(obj);
    if( CORBA::is_nil(rootContext) ) {
      cerr << "Failed to narrow the root naming context." << endl;
      return 0;
    }
  }
  catch(CORBA::ORB::InvalidName& ex) {
    // This should not happen!
    cerr << "Service required is invalid [does not exist]." << endl;
    return 0;
  }

  try {
    // Bind a context called "test" to the root context:

    CosNaming::Name contextName;
    contextName.length(1);
    contextName[0].id   = (const char*) "test";       // string copied
    contextName[0].kind = (const char*) "my_context"; // string copied
    // Note on kind: The kind field is used to indicate the type
    // of the object. This is to avoid conventions such as that used
    // by files (name.type -- e.g. test.ps = postscript etc.)

    CosNaming::NamingContext_var testContext;
    try {
      // Bind the context to root.
      testContext = rootContext->bind_new_context(contextName);
    }
    catch(CosNaming::NamingContext::AlreadyBound& ex) {
      // If the context already exists, this exception will be raised.
      // In this case, just resolve the name and assign testContext
      // to the object returned:
      CORBA::Object_var obj;
      obj = rootContext->resolve(contextName);
      testContext = CosNaming::NamingContext::_narrow(obj);
      if( CORBA::is_nil(testContext) ) {
        cerr << "Failed to narrow naming context." << endl;
        return 0;
      }
    }

    // Bind objref with name Echo to the testContext:
    CosNaming::Name objectName;
    objectName.length(1);
    objectName[0].id   = (const char*) "Echo";   // string copied
    objectName[0].kind = (const char*) "Object"; // string copied

    try {
      testContext->bind(objectName, objref);
    }
    catch(CosNaming::NamingContext::AlreadyBound& ex) {
      testContext->rebind(objectName, objref);
    }
    // Note: Using rebind() will overwrite any Object previously bound
    //       to /test/Echo with obj.
    //       Alternatively, bind() can be used, which will raise a
    //       CosNaming::NamingContext::AlreadyBound exception if the name
    //       supplied is already bound to an object.

    // Amendment: When using OrbixNames, it is necessary to first try bind
    // and then rebind, as rebind on it's own will throw a NotFoundexception if
    // the Name has not already been bound. [This is incorrect behaviour -
    // it should just bind].
  }
  catch(CORBA::COMM_FAILURE& ex) {
    cerr << "Caught system exception COMM_FAILURE -- unable to contact the "
         << "naming service." << endl;
    return 0;
  }
  catch(CORBA::SystemException&) {
    cerr << "Caught a CORBA::SystemException while using the naming service."
	 << endl;
    return 0;
  }

  return 1;
}
\end{cxxlisting}


\clearpage
\subsection{eg3\_clt.cc}

\begin{cxxlisting}
// eg3_clt.cc - This is the source code of example 3 used in Chapter 2
//              "The Basics" of the omniORB user guide.
//
//              This is the client. It uses the COSS naming service
//              to obtain the object reference.
//
// Usage: eg3_clt
//
//
//        On startup, the client lookup the object reference from the
//        COS naming service.
//
//        The name which the object is bound to is as follows:
//              root  [context]
//               |
//              text  [context] kind [my_context]
//               |
//              Echo  [object]  kind [Object]
//

#include <iostream.h>
#include <echo.hh>

static CORBA::Object_ptr getObjectReference(CORBA::ORB_ptr orb);

static void hello(Echo_ptr e)
{
  if( CORBA::is_nil(e) ) {
    cerr << "hello: The object reference is nil!\n" << endl;
    return;
  }

  CORBA::String_var src = (const char*) "Hello!";

  CORBA::String_var dest = e->echoString(src);

  cerr << "I said, \"" << (char*)src << "\"." << endl
       << "The Echo object replied, \"" << (char*)dest <<"\"." << endl;
}

//////////////////////////////////////////////////////////////////////

int
main (int argc, char **argv) 
{
  try {
    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);

    CORBA::Object_var obj = getObjectReference(orb);

    Echo_var echoref = Echo::_narrow(obj);

    for (CORBA::ULong count=0; count < 10; count++)
      hello(echoref);

    orb->destroy();
  }
  catch(CORBA::COMM_FAILURE& ex) {
    cerr << "Caught system exception COMM_FAILURE -- unable to contact the "
         << "object." << endl;
  }
  catch(CORBA::SystemException&) {
    cerr << "Caught CORBA::SystemException." << endl;
  }
  catch(CORBA::Exception&) {
    cerr << "Caught CORBA::Exception." << endl;
  }
  catch(omniORB::fatalException& fe) {
    cerr << "Caught omniORB::fatalException:" << endl;
    cerr << "  file: " << fe.file() << endl;
    cerr << "  line: " << fe.line() << endl;
    cerr << "  mesg: " << fe.errmsg() << endl;
  }
  catch(...) {
    cerr << "Caught unknown exception." << endl;
  }

  return 0;
}

//////////////////////////////////////////////////////////////////////

static CORBA::Object_ptr
getObjectReference(CORBA::ORB_ptr orb)
{
  CosNaming::NamingContext_var rootContext;
  
  try {
    // Obtain a reference to the root context of the Name service:
    CORBA::Object_var obj;
    obj = orb->resolve_initial_references("NameService");

    // Narrow the reference returned.
    rootContext = CosNaming::NamingContext::_narrow(obj);
    if( CORBA::is_nil(rootContext) ) {
      cerr << "Failed to narrow the root naming context." << endl;
      return CORBA::Object::_nil();
    }
  }
  catch(CORBA::ORB::InvalidName& ex) {
    // This should not happen!
    cerr << "Service required is invalid [does not exist]." << endl;
    return CORBA::Object::_nil();
  }

  // Create a name object, containing the name test/context:
  CosNaming::Name name;
  name.length(2);

  name[0].id   = (const char*) "test";       // string copied
  name[0].kind = (const char*) "my_context"; // string copied
  name[1].id   = (const char*) "Echo";
  name[1].kind = (const char*) "Object";
  // Note on kind: The kind field is used to indicate the type
  // of the object. This is to avoid conventions such as that used
  // by files (name.type -- e.g. test.ps = postscript etc.)

  try {
    // Resolve the name to an object reference.
    return rootContext->resolve(name);
  }
  catch(CosNaming::NamingContext::NotFound& ex) {
    // This exception is thrown if any of the components of the
    // path [contexts or the object] aren't found:
    cerr << "Context not found." << endl;
  }
  catch(CORBA::COMM_FAILURE& ex) {
    cerr << "Caught system exception COMM_FAILURE -- unable to contact the "
         << "naming service." << endl;
  }
  catch(CORBA::SystemException&) {
    cerr << "Caught a CORBA::SystemException while using the naming service."
	 << endl;
  }

  return CORBA::Object::_nil();
}
\end{cxxlisting}


\clearpage
\subsection{eg3\_tieimpl.cc}

\begin{cxxlisting}
// eg3_tieimpl.cc - This example is similar to eg3_impl.cc except that
//                  the tie implementation skeleton is used.
//
//               This is the object implementation.
//
// Usage: eg3_tieimpl
//
//        On startup, the object reference is registered with the 
//        COS naming service. The client uses the naming service to
//        locate this object.
//
//        The name which the object is bound to is as follows:
//              root  [context]
//               |
//              test  [context] kind [my_context]
//               |
//              Echo  [object]  kind [Object]
//

#include <iostream.h>
#include <echo.hh>


static CORBA::Boolean bindObjectToName(CORBA::ORB_ptr,CORBA::Object_ptr);


// This is the object implementation.  Notice that it does not
// inherit from any stub class.

class Echo_i {
public:
  inline Echo_i() {}
  inline ~Echo_i() {}
  virtual char* echoString(const char* mesg);
};


char* Echo_i::echoString(const char* mesg)
{
  return CORBA::string_dup(mesg);
}

//////////////////////////////////////////////////////////////////////

int main(int argc, char** argv)
{
  try {
    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv);

    CORBA::Object_var obj = orb->resolve_initial_references("RootPOA");
    PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);

    // Note that the <myecho> object is constructed on the stack here.
    // This is because tie implementations do not inherit from the
    // PortableServer::RefCountServantBase mixin class -- and so are
    // not automatically deleted by the POA.
    // However, it will delete its implementation (myimpl) when it
    // it itself destroyed (when it goes out of scope).  It is
    // essential however to ensure that such objects are not deleted
    // whilst still activated.
    Echo_i* myimpl = new Echo_i();
    POA_Echo_tie<Echo_i> myecho(myimpl);

    PortableServer::ObjectId_var myechoid = poa->activate_object(&myecho);

    // Obtain a reference to the object, and register it in
    // the naming service.
    obj = myecho._this();
    if( !bindObjectToName(orb, obj) )
      return 1;

    PortableServer::POAManager_var pman = poa->the_POAManager();
    pman->activate();

    orb->run();
  }
  catch(CORBA::SystemException&) {
    cerr << "Caught CORBA::SystemException." << endl;
  }
  catch(CORBA::Exception&) {
    cerr << "Caught CORBA::Exception." << endl;
  }
  catch(omniORB::fatalException& fe) {
    cerr << "Caught omniORB::fatalException:" << endl;
    cerr << "  file: " << fe.file() << endl;
    cerr << "  line: " << fe.line() << endl;
    cerr << "  mesg: " << fe.errmsg() << endl;
  }
  catch(...) {
    cerr << "Caught unknown exception." << endl;
  }

  return 0;
}

//////////////////////////////////////////////////////////////////////

static CORBA::Boolean
bindObjectToName(CORBA::ORB_ptr orb, CORBA::Object_ptr objref)
{
  CosNaming::NamingContext_var rootContext;

  try {
    // Obtain a reference to the root context of the Name service:
    CORBA::Object_var obj;
    obj = orb->resolve_initial_references("NameService");

    // Narrow the reference returned.
    rootContext = CosNaming::NamingContext::_narrow(obj);
    if( CORBA::is_nil(rootContext) ) {
      cerr << "Failed to narrow the root naming context." << endl;
      return 0;
    }
  }
  catch(CORBA::ORB::InvalidName& ex) {
    // This should not happen!
    cerr << "Service required is invalid [does not exist]." << endl;
    return 0;
  }

  try {
    // Bind a context called "test" to the root context:

    CosNaming::Name contextName;
    contextName.length(1);
    contextName[0].id   = (const char*) "test";       // string copied
    contextName[0].kind = (const char*) "my_context"; // string copied
    // Note on kind: The kind field is used to indicate the type
    // of the object. This is to avoid conventions such as that used
    // by files (name.type -- e.g. test.ps = postscript etc.)

    CosNaming::NamingContext_var testContext;
    try {
      // Bind the context to root.
      testContext = rootContext->bind_new_context(contextName);
    }
    catch(CosNaming::NamingContext::AlreadyBound& ex) {
      // If the context already exists, this exception will be raised.
      // In this case, just resolve the name and assign testContext
      // to the object returned:
      CORBA::Object_var obj;
      obj = rootContext->resolve(contextName);
      testContext = CosNaming::NamingContext::_narrow(obj);
      if( CORBA::is_nil(testContext) ) {
        cerr << "Failed to narrow naming context." << endl;
        return 0;
      }
    }

    // Bind objref with name Echo to the testContext:
    CosNaming::Name objectName;
    objectName.length(1);
    objectName[0].id   = (const char*) "Echo";   // string copied
    objectName[0].kind = (const char*) "Object"; // string copied

    try {
      testContext->bind(objectName, objref);
    }
    catch(CosNaming::NamingContext::AlreadyBound& ex) {
      testContext->rebind(objectName, objref);
    }
    // Note: Using rebind() will overwrite any Object previously bound
    //       to /test/Echo with obj.
    //       Alternatively, bind() can be used, which will raise a
    //       CosNaming::NamingContext::AlreadyBound exception if the name
    //       supplied is already bound to an object.

    // Amendment: When using OrbixNames, it is necessary to first try bind
    // and then rebind, as rebind on it's own will throw a NotFoundexception if
    // the Name has not already been bound. [This is incorrect behaviour -
    // it should just bind].
  }
  catch(CORBA::COMM_FAILURE& ex) {
    cerr << "Caught system exception COMM_FAILURE -- unable to contact the "
         << "naming service." << endl;
    return 0;
  }
  catch(CORBA::SystemException&) {
    cerr << "Caught a CORBA::SystemException while using the naming service."
	 << endl;
    return 0;
  }

  return 1;
}
\end{cxxlisting}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{C++ language mapping}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Now that you are familiar with the basics, it is important to
familiarise yourself with the standard IDL to C++ language mapping.
The mapping is described in detail in~\cite{cxxmapping}. If you have
not done so, you should obtain a copy of the document and use that as
the programming guide to omniORB.

The specification is not an easy read. The alternative is to use one
of the books on CORBA programming that has begun to appear. For
instance, Henning and Vinoski's `Advanced CORBA Programming with
C++'~\cite{henning1999} includes many example code bits to illustrate
how to use the C++ mapping.


\section{omniORB 2 BOA compatibility}
\label{sec:BOAcompat}

If you use the \cmdline{-WbBOA} option to omniidl, it will generate
skeleton code with the same interface as the old omniORB 2 BOA
mapping, as well as code to be used with the POA. Note that since the
major problem with the BOA specification was that server code was not
portable between ORBs, it is unlikely that omniORB 4.0's BOA
compatibility will help you much if you are moving from a different
BOA-based ORB.

The BOA compatibility permits the majority of BOA code to compile
without difficulty. However, there are a number of constructs which
relied on omniORB 2 implementation details which no longer work.

\begin{itemize}

\item omniORB 2 did not use distinct types for object references and
servants, and often accepted a pointer to a servant when the CORBA
specification says it should only accept an object reference. Such
code will not compile under omniORB 4.0.

\item The reverse is true for \op{BOA::obj\_is\_ready}. It now only
works when passed a pointer to a servant object, not an object
reference. The more commonly used mechanism of calling
\code{\_obj\_is\_ready(boa)} on the servant object still works as
expected.

\item It used to be the case that the skeleton class for interface
\intf{I} (\type{\_sk\_I}) was derived from class \type{I}. This meant
that the names of any types declared in the interface were available
in the scope of the skeleton class. This is no longer true. If you
have an interface:

\begin{idllisting}
interface I {
  struct S {
    long a,b;
  };
  S op();
};
\end{idllisting}

\noindent then where before the implementation code might have been:

\begin{cxxlisting}
class I_impl : public virtual _sk_I {
  S op();  // _sk_I is derived from I
};
I::S I_impl::op() {
  S ret;
  // ...
}
\end{cxxlisting}

\noindent it is now necessary to fully qualify all uses of \type{S}:

\begin{cxxlisting}
class I_impl : public virtual _sk_I {
  I::S op(); // _sk_I is not derived from I
};
I::S I_impl::op() {
  I::S ret;
  // ...
}
\end{cxxlisting}


\item The proprietary omniORB 2 LifeCycle extensions are no longer
supported. All of the facilities it offered can be implemented with
the POA interfaces, and the \code{omniORB::LOCATION\_FORWARD}
exception (see section~\ref{sec:locationForward}). Code which used the
old interfaces will have to be rewritten.


\end{itemize}


\section{omniORB 3.0 compatibility}

omniORB 4.0 is almost completely source-code compatible with omniORB
3.0. There are two main cases where code may have to change. The first
is code that uses the omniORB API, some aspects of which have
changed. The omniORB configuration file also has a new format. See the
next chapter for details of the new API and configuration file.

The second case of code that may have to change is code using the
Dynamic Any interfaces. The standard changed quite significantly
between CORBA 2.2 and CORBA 2.3; omniORB 3.0 supported the old CORBA
2.2 interfaces; omniORB 4.0 uses the new mapping. The changes are
largely syntax changes, rather than semantic differences.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{omniORB configuration and API}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:config}

omniORB 4.0 has a wide range of parameters that can be
configured. They can be set in the configuration file / Windows
registry, as environment variables, on the command line, or within a
proprietary extra argument to \op{CORBA::ORB\_init}. A few parameters
can be configured at run time. This chapter lists all the
configuration parameters, and how they are used.

\section{Setting parameters}

When \op{CORBA::ORB\_init} is called, the value for each configuration
parameter is searched for in the following order:

\begin{enumerate}

\item Command line arguments
\item \op{ORB\_init} options
\item Environment variables
\item Configuration file / Windows registry
\item Built-in defaults

\end{enumerate}

\subsection{Command line arguments}

Command line arguments take the form
`\cmdline{-ORB}\textit{parameter}', and usually expect another
argument. An example is `\cmdline{-ORBtraceLevel 10}'.


\subsection{ORB\_init() parameter}

\op{ORB\_init}'s extra argument accepts an array of two-dimensional
arrays of strings, like this:

\begin{cxxlisting}
const char* options[][2] = { { "traceLevel", "1" }, { 0, 0 } }; 
orb = CORBA::ORB_init(argc,argv,"omniORB4",options); 
\end{cxxlisting}


\subsection{Environment variables}

Environment variables consist of the parameter name prefixed with
`\cmdline{ORB}'. Using bash, for example

\begin{makelisting}
export ORBtraceLevel=10
\end{makelisting}


\subsection{Configuration file}

The best way to understand the format of the configuration file is to
look at the \file{sample.cfg} file in the omniORB distribution. Each
parameter is set on a single line like

\begin{verbatim}
traceLevel = 10
\end{verbatim}

Some parameters can have more than one value, in which case the
parameter name may be specified more than once, or you can leave it
out:

\begin{verbatim}
InitRef = NameService=corbaname::host1.example.com
        = InterfaceRepository=corbaloc::host2.example.com:1234/IfR
\end{verbatim}


\begin{statement}
Note how command line arguments and environment variables prefix
parameter names with `-ORB' and `ORB' respectively, but the
configuration file and the extra argument to \op{ORB\_init} do not use
a prefix.
\end{statement}


\subsection{Windows registry}

On Windows, configuration parameters can be stored in the registry,
under the key
%BEGIN LATEX
\file{HKEY_LOCAL_MACHINE\SOFTWARE\omniORB}.
%END LATEX
%HEVEA \verb|HKEY_LOCAL_MACHINE\SOFTWARE\omniORB|.

The file \file{sample.reg} shows the settings that can be made. It can
be edited and then imported into regedit.



\section{Tracing options}

The following options control debugging trace output.


\confopt{traceLevel}{1}

omniORB can output tracing and diagnostic messages to the standard
error stream. The following levels are defined:

\vspace{\baselineskip}

\begin{tabular}{lp{.6\textwidth}}
%HEVEA\\

level 0      & critical errors only\\
level 1      & informational messages only\\
level 2      & configuration information and warnings\\

level 5      & notifications when server threads are
               created and communication endpoints are shutdown\\

level 10     & execution and exception traces\\
level 25     & trace each send or receive of a giop message\\
level 30     & dump up to 128 bytes of each giop message\\
level 40     & dump complete contents of each giop message\\
\end{tabular}

\vspace{\baselineskip}

\noindent The trace level is cumulative, so at level 40, all trace
messages are output.


\confopt{traceInvocations}{0}

If the \code{traceInvocations} parameter is set true, all local and
remote invocations are logged, in addition to any logging that may
have been selected with \code{traceLevel}.


\confopt{traceThreadId}{0}

If \code{traceThreadId} is set true, all trace messages are prefixed
with the id of the thread outputting the message. This can be handy
for tracking down race conditions, but it adds significant overhead to
the logging function so it is turned off by default.


\subsection{Tracing API}

The three tracing parameters can be modified at runtime by assigning
to the following variables

\begin{cxxlisting}
namespace omniORB {
  CORBA::ULong   traceLevel;
  CORBA::Boolean traceInvocations;
  CORBA::Boolean traceThreadId;
};
\end{cxxlisting}

\noindent
Log messages can be sent somewhere other than stderr by registering a
logging function which is called with the text of each log message:

\begin{cxxlisting}
namespace omniORB {
  typedef void (*logFunction)(const char*);
  void setLogFunction(logFunction f);
};
\end{cxxlisting}

\noindent
The log function must not make any CORBA calls, since that could lead
to infinite recursion as outputting a log message caused other log
messages to be generated, and so on.




\section{Miscellaneous global options}

These options control miscellaneous features that affect the whole ORB
runtime.

\confopt{dumpConfiguration}{0}

If set true, the ORB dumps the values of all configuration parameters
at start-up.


\confopt{scanGranularity}{5}

As explained in chapter~\ref{chap:connections}, omniORB regularly
scans incoming and outgoing connections, so it can close unused
ones. This value is the granularity in seconds at which the ORB
performs its scans. A value of zero turns off the scanning altogether.


\confopt{nativeCharCodeSet}{ISO-8859-1}

The native code set the application is using for \type{char} and
\type{string}. See chapter~\ref{chap:codesets}.


\confopt{nativeWCharCodeSet}{UTF-16}

The native code set the application is using for \type{wchar} and
\type{wstring}. See chapter~\ref{chap:codesets}.


\confopt{omniORB\_27\_CompatibleAnyExtraction}{0}

In omniORB 2.7 and earlier, the Any extraction operators for strings
and object references returned a copy/duplicate of the value stored in
the Any, meaning the caller had to release the extracted value. The
C++ mapping was clarified to state that the Any retains ownership of
the returned value, so the caller does not need to release it. To aid
the transition for ancient programs from omniORB 2.7 or earlier,
setting this flag to true selects the old copying behaviour.


\confopt{abortOnInternalError}{0}

If this is set true, internal fatal errors will abort immediately,
rather than throwing the \type{omniORB::fatalException} exception.
This can be helpful for tracking down bugs, since it leaves the call
stack intact.


\section{Client side options}

These options control aspects of client-side behaviour.


\confopt{InitRef}{\textit{none}}

Specify the objects available from
\op{ORB::resolve\_initial\_references}. The arguments take the form
<\textit{key}>=<\textit{uri}>, where the \textit{key} is the name
given to \op{resolve\_\dsc{}initial\_\dsc{}references} and
\textit{uri} is a valid CORBA object reference URI, as detailed in
chapter~\ref{chap:ins}.


\confopt{DefaultInitRef}{\textit{none}}

Specify the default URI prefix for
\op{resolve\_\dsc{}initial\_\dsc{}references}, as explained in
chapter~\ref{chap:ins}.


\confopt{clientTransportRule}{* unix,tcp,ssl}

Used to specify the way the client contacts a server, depending on the
server's address. See section~\ref{sec:clientRule} for details.


\confopt{clientCallTimeOutPeriod}{0}

Call timeout in milliseconds for the client side. If a call takes
longer than the specified number of milliseconds, the ORB closes the
connection and raises a \code{COMM\_\dsc{}FAILURE} exception. A value
of zero means no timeout; calls can block for ever.

\vspace{.5\baselineskip}

\noindent\textbf{Note}: omniORB 3 had timeouts specified in seconds; omniORB
4.0 uses milliseconds for timeouts.


\confopt{outConScanPeriod}{120}

Idle timeout in seconds for outgoing (i.e.\ client initiated)
connections. If a connection has been idle for this amount of time,
the ORB closes it. See section~\ref{sec:connShutdown}.


\confopt{maxGIOPConnectionPerServer}{5}

The maximum number of concurrent connections the ORB will open to a
\emph{single} server. If multiple threads on the client call the same
server, the ORB opens additional connections to the server, up to the
maximum specified by this parameter. If the maximum is reached,
threads are blocked until a connection becomes free for them to use.


\confopt{oneCallPerConnection}{1}

When this parameter is set to true (the default), the ORB will only
send a single call on a connection at a time. If multiple client
threads invoke on the same server, multiple connections are opened, up
to the limit specified by
\code{maxGIOPConnection\dsc{}PerServer}. With this parameter set to
false, the ORB will allow concurrent calls on a single
connection. This saves connection resources, but requires slightly
more management work for both client and server. Some server-side ORBs
(including omniORB versions before 4.0) serialise all calls on a
single connection.


\confopt{offerBiDirectionalGIOP}{0}

If set true, the client will indicate to servers that it is willing to
accept callbacks on client-initiated connections using bidirectional
GIOP, provided the relevant POA policies are set. See
section~\ref{sec:bidir}.


\confopt{diiThrowsSysExceptions}{0}

If this is true, DII functions throw system exceptions; if it is
false, system exceptions that occur are passed through the
\type{Environment} object.


\confopt{verifyObjectExistsAndType}{1}

By default, omniORB uses the GIOP \code{LOCATE\_REQUEST} message to
verify the existence of an object prior to the first invocation. In
the case that the full type of the object is not known, it instead
calls the \op{\_is\_a} operation to check the object's type. Some ORBs
have bugs that mean one or other of these operations fail. Setting
this parameter false prevents omniORB from making these calls.


\confopt{giopTargetAddressMode}{0}

GIOP 1.2 supports three addressing modes for contacting objects. This
parameter selects the mode that omniORB uses. A value of 0 means
\code{GIOP::KeyAddr}; 1 means \code{GIOP::ProfileAddr}; 2 means
\code{GIOP::ReferenceAddr}.


\confopt{bootstrapAgentHostname}{\textit{none}}

If set, this parameter indicates the hostname to use for look-ups
using the obsolete Sun bootstrap agent. This mechanism is superseded
by the interoperable naming service.


\confopt{bootstrapAgentPort}{900}

The port number for the obsolete Sun bootstrap agent.


\confopt{principal}{\textit{none}}

GIOP 1.0 and 1.1 have a request header field named `principal', which
contains a sequence of octets. It was never defined what it should
mean, and its use is now deprecated; GIOP 1.2 has no such field. Some
systems (e.g.\ Gnome) use the principal field as a primitive
authentication scheme. This parameter sets the data omniORB uses in
the principal field. The default is an empty sequence.



\section{Server side options}

These parameters affect server-side operations.


\vspace{\baselineskip}

\noindent
\code{endPoint~~~~~~~~~} ~~ \textit{default} = \code{giop:tcp::}\\
\code{endPointNoListen}\\
\code{endPointNoPublish}\\
\code{endPointPublishAllIFs}\\[.1ex]

\noindent
These options determine the end-points the ORB should listen on, and
the details that should be published in IORs. See
chapter~\ref{chap:connections} for details.



\confopt{serverTransportRule}{* unix,tcp,ssl}

Configure the rules about whether a server should accept an incoming
connection from a client. See section~\ref{sec:serverRule} for
details.


\confopt{serverCallTimeOutPeriod}{0}

This timeout is used to catch the situation that the server starts
receiving a request, but the end of the request never comes. If a
calls takes longer than the specified number of milliseconds to
arrive, the ORB shuts the connection. A value of zero means never
timeout.


\confopt{inConScanPeriod}{180}

Idle timeout in seconds for incoming. If a connection has been idle
for this amount of time, the ORB closes it. See
section~\ref{sec:connShutdown}.


\confopt{threadPerConnectionPolicy}{1}

If true (the default), the ORB dedicates one server thread to each
incoming connection. Setting it false means the server should use a
thread pool.


\confopt{maxServerThreadPerConnection}{100}

If the client multiplexes several concurrent requests on a single
connection, omniORB uses extra threads to service them. This parameter
specifies the maximum number of threads that are allowed to service a
single connection at any one time.


\confopt{maxServerThreadPoolSize}{100}

The maximum number of threads the server will allocate to do various
tasks, including dispatching calls in the thread pool mode. This
number does not include threads dispatched under the thread per
connection server mode.


\confopt{threadPerConnectionUpperLimit}{10000}

If the \code{threadPerConnectionPolicy} parameter is true, the ORB can
automatically transition to thread pool mode if too many connections
arrive. This parameter sets the number of connections at which thread
pooling is started. The default of 10000 is designed to mean that it
never happens.


\confopt{threadPerConnectionLowerLimit}{9000}

If thread pooling was started because the number of connections hit
the upper limit, this parameter determines when thread per connection
should start again.


\confopt{threadPoolWatchConnection}{1}

If true, threads from the pool temporarily behave a bit like thread
per connection after dispatching a call. See
section~\ref{sec:watchConn} for details.


\confopt{acceptBiDirectionalGIOP}{0}

Determines whether a server will ever accept clients' offers of
bidirectional GIOP connections. See section~\ref{sec:bidir}.


\confopt{unixTransportDirectory}{/tmp/omni-\%u}

(Unix platforms only). Selects the location used to store Unix domain
sockets. The `\code{\%u}' is expanded to the user name.


\confopt{unixTransportPermission}{0777}

(Unix platforms only). Determines the octal permission bits for Unix
domain sockets. By default, all users can connect to a server, just as
with TCP.


\confopt{supportCurrent}{1}

omniORB 4.0 supports the \type{PortableServer::Current} interface that
provides thread context information to a servant. Supporting current
has a small but noticeable run-time overhead due to accessing thread
specific storage, so this option allows it to be turned off.


\confopt{objectTableSize}{0}

Hash table size of the Active Object Map. If this is zero, the ORB
uses a dynamically resized open hash table. This is normally the best
option, but it leads to less predictable performance since any
operation which adds or removes a table entry may trigger a resize. If
set to a non-zero value, the hash table has the specified number of
entries, and is never resized. Note that the hash table is open, so
this does not limit the number of active objects, just how efficiently
they can be located.


\confopt{poaHoldRequestTimeout}{0}

If a POA is put in the \code{HOLDING} state, calls to it will be timed
out after the specified number of milliseconds, by raising a
\code{TRANSIENT} exception. Zero means no timeout.


\confopt{supportBootstrapAgent}{0}

If set true, servers support the Sun bootstrap agent protocol.


\subsection{Main thread selection}

There is one server-side parameter that must be set with an API
function, rather than a normal configuration parameter:

\begin{cxxlisting}
namespace omniORB {
  void setMainThread();
};
\end{cxxlisting}

\noindent
POAs with the \code{MAIN\_THREAD} policy dispatch calls on the `main'
thread.  By default, omniORB assumes that the thread that initialised
the omnithread library is the `main' thread. To choose a different
thread, call this function from the desired `main' thread. The calling
thread must have an \code{omni\_thread} associated with it (i.e.\ it
must have been created by omnithread, or
\op{omni\_thread::create\_\dsc{}dummy} must have been called). If it
does not, the function throws \code{CORBA::\dsc{}INITIALIZE}.
                                                                  
Note that calls are only actually dispatched to the `main' thread if
\op{ORB::run} or \op{ORB::perform\_work} is called from that thread.




\section{GIOP and interoperability options}

These options control omniORB's use of GIOP, and cover some areas
where omniORB can work around buggy behaviour by other ORBs.


\confopt{maxGIOPVerson}{1.2}

Choose the maximum GIOP version the ORB should support. Valid values
are 1.0, 1.1 and 1.2.


\confopt{giopMaxMsgSize}{2097152}

The largest message, in bytes, that the ORB will send or receive, to
avoid resource starvation. If the limit is exceeded, a \code{MARSHAL}
exception is thrown. The size must be >= 8192.

\confopt{strictIIOP}{1}

If true, be strict about interpretation of the IIOP specification; if
false, permit some buggy behaviour to pass.


\confopt{lcdMode}{0}

If true, select `Lowest Common Denominator' mode. This disables
various IIOP and GIOP features that are known to cause problems with
some ORBs.


\confopt{tcAliasExpand}{0}

This flag is used to indicate whether TypeCodes associated with Anys
should have aliases removed. This functionality is included because
some ORBs will not recognise an Any containing a TypeCode with aliases
to be the same as the actual type contained in the Any. Note that
omniORB will always remove top-level aliases, but will not remove
aliases from TypeCodes that are members of other TypeCodes (e.g.\
TypeCodes for members of structs etc.), unless \code{tcAliasExpand} is
set to 1. There is a performance penalty when inserting into an Any if
\code{tcAliasExpand} is set to 1.


\confopt{useTypeCodeIndirections}{1}

TypeCode Indirections reduce the size of marshalled TypeCodes, and are
essential for recursive types, but some ORBs do not support them.
Setting this flag to false prevents the use of indirections (and,
therefore, recursive TypeCodes).


\confopt{acceptMisalignedTcIndirections}{0}

If true, try to fix a mis-aligned indirection in a typecode. This is
used to work around a bug in some versions of Visibroker's Java ORB.


\vspace{2\baselineskip}


\section{System Exception Handlers}

By default, all system exceptions that are raised during an operation
invocation, with the exception of some cases of
\code{CORBA::TRANSIENT}, are propagated to the application code. Some
applications may prefer to trap these exceptions within the proxy
objects so that the application logic does not have to deal with the
error condition. For example, when a \code{CORBA::COMM\_FAILURE} is
received, an application may just want to retry the invocation until
it finally succeeds. This approach is useful for objects that are
persistent and have idempotent operations.

omniORB provides a set of functions to install exception handlers.
Once they are installed, proxy objects will call these handlers when
the associated system exceptions are raised by the ORB runtime.
Handlers can be installed for \code{CORBA::\dsc{}TRANSIENT},
\code{CORBA::COMM\_FAILURE} and \code{CORBA::SystemException}.  This
last handler covers all system exceptions other than the two covered
by the first two handlers. An exception handler can be installed for
individual proxy objects, or it can be installed for all proxy objects
in the address space.


\subsection{Minor codes}

A new feature in omniORB 4.0 is extensive use of exception minor codes
to indicate the specific circumstances surrounding a system exception.
The file \file{include/omniORB4/minorCode.h} contains definitions of
all the minor codes used in omniORB, covering codes allocated in the
CORBA specification, and ones specific to omniORB. In compilers with
namespace support, the minor code constants appear in namespace
\code{omni}; otherwise they are in the global scope.

Applications can use minor codes to adjust their behaviour according
to the condition, e.g.

\begin{cxxlisting}
try {
  ...
}
catch (CORBA::TRANSIENT& ex) {
  if (ex.minor() == omni::TRANSIENT_ConnectFailed) {
    // retry with a different object reference...
  }
  else {
    // print an error message...
  }
}
\end{cxxlisting}



\subsection{CORBA::TRANSIENT handlers}

\code{TRANSIENT} exceptions can occur in many circumstances. One
circumstance is as follows:

\begin{enumerate}

\item The client invokes on an object reference.
\item The object replies with a \code{LOCATION\_FORWARD} message.
\item The client caches the new location and retries to the new location.
\item Time passes...
\item The client tries to invoke on the object again, using the
      cached, forwarded location. 
\item The attempt to contact the object fails.
\item The ORB runtime resets the location cache and throws a
      \code{TRANSIENT} exception with minor code
      \code{TRANSIENT\_FailedOnForwarded}.

\end{enumerate}

In this situation, the default \code{TRANSIENT} exception handler
retries the call, using the object's original location. If the retry
results in another \code{LOCATION\_FORWARD}, to the same or a
different location, and \emph{that} forwarded location fails
immediately, the \code{TRANSIENT} exception will occur again, and the
pattern will repeat. With repeated exceptions, the handler starts
adding delays before retries, with exponential back-off.

In all other circumstances, the default \code{TRANSIENT} handler just
passes the exception on to the caller.

Applications can override the default behaviour by installing their
own exception handler. The API to do so is summarised below:

\begin{cxxlisting}
namespace omniORB {
  
typedef CORBA::Boolean (*transientExceptionHandler_t)(void* cookie,
                                                CORBA::ULong n_retries,
                                                const CORBA::TRANSIENT& ex);

void installTransientExceptionHandler(void* cookie,
                                      transientExceptionHandler_t fn);

void installTransientExceptionHandler(CORBA::Object_ptr obj,
                                      void* cookie,
                                      transientExceptionHandler_t fn);
  
}
\end{cxxlisting}

The overloaded function \op{installTransientExceptionHandler} can be
used to install the exception handlers for \code{CORBA::TRANSIENT}.
Two forms are available: the first form installs an exception handler
for all object references except for those which have an exception
handler installed by the second form, which takes an additional
argument to identify the target object reference. The argument
\code{cookie} is an opaque pointer which will be passed on by the ORB
when it calls the exception handler.

An exception handler will be called by proxy objects with three
arguments. The \code{cookie} is the opaque pointer registered by
\op{installTransientExceptionHandler}. The argument \code{n\_retries}
is the number of times the proxy has called this handler for the same
invocation. The argument \code{ex} is the value of the exception
caught.  The exception handler is expected to do whatever is
appropriate and returns a boolean value. If the return value is
TRUE(1), the proxy object retries the operation. If the return value
is FALSE(0), the \code{CORBA::TRANSIENT} exception is propagated into
the application code.

The following sample code installs a simple exception handler for all
objects and for a specific object:

\begin{cxxlisting}
CORBA::Boolean my_transient_handler1 (void* cookie,
                                      CORBA::ULong retries,
                                      const CORBA::TRANSIENT& ex)
{
   cerr << "transient handler 1 called." << endl;
   return 1;           // retry immediately.
}
 
CORBA::Boolean my_transient_handler2 (void* cookie,
                                      CORBA::ULong retries,
                                      const CORBA::TRANSIENT& ex)
{
   cerr << "transient handler 2 called." << endl;
   return 1;           // retry immediately.
}


static Echo_ptr myobj;

void installhandlers()
{
   omniORB::installTransientExceptionHandler(0,my_transient_handler1);
   // All proxy objects will call my_transient_handler1 from now on.

   omniORB::installTransientExceptionHandler(myobj,0,my_transient_handler2);
   // The proxy object of myobj will call my_transient_handler2 from now on.
}
\end{cxxlisting}


\subsection{CORBA::COMM\_FAILURE}

If the ORB has successfully contacted an object at some point, and
access to it subsequently fails (and the condition for
\code{TRANSIENT} described above does not occur), the ORB raises a
\code{CORBA::COMM\_FAILURE} exception.

The default behaviour of the proxy objects is to propagate this
exception to the application. Applications can override the default
behaviour by installing their own exception handlers. The API to do so
is summarised below:

\begin{cxxlisting}
class omniORB {
public:

typedef CORBA::Boolean (*commFailureExceptionHandler_t)(void* cookie,
                                                CORBA::ULong n_retries,
                                                const CORBA::COMM_FAILURE& ex);

static void installCommFailureExceptionHandler(void* cookie,
                                             commFailureExceptionHandler_t fn);

static void installCommFailureExceptionHandler(CORBA::Object_ptr obj,
                                             void* cookie,
                                             commFailureExceptionHandler_t
                                             fn);
}
\end{cxxlisting}

The functions are equivalent to their counterparts for
\code{CORBA::TRANSIENT}.


\subsection{CORBA::SystemException}

If a system exception that is neither \code{CORBA::TRANISENT} nor
\code{CORBA::COMM\_FAILURE} occurs, the default behaviour of the proxy
objects is to propagate this exception to the application.
Applications can override the default behaviour by installing their
own exception handlers. The API to do so is summarised below:


\begin{cxxlisting}
class omniORB {
public:

typedef CORBA::Boolean (*systemExceptionHandler_t)(void* cookie,
                                            CORBA::ULong n_retries,
                                            const CORBA::SystemException& ex);

static void installSystemExceptionHandler(void* cookie,
                                          systemExceptionHandler_t fn);

static void installSystemExceptionHandler(CORBA::Object_ptr obj,
                                          void* cookie,
                                          systemExceptionHandler_t fn);
}
\end{cxxlisting}

The functions are equivalent to their counterparts for
\code{CORBA::TRANSIENT}.



\section{Location forwarding}
\label{sec:locationForward}

Any CORBA operation invocation can return a \code{LOCATION\_FORWARD}
message to the caller, indicating that it should retry the invocation
on a new object reference. The standard allows ServantManagers to
trigger \code{LOCATION\_FORWARD}s by raising the
\code{PortableServer::ForwardRequest} exception, but it does not
provide a similar mechanism for normal servants. omniORB provides the
\code{omniORB::\dsc{}LOCATION\_FORWARD} exception for this purpose. It
can be thrown by any operation implementation.

\begin{cxxlisting}
namespace omniORB {
  class LOCATION_FORWARD {
  public:
    LOCATION_FORWARD(CORBA::Object_ptr objref);
  };
};
\end{cxxlisting}

\noindent The exception object consumes the object reference it is
passed.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{The IDL compiler}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:omniidl}

omniORB's IDL compiler is called omniidl. It consists of a generic
front-end parser written in C++, and a number of back-ends written in
Python. omniidl is very strict about IDL validity, so you may find
that it reports errors in IDL which compiles fine with other IDL
compilers.

The general form of an omniidl command line is:

\begin{quote} % Not the clearest bit of mark-up ever... :-)
\cmdline{omniidl }[\textit{options}]\cmdline{ -b}%
<\textit{back-end}>\cmdline{ }[\textit{back-end options}]%
\cmdline{ }<\textit{file 1}>\cmdline{ }<\textit{file 2}>%
\cmdline{ }\dots
\end{quote}

\section{Common options}

The following options are common to all back-ends:

\begin{tabbing}
\cmdline{-D}\textit{name}[\cmdline{=}\textit{value}]~~ \= \kill
%HEVEA\\

\cmdline{-b}\textit{back-end}
     \> Run the specified back-end. For the C++ ORB, use \cmdline{-bcxx}.\\

\cmdline{-D}\textit{name}[\cmdline{=}\textit{value}]
     \> Define \textit{name} for the preprocessor.\\

\cmdline{-U}\textit{name}
     \> Undefine \textit{name} for the preprocessor.\\

\cmdline{-I}\textit{dir}
     \> Include \textit{dir} in the preprocessor search path.\\

\cmdline{-E}
     \> Only run the preprocessor, sending its output to stdout.\\

\cmdline{-Y}\textit{cmd}
     \> Use \textit{cmd} as the preprocessor, rather than the normal C
        preprocessor.\\

\cmdline{-N}
     \> Do not run the preprocessor.\\

\cmdline{-T}
     \> Use a temporary file, not a pipe, for preprocessor output.\\

\cmdline{-Wp}\textit{arg}[,\textit{arg}\dots]
     \> Send arguments to the preprocessor.\\

\cmdline{-Wb}\textit{arg}[,\textit{arg}\dots]
     \> Send arguments to the back-end.\\

\cmdline{-nf}
     \> Do not warn about unresolved forward declarations.\\

\cmdline{-k}
     \> Keep comments after declarations, to be used by some back-ends.\\

\cmdline{-K}
     \> Keep comments before declarations, to be used by some back-ends.\\

\cmdline{-C}\textit{dir}
     \> Change directory to \textit{dir} before writing output files.\\

\cmdline{-d}
     \> Dump the parsed IDL then exit, without running a back-end.\\

\cmdline{-p}\textit{dir}
     \> Use \textit{dir} as a path to find omniidl back-ends.\\

\cmdline{-V}
     \> Print version information then exit.\\

\cmdline{-u}
     \> Print usage information.\\

\cmdline{-v}
     \> Verbose: trace compilation stages.\\

\end{tabbing}

\noindent Most of these options are self explanatory, but some are not
so obvious.

\subsection{Preprocessor interactions}

IDL is processed by the C preprocessor before omniidl parses it.
Unlike the old IDL compiler, which used different C preprocessors on
different platforms, omniidl always uses the GNU C preprocessor (which
it builds with the name omnicpp). The \cmdline{-D}, \cmdline{-U}, and
\cmdline{-I} options are just sent to the preprocessor. Note that the
current directory is not on the include search path by default---use
`\cmdline{-I.}' for that. The \cmdline{-Y} option can be used to
specify a different preprocessor to omnicpp. Beware that line
directives inserted by other preprocessors are likely to confuse
omniidl.

\subsubsection{Windows 9x}

The output from the C preprocessor is normally fed to the omniidl
parser through a pipe. On some Windows 98 machines (but not all!)  the
pipe does not work, and the preprocessor output is echoed to the
screen. When this happens, the omniidl parser sees an empty file, and
produces useless stub files with strange long names. To avoid the
problem, use the `\cmdline{-T}' option to create a temporary file
between the two stages.


\subsection{Forward-declared interfaces}

If you have an IDL file like:

\begin{idllisting}
interface I;
interface J {
  attribute I the_I;
};
\end{idllisting}

\noindent then omniidl will normally issue a warning:

{\small
\begin{verbatim}
  test.idl:1: Warning: Forward declared interface `I' was never
  fully defined
\end{verbatim}
}

\noindent It is illegal to declare such IDL in isolation, but it
\emph{is} valid to define interface \intf{I} in a separate file. If
you have a lot of IDL with this sort of construct, you will drown
under the warning messages. Use the \cmdline{-nf} option to suppress
them.


\subsection{Comments}

By default, omniidl discards comments in the input IDL. However, with
the \cmdline{-k} and \cmdline{-K} options, it preserves the comments
for use by the back-ends. The C++ back-end ignores this information,
but it is relatively easy to write new back-ends which \emph{do} make
use of comments.

The two different options relate to how comments are attached to
declarations within the IDL. Given IDL like:

\begin{idllisting}
interface I {
  void op1();
  // A comment
  void op2();
};
\end{idllisting}

\noindent the \cmdline{-k} flag will attach the comment to \op{op1};
the \cmdline{-K} flag will attach it to \op{op2}.



\section{C++ back-end options}

When you specify the C++ back-end (with \cmdline{-bcxx}), the
following \cmdline{-Wb} options are available. Note that the
\cmdline{-Wb} options must be specified \emph{after} the
\cmdline{-bcxx} option, so omniidl knows which back-end to give the
arguments to.

\begin{tabbing}
\cmdline{-Wbsplice-modules}~~ \= \kill
%HEVEA\\

\cmdline{-Wbh=}\textit{suffix}
     \> Use \textit{suffix} for generated header files. Default
        `\file{.hh}'.\\

\cmdline{-Wbs=}\textit{suffix}
     \> Use \textit{suffix} for generated stub files. Default
        `\file{SK.cc}.'\\

\cmdline{-Wbd=}\textit{suffix}
     \> Use \textit{suffix} for generated dynamic files. Default
        `\file{DynSK.cc}.'\\

\cmdline{-Wba}
     \> Generate stubs for TypeCode and Any.\\

\cmdline{-Wbinline}
     \> Output stubs for \code{\#include}d IDL files in line with the
        main file.\\

\cmdline{-Wbtp}
     \> Generate `tie' implementation skeletons.\\

\cmdline{-Wbtf}
     \> Generate flattened `tie' implementation skeletons.\\

\cmdline{-Wbsplice-modules}
     \> Splice together multiply-opened modules into one.\\

\cmdline{-Wbexample}
     \> Generate example implementation code.\\

\cmdline{-WbF}
     \> Generate code fragments (for experts only).\\

\cmdline{-WbBOA}
     \> Generate BOA compatible skeletons.\\

\cmdline{-Wbold}
     \> Generate old CORBA 2.1 signatures for skeletons.\\

\cmdline{-Wbold\_prefix}
     \> Map C++ reserved words with prefix `\code{\_}' rather than
        `\code{\_cxx\_}'.\\

\cmdline{-Wbkeep\_inc\_path}
     \> Preserve IDL `\code{\#include}' paths in generated
       	`\code{\#include}' directives.\\

\cmdline{-Wbuse\_quotes}
     \> Use quotes in `\code{\#include}' directives 
        (e.g.\ \code{"foo"} rather than \code{<foo>}.)\\



\end{tabbing}

\noindent Again, most of these are self-explanatory.


\subsection{Stub / skeleton files}

By default, omniidl separates the normal stub and skeleton file (the
\file{SK.cc} file) from the `dynamic' stubs (the \file{DynSK.cc}
file), so applications that do not need support for Any and TypeCode
for a particular IDL file do not waste space with unnecessary
definitions. New in omniORB 4.0, it is possible to output both the
normal stubs \emph{and} the dynamic stubs to a single file, by simply
specifying the same extension for both files. This command places
both the normal stubs and the dynamic stubs in \file{aSK.cc}:

\begin{quote}
\cmdline{omniidl -bcxx -Wba -Wbd=SK.cc a.idl}
\end{quote}



\subsection{Module splicing}

On C++ compilers without namespace support, IDL modules map to C++
classes, and so cannot be reopened. For some IDL, it is possible to
`splice' reopened modules on to the first occurrence of the module, so
all module definitions are in a single class. It is possible in this
sort of situation:

\begin{idllisting}
module M1 {
  interface I {};
};
module M2 {
  interface J {
    attribute M1::I ok;
  };
};
module M1 {
  interface K {
    attribute I still_ok;
  };
};
\end{idllisting}

\noindent but not if there are cross-module dependencies:

\begin{idllisting}
module M1 {
  interface I {};
};
module M2 {
  interface J {
    attribute M1::I ok;
  };
};
module M1 {
  interface K {
    attribute M2::J oh_dear;
  };
};
\end{idllisting}

\noindent In both of these cases, the \cmdline{-Wbsplice-modules}
option causes omniidl to put all of the definitions for module
\intf{M1} into a single C++ class. For the first case, this will work
fine. For the second case, class \type{M1::K} will contain a reference
to \type{M2::J}, which has not yet been defined; the C++ compiler will
complain.


\subsection{Flattened tie classes}

Another problem with mapping IDL modules to C++ classes arises with
tie templates. The C++ mapping says that for the interface
\intf{M::I}, the C++ tie template class should be named
\type{POA\_M::I\_tie}. However, since template classes cannot be
declared inside other classes, this naming scheme cannot be used with
compilers without namespace support.

The standard solution is to produce `flattened' tie class names, using
the \cmdline{-Wbtf} command line argument. With that flag, the
template class is declared at global scope with the name
\type{POA\_M\_I\_tie}. i.e.\ all occurrences of `\type{::}' are
replaced by `\type{\_}'.


\subsection{Generating example implementations}

If you use the \cmdline{-Wbexample} flag, omniidl will generate an
example implementation file as well as the stubs and skeletons. For
IDL file \file{foo.idl}, the example code is written to
\file{foo_i.cc}. The example file contains class and method
declarations for the operations of all interfaces in the IDL file,
along with a \op{main} function which creates an instance of each
object. You still have to fill in the operation implementations, of
course.



\section{Examples}

Generate the C++ headers and stubs for a file \file{a.idl}:

\begin{quote}
\cmdline{omniidl -bcxx a.idl}
\end{quote}

\noindent Generate with Any support:

\begin{quote}
\cmdline{omniidl -bcxx -Wba a.idl}
\end{quote}

\noindent As above, but also generate Python stubs (assuming omniORBpy
is installed):

\begin{quote}
\cmdline{omniidl -bcxx -Wba -bpython a.idl}
\end{quote}

\noindent Just check the IDL files for validity, generating no output:

\begin{quote}
\cmdline{omniidl a.idl b.idl}
\end{quote}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Interoperable Naming Service}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:ins}

omniORB 4.0 supports the Interoperable Naming Service (INS). The
following is a summary of its facilities.

\section{Object URIs}

As well as accepting IOR-format strings, \op{ORB::string\_to\_object}
also supports two Uniform Resource Identifier (URI)~\cite{rfc2396}
formats, which can be used to specify objects in a convenient
human-readable form. IOR-format strings are now also considered URIs.

\subsection{corbaloc}

\corbauri{corbaloc} URIs allow you to specify object references which
can be contacted by IIOP, or found through
\op{ORB::resolve\_initial\_references}. To specify an IIOP object
reference, you use a URI of the form:

\begin{quote}
\corbauri{corbaloc:iiop:}<\textit{host}>\corbauri{:}<\textit{port}>%
\corbauri{/}<\textit{object key}>
\end{quote}

\noindent for example:

\begin{quote}
\corbauri{corbaloc:iiop:myhost.example.com:1234/MyObjectKey}
\end{quote}

\noindent which specifies an object with key `MyObjectKey' within a
process running on myhost.example.com listening on port 1234. Object
keys containing non-ASCII characters can use the standard URI \%
escapes:

\begin{quote}
\corbauri{corbaloc:iiop:myhost.example.com:1234/My}%
\texttt{\%}%
\corbauri{efObjectKey}
\end{quote}

\noindent denotes an object key with the value 239 (hex ef) in the
third octet.

The protocol name `\corbauri{iiop}' can be abbreviated to the empty
string, so the original URI can be written:

\begin{quote}
\corbauri{corbaloc::myhost.example.com:1234/MyObjectKey}
\end{quote}

\noindent The IANA has assigned port number 2809\footnote{Not 2089 as
printed in \cite{inschapters}!} for use by \corbauri{corbaloc}, so if
the server is listening on that port, you can leave the port number
out.  The following two URIs refer to the same object:

\begin{quote}
\corbauri{corbaloc::myhost.example.com:2809/MyObjectKey}\\
\corbauri{corbaloc::myhost.example.com/MyObjectKey}
\end{quote}

\noindent You can specify an object which is available at more than
one location by separating the locations with commas:

\begin{quote}
\corbauri{corbaloc::myhost.example.com,:localhost:1234/MyObjectKey}
\end{quote}

\noindent Note that you must restate the protocol for each address,
hence the `\corbauri{:}' before `\corbauri{localhost}'. It could
equally have been written `\corbauri{iiop:localhost}'.

You can also specify an IIOP version number:

\begin{quote}
\corbauri{corbaloc::1.2@myhost.example.com/MyObjectKey}
\end{quote}

Specifying IIOP versions above 1.0 is slightly risky since higher
versions make use of various information stored in IORs that is not
present in a corbaloc URI. It is generally best to contact initial
corbaloc objects with IIOP 1.0, and rely on higher versions for all
other object references.


\vspace{\baselineskip}

\noindent Alternatively, to use \op{resolve\_initial\_references}, you
use a URI of the form:

\begin{quote}
\corbauri{corbaloc:rir:/NameService}
\end{quote}


\subsection{corbaname}
\label{sec:corbaname}

\corbauri{corbaname} URIs cause \op{string\_to\_object} to look-up a
name in a CORBA Naming service. They are an extension of the
\corbauri{corbaloc} syntax:

\begin{quote}
\corbauri{corbaname:}%
<\textit{corbaloc location}>%
\corbauri{/}%
<\textit{object key}>%
\corbauri{#}%
<\textit{stringified name}>
\end{quote}

\noindent for example:

\begin{quote}
\corbauri{corbaname::myhost/NameService#project/example/echo.obj}\\
\corbauri{corbaname:rir:/NameService#project/example/echo.obj}
\end{quote}

\noindent The object found with the \corbauri{corbaloc}-style portion
must be of type \intf{CosNaming::\dsc{}NamingContext}, or something
derived from it. If the object key (or \corbauri{rir} name) is
`\corbauri{NameService}', it can be left out:

\begin{quote}
\corbauri{corbaname::myhost#project/example/echo.obj}\\
\corbauri{corbaname:rir:#project/example/echo.obj}
\end{quote}

\noindent The stringified name portion can also be left out, in which
case the URI denotes the \intf{CosNaming::NamingContext} which would
have been used for a look-up:

\begin{quote}
\corbauri{corbaname::myhost.example.com}\\
\corbauri{corbaname:rir:}
\end{quote}

\noindent The first of these examples is the easiest way of specifying
the location of a naming service.


\section{Configuring resolve\_initial\_references}
\label{sec:insargs}

The INS specified two standard command line arguments which provide a
portable way of configuring \op{ORB::resolve\_initial\_references}:


\subsection{ORBInitRef}

\cmdline{-ORBInitRef} takes an argument of the form
<\textit{ObjectId}>\cmdline{=}<\textit{ObjectURI}>. So, for example,
with command line arguments of:

\begin{quote}
\cmdline{-ORBInitRef NameService=corbaname::myhost.example.com}
\end{quote}

\noindent \code{resolve\_initial\_references("NameService")} will
return a reference to the object with key `NameService' available on
myhost.example.com, port 2809. Since IOR-format strings are considered
URIs, you can also say things like:

\begin{quote}
\cmdline{-ORBInitRef NameService=IOR:00ff...}
\end{quote}


\subsection{ORBDefaultInitRef}

\cmdline{-ORBDefaultInitRef} provides a prefix string which is used to
resolve otherwise unknown names. When
\op{resolve\_initial\_references} is unable to resolve a name which
has been specifically configured (with \cmdline{-ORBInitRef}), it
constructs a string consisting of the default prefix, a `\corbauri{/}'
character, and the name requested.  The string is then fed to
\op{string\_to\_object}. So, for example, with a command line of:

\begin{quote}
\cmdline{-ORBDefaultInitRef corbaloc::myhost.example.com}
\end{quote}

\noindent a call to \code{resolve\_initial\_references("MyService")}
will return the object reference denoted by
`\corbauri{corbaloc::myhost.example.com/MyService}'.

Similarly, a \corbauri{corbaname} prefix can be used to cause
look-ups in the naming service. Note, however, that since a
`\corbauri{/}' character is always added to the prefix, it is
impossible to specify a look-up in the root context of the naming
service---you have to use a sub-context, like:

\begin{quote}
\cmdline{-ORBDefaultInitRef corbaname::myhost.example.com\#services}
\end{quote}



\section{omniNames}

\subsection{NamingContextExt}

omniNames supports the extended \intf{CosNaming::NamingContextExt}
interface:

\begin{idllisting}
module CosNaming {
  interface NamingContextExt : NamingContext {
    typedef string StringName;
    typedef string Address;
    typedef string URLString;

    StringName  to_string(in Name n)        raises(InvalidName);
    Name        to_name  (in StringName sn) raises(InvalidName);

    exception InvalidAddress {};

    URLString   to_url(in Address addr, in StringName sn)
      raises(InvalidAddress, InvalidName);

    Object      resolve_str(in StringName n)
      raises(NotFound, CannotProceed, InvalidName, AlreadyBound);
  };
};
\end{idllisting}

\op{to\_string} and \op{to\_name} convert from \type{CosNaming::Name}
sequences to flattened strings and vice-versa.  Note that calling
these operations involves remote calls to the naming service, so they
are not particularly efficient. You can use the omniORB specific local
\op{omniURI::nameToString} and \op{omniURI::\dsc{}stringToName}
functions instead.

A \type{CosNaming::Name} is stringified by separating name components
with `\texttt{/}' characters. The \code{kind} and \code{id} fields of
each component are separated by `\texttt{.}' characters. If the
\code{kind} field is empty, the representation has no trailing
`\texttt{.}'; if the \code{id} is empty, the representation starts
with a `\texttt{.}' character; if both \texttt{id} and \texttt{kind}
are empty, the representation is just a `\texttt{.}'. The backslash
`\texttt{\textbackslash}' is used to escape the meaning of
`\texttt{/}', `\texttt{.}' and `\texttt{\textbackslash}' itself.

\op{to\_url} takes a \corbauri{corbaloc} style address and key string
(but without the \corbauri{corbaloc:} part), and a stringified name,
and returns a \corbauri{corbaname} URI (incorrectly called a URL)
string, having properly escaped any invalid characters. The
specification does not make it clear whether or not the address string
should also be escaped by the operation; omniORB does not escape
it. For this reason, it is best to avoid calling \op{to\_url} if the
address part contains escapable characters.  omniORB provides the
equivalent local function \op{omniURI::addrAndNameToURI}.

\op{resolve\_str} is equivalent to calling \op{to\_name} followed by
the inherited \op{resolve} operation. There are no string-based
equivalents of the various bind operations.


\subsection{Use with corbaname}

To make it easy to use omniNames with \corbauri{corbaname} URIs, it
starts with the default port of 2809, and an object key of
`\texttt{NameService}' for the root naming context.


\section{omniMapper}
\hyphenation{omni-Mapper}

omniMapper is a simple daemon which listens on port 2809 (or any other
port), and redirects IIOP requests for configured object keys to
associated persistent IORs. It can be used to make a naming service
(even an old non-INS aware version of omniNames or other ORB's naming
service) appear on port 2809 with the object key
`\texttt{NameService}'. The same goes for any other service you may
wish to specify, such as an interface repository. omniMapper is
started with a command line of:

\begin{quote}
\cmdline{omniMapper [-port }<\textit{port}>%
\cmdline{] [-config }<\textit{config file}>%
\cmdline{] [-v]}
\end{quote}

\noindent The \cmdline{-port} option allows you to choose a port other
than 2809 to listen on. The \cmdline{-config} option specifies a
location for the configuration file. The default name is
\file{/etc/omniMapper.cfg}, or
%BEGIN LATEX
\file{C:\omniMapper.cfg}
%END LATEX
%HEVEA\verb|C:\omniMapper.cfg|
on Windows. omniMapper does not normally print anything; the
\cmdline{-v} option makes it verbose so it prints configuration
information and a record of the redirections it makes, to standard
output.

The configuration file is very simple. Each line contains a string to
be used as an object key, some white space, and an IOR (or any valid
URI) that it will redirect that object key to. Comments should be
prefixed with a `\texttt{\#}' character. For example:

\begin{quote}
\begin{verbatim}
# Example omniMapper.cfg
NameService         IOR:000f...
InterfaceRepository IOR:0100...
\end{verbatim}
\end{quote}

omniMapper can either be run on a single machine, in much the same way
as omniNames, or it can be run on \emph{every} machine, with a common
configuration file. That way, each machine's omniORB configuration
file could contain the line:

\begin{quote}
\begin{verbatim}
ORBDefaultInitRef corbaloc::localhost
\end{verbatim}
\end{quote}



\section{Creating objects with simple object keys}

In normal use, omniORB creates object keys containing various
information including POA names and various non-ASCII characters.
Since object keys are supposed to be opaque, this is not usually a
problem. The INS breaks this opacity and requires servers to create
objects with human-friendly keys.

If you wish to make your objects available with human-friendly URIs,
there are two options. The first is to use omniMapper as described
above, in conjunction with a \code{PERSISTENT} POA. The second is to
create objects with the required keys yourself. You do this with a
special POA with the name `\texttt{omniINSPOA}', acquired from
\op{resolve\_initial\_references}. This POA has the \code{USER\_ID}
and \code{PERSISTENT} policies, and the special property that the
object keys it creates contain only the object ids given to the POA,
and no other data. It is a normal POA in all other respects, so you
can activate/deactivate it, create children, and so on, in the usual
way.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Interface Type Checking}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{ch_intf}

This chapter describes the mechanism used by omniORB to ensure type
safety when object references are exchanged across the network. This
mechanism is handled completely within the ORB. There is no
programming interface visible at the application level. However, for
the sake of diagnosing the problem when there is a type violation, it
is useful to understand the underlying mechanism in order to interpret
the error conditions reported by the ORB.

\section{Introduction}

In GIOP/IIOP, an object reference is encoded as an Interoperable
Object Reference (IOR) when it is sent across a network connection.
The IOR contains a Repository ID (RepoId) and one or more
communication profiles. The communication profiles describe where and
how the object can be contacted. The RepoId is a string which uniquely
identifies the IDL interface of the object.

Unless the \code{ID} pragma is specified in the IDL, the ORB generates
the RepoId string in the so-called OMG IDL Format\footnote{For further
details of the repository ID formats, see section 10.6 in the CORBA
2.3 specification.}. For instance, the RepoId for the \intf{Echo}
interface used in the examples of chapter~\ref{chap:basic} is
\texttt{IDL:Echo:1.0}.

When interface inheritance is used in the IDL, the ORB always sends the
RepoId of the most derived interface. For example:

\begin{idllisting}
   // IDL
   interface A {
     ...
   };
   interface B : A {
     ...
   };
   interface C {
      void op(in A arg);
   };
\end{idllisting}

\begin{cxxlisting}
   // C++
   C_ptr server;
   B_ptr objB;
   A_ptr objA = objB;
   server->op(objA);  // Send B as A
\end{cxxlisting}

In the example, the operation \op{C::op} accepts an object reference
of type \type{A}. The real type of the reference passed to \op{C::op}
is \type{B}, which inherits from \type{A}. In this case, the RepoId of
\type{B}, and not that of \type{A}, is sent across the network.

The GIOP/IIOP specification allows an ORB to send a null string in the
RepoId field of an IOR. It is up to the receiving end to work out the
real type of the object. omniORB never sends out null strings as
RepoId, but it may receive null RepoIds from other ORBs. In that case,
it will use the mechanism described below to ensure type safety.


\section{Interface Inheritance}

When the ORB receives an IOR of interface type B when it expects the
type to be A, it must find out if B inherits from A. When the ORB has
no local knowledge of the type B, it must work out the type of B
dynamically.

The CORBA specification defines an Interface Repository (IR) from
which IDL interfaces can be queried dynamically. In the above
situation, the ORB could contact the IR to find out the type of B.
However, this approach assumes that an IR is always available and
contains the up-to-date information of all the interfaces used in the
domain. This assumption may not be valid in many applications.

An alternative is to use the \op{\_is\_a} operation to work out the
actual type of an object. This approach is simpler and more robust
than the previous one because no 3rd party is involved, so this is
what omniORB does.

\begin{cxxlisting}
class Object{
    CORBA::Boolean _is_a(const char* type_id);
};
\end{cxxlisting}

The \op{\_is\_a} operation is part of the \intf{CORBA::Object}
interface and must be implemented by every object. The input argument
is a RepoId. The function returns true(1) if the object is really an
instance of that type, including if that type is a base type of the
most derived type of that object.

In the situation above, the ORB would invoke the \op{\_is\_a}
operation on the object and ask if the object is of type A
\emph{before} it processes any application invocation on the object.

Notice that the \op{\_is\_a} call is \emph{not} performed when the IOR
is unmarshalled. It is performed just prior to the first application
invocation on the object. This leads to some interesting failure modes
if B reports that it is not an A. Consider the following example:

\begin{idllisting}
// IDL
interface A { ... };
interface B : A { ... };
interface D { ... };
interface C {
  A      op1();
  Object op2();
};
\end{idllisting}

\lstset{labelstep=1,gobble=4}
\begin{cxxlisting}
 1  // C++
 2  C_ptr objC;
 3  A_ptr objA;
 4  CORBA::Object_ptr objR;
 5
 6  objA =  objC->op1();
 7  (void) objA->_non_existent();
 8
 9  objR =  objC->op2();
10  objA =  A::_narrow(objR);
\end{cxxlisting}
\lstset{labelstep=0,gobble=0}

\noindent If the stubs of A,B,C,D are linked into the executable and:

\begin{description}
\item[Case 1] \op{C::op1} and \op{C::op2} return a B. Lines 6--10
complete successfully. The remote object is only contacted at line 7.

\item[Case 2] \op{C::op1} and \op{C::op2} return a D. This condition
only occurs if the runtime of the remote end is buggy. The ORB raises
a \code{CORBA::MARSHAL} exception at line 1 because it knows it has
received an interface of the wrong type.
\end{description}

\noindent If only the stubs of A are linked into the executable and:

\begin{description}
\item[Case 1] \op{C::op1} and \op{C::op2} return a B. Lines 6--10
complete successfully. When lines 7 and 10 are executed, the object is
contacted to ask if it is an A.

\item[Case 2] \op{C::op1} and \op{C::op2} return a D. This condition
only occurs if the runtime of the remote end is buggy. Line 6
completes and no exception is raised. At line 7, the object is
contacted to ask if it is an A. If the answer is no, a
\code{CORBA::INV\_OBJREF} exception is raised. The application will
also see a \code{CORBA::INV\_OBJREF} at line 10.
\end{description}









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Connection and Thread Management}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:connections}


This chapter describes how omniORB manages threads and network
connections.

\section{Background}

In CORBA, the ORB is the `middleware' that allows a client to invoke
an operation on an object without regard to its implementation or
location. In order to invoke an operation on an object, a client needs
to `bind' to the object by acquiring its object reference. Such a
reference may be obtained as the result of an operation on another
object (such as a naming service or factory object) or by conversion
from a stringified representation. If the object is in a different
address space, the binding process involves the ORB building a proxy
object in the client's address space. The ORB arranges for invocations
on the proxy object to be transparently mapped to equivalent
invocations on the implementation object.

For the sake of interoperability, CORBA mandates that all ORBs should
support IIOP as the means to communicate remote invocations over a
TCP/IP connection. IIOP is usually\footnote{GIOP 1.2 supports
`bidirectional GIOP', which permits the r\^oles to be reversed.}
asymmetric with respect to the roles of the parties at the two ends of
a connection. At one end is the client which can only initiate remote
invocations. At the other end is the server which can only receive
remote invocations.

Notice that in CORBA, as in most distributed systems, remote bindings
are established implicitly without application intervention. This
provides the illusion that all objects are local, a property known as
`location transparency'. CORBA does not specify when such bindings
should be established or how they should be multiplexed over the
underlying network connections. Instead, ORBs are free to implement
implicit binding by a variety of means.

The rest of this chapter describes how omniORB manages network
connections and the programming interface to fine tune the management
policy.


\section{The model}

omniORB is designed from the ground up to be fully multi-threaded. The
objective is to maximise the degree of concurrency and at the same
time eliminate any unnecessary thread overhead. Another objective is
to minimise the interference by the activities of other threads on the
progress of a remote invocation. In other words, thread `cross-talk'
should be minimised within the ORB. To achieve these objectives, the
degree of multiplexing at every level is kept to a minimum by default.

Minimising multiplexing works well when the ORB is relatively lightly
loaded. However, when the ORB is under heavy load, it can sometimes be
beneficial to conserve operating system resources such as threads and
network connections by multiplexing at the ORB level. omniORB has
various options that control its multiplexing behaviour.


\section{Client side behaviour}

On the client side of a connection, the thread that invokes on a proxy
object drives the GIOP protocol directly and blocks on the connection
to receive the reply. The first time the client makes a call to a
particular address space, the ORB opens a suitable connection to the
remote address space (based on the client transport rule as described
in section~\ref{sec:clientRule}). After the reply has been received,
the ORB caches the open network connection, ready for use by another
call.

If two (or more) threads in a multi-threaded client attempt to contact
the same address space simultaneously, there are two different ways to
proceed. The default way is to open another network connection to the
server. This means that neither the client or server ORB has to
perform any multiplexing on the network connections---multiplexing is
performed by the operating system, which has to deal with multiplexing
anyway. The second possibility is for the client to multiplex the
concurrent requests on a single network connection. This conserves
operating system resources (network connections), but means that both
the client and server have to deal with multiplexing issues
themselves.

In the default one call per connection mode, there is a limit to the
number of concurrent connections that are opened, set with the
\code{maxGIOPConnection\dsc{}PerServer} parameter. To tell the ORB to
multiplex calls on a single connection, set the
\code{oneCallPerConnection} parameter to zero.

Note that some server-side ORBs, including omniORB versions before
version 4.0, are unable to deal with concurrent calls multiplexed on a
single connection, so they serialise the calls. It is usually best to
keep to the default mode of opening multiple connections.



\section{Server side behaviour}

The server side has two primary modes of operation: thread per
connection and thread pooling. It is able to dynamically transition
between the two modes, and it supports a hybrid scheme that behaves
mostly like thread pooling, but has the same fast turn-around for
sequences of calls as thread per connection.

\subsection{Thread per connection mode}

In thread per connection mode (the default, and the only option in
omniORB versions before 4.0), each connection has a single thread
dedicated to it. The thread blocks waiting for a request. When it
receives one, it unmarshals the arguments, makes the up-call to the
application code, marshals the reply, and goes back to watching the
connection. There is thus no thread switching along the call chain,
meaning the call is very efficient.

As explained above, a client can choose to multiplex multiple
concurrent calls on a single connection, so once the server has
received the request, and just before it makes the call into
application code, it marks the connection as `selectable', meaning
that another thread should watch it to see if any other requests
arrive. If they do, extra threads are dispatched to handle the
concurrent calls. GIOP 1.2 actually allows the argument data for
multiple calls to be interleaved on a connection, so the unmarshalling
code has to handle that too. As soon as any multiplexing occurs on the
connection, the aim of removing thread switching cannot be met, and
there is inevitable inefficiency due to thread switching.

The \code{maxServerThreadPerConnection} parameter can be set to limit
the number of threads that can be allocated to a single connection
containing concurrent calls. Setting the parameter to 1 mimics the
behaviour of omniORB versions before 4.0, that did not support
multiplexed calls.


\subsection{Thread pool mode}
\label{sec:watchConn}

In thread pool mode, selected by setting the
\code{threadPerConnectionPolicy} parameter to zero, a single thread
watches all incoming connections. When a call arrives on one of them,
a thread is chosen from a pool of threads, and set to work
unmarshalling the arguments and performing the up-call. There is
therefore at least one thread switch for each call.

The thread pool is not pre-initialised. Instead, threads are started
on demand, and idle threads are stopped after a period of inactivity.
The maximum number of threads that can be started in the pool is
selected with the \code{maxServerThreadPool\dsc{}Size} parameter. The
default is 100.

A common pattern in CORBA applications is for a client to make several
calls to a single object in quick succession. To handle this situation
most efficiently, the default behaviour is to not return a thread to
the pool immediately after a call is finished. Instead, it is set to
watch the connection it has just served for a short while, mimicking
the behaviour in thread per connection mode. If a new call comes in
during the watching period, the call is dispatched without any thread
switching, just as in thread per connection mode. Of course, if the
server is supporting a very large number of connections (more than the
size of the thread pool), this policy can delay a call coming from
another connection. If the \code{threadPoolWatch\dsc{}Connection}
parameter is set to zero, connection watching is disabled and threads
return to the pool immediately after finishing a single request.


\subsection{Policy transition}

If the server is dealing with a relatively small number of
connections, it is most efficient to use thread per connection mode.
If the number of connections becomes too large, however, operating
system limits on the number of threads may cause a significant
slowdown, or even prevent the acceptance of new connections
altogether.

To give the most efficient response in all circumstances, omniORB
allows a server to start in thread per connection mode, and transition
to thread pooling if many connections arrive. This is controlled with
the \code{threadPerConnection\dsc{}UpperLimit} and
\code{threadPerConnectionLowerLimit} parameters. The former must
always be larger than the latter. The upper limit chooses the number
of connections at which time the ORB transitions to thread pool mode;
the lower limit selects the point at which the transition back to
thread per connection is made.

For example, setting the upper limit to 50 and the lower limit to 30
would mean that the first 49 connections would receive dedicated
threads. The 50th to arrive would trigger thread pooling. All future
connections to arrive would make use of threads from the pool. Note
that the existing dedicated threads continue to service their
connections until the connections are closed. If the number of
connections falls below 30, thread per connection is reactivated and
new connections receive their own dedicated threads (up to the limit
of 50 again). Once again, existing connections in thread pool mode
stay in that mode until they are closed.


\section{Idle connection shutdown}
\label{sec:connShutdown}

It is wasteful to leave a connection open when it has been left unused
for a considerable time. Too many idle connections could block out new
connections when it runs out of spare communication channels. For
example, most Unix platforms have a limit on the number of file
handles a process can open. 64 is the usual default limit. The value
can be increased to a maximum of a thousand or more by changing the
`ulimit' in the shell.

Every so often, a thread scans all open connections to see which are
idle. The scanning period (in seconds) is set with the
\code{scanGranularity} parameter. The default is 5 seconds.

Outgoing connections (initiated by clients) and incoming connections
(initiated by servers) have separate idle timeouts.  The timeouts are
set with the \code{outConScan\dsc{}Period} and \code{inConScanPeriod}
parameters respectively. The values are in seconds, and must be a
multiple of the scan granularity.


\subsection{Interoperability Considerations}

The IIOP specification allows both the client and the server to
shutdown a connection unilaterally. When one end is about to shutdown
a connection, it should send a CloseConnection message to the other
end. It should also make sure that the message will reach the other
end before it proceeds to shutdown the connection.

The client should distinguish between an orderly and an abnormal
connection shutdown. When a client receives a CloseConnection message
before the connection is closed, the condition is an orderly shutdown.
If the message is not received, the condition is an abnormal shutdown.
In an abnormal shutdown, the ORB should raise a \code{COMM\_FAILURE}
exception whereas in an orderly shutdown, the ORB should \emph{not}
raise an exception and should try to re-establish a new connection
transparently.

omniORB implements these semantics completely. However, it is known
that some ORBs are not (yet) able to distinguish between an orderly
and an abnormal shutdown. Usually this is manifested as the client in
these ORBs seeing a \code{COMM\_FAILURE} occasionally when connected
to an omniORB server. The work-around is either to catch the exception
in the application code and retry, or to turn off the idle connection
shutdown inside the omniORB server.



\section{Transports and endpoints}

omniORB can support multiple network transports. All platforms
(usually) have a TCP transport available. Unix platforms support a
Unix domain socket transport. Platforms with the OpenSSL library
available can support an SSL transport.

Servers must be configured in two ways with regard to transports: the
transports and interfaces on which they listen, and the details that
are published in IORs for clients to see. Usually the published
details will be the same as the listening details, but there are times
when it is useful to publish different information.

Details are selected with the \code{endPoint} family of parameters.
The simplest is plain \code{endPoint}, which chooses a transport and
interface details, and publishes the information in IORs. End point
parameters are in the form of URIs, with a scheme name of
`\code{giop:}', followed by the transport name. Different transports
have different parameters following the transport.

TCP end points have the format:

\begin{quote}
\code{giop:tcp:}\textit{<host>}\code{:}\textit{<port>}
\end{quote}

\noindent The host must be a valid host name for the server machine.
It determines the network interface on which the server listens. The
port selects the TCP port to listen on, which must be unoccupied.
Either the host or port, or both can be left empty. If the host is
empty, the ORB published the IP address of the first non-loopback
network interface it can find (or the loopback if that is the only
interface), but listens on \emph{all} network interfaces. If the port
is empty, the operating system chooses a port.

Multiple TCP end points can be selected, either to specify multiple
network interfaces on which to listen, or (less usefully) to select
multiple TCP ports on which to listen.

If no \code{endPoint} parameters are set, the ORB assumes a single
parameter of \code{giop:tcp::}, meaning IORs contain the address of
the first non-loopback network interface, the ORB listens on all
interfaces, and the OS chooses a port number.

SSL end points have the same format as TCP ones, except `\code{tcp}'
is replaced with `\code{ssl}'. Unix domain socket end points have the
format:

\begin{quote}
\code{giop:unix:}\textit{<filename>}
\end{quote}

\noindent where the filename is the name of the socket within the
filesystem. If the filename is left blank, the ORB chooses a name
based on the process id and a timestamp.


\subsection{End point publishing}

To publish an end point in IORs, without actually listening on that
end point, the \code{endPointNoListen} parameter can be set. This can
be useful in fault-tolerant applications where replicas of an object
can be contacted at more than one server. \code{endPointNoListen} does
not check that the transport specified is sensible for the current
machine, so it allows the address of a different machine to be
specified.

Similarly, but less likely to be useful, it is possible to ask the
server to listen on an end point, but not publish the details in IORs,
using the \code{endPointNoPublish} parameter. This should \emph{not}
be used for security by obscurity!

If a machine has multiple TCP network interfaces, it may be useful to
publish all interfaces, instead of just the first one. This is
necessary if different interfaces are on separate non-gatewayed
subnets, for example. Publishing all addresses could be achieved with
lots of \code{endPoint} parameters, but a short-hand is to set the
\code{endPointPublishAllIFs} parameter to 1. That (in conjunction with
a `\code{giop:tcp::}' transport selection without a specific hostname)
causes all the machine's non-loopback interfaces to be published in
IORs.



\section{Connection selection and acceptance}

In the face of IORs containing details about multiple different end
points, clients have to know how to choose the one to use to connect a
server. Similarly, servers may wish to restrict which clients can
connect to particular transports. This is achieved with
\term{transport rules}.


\subsection{Client transport rules}
\label{sec:clientRule}

The \code{clientTransportRule} parameter is used to filter and
prioritise the order in which transports specified in an IOR are
tried. Each rule has the form:

\begin{quote}
\textit{<address mask> [action]+}
\end{quote}

\noindent The address mask can be one of

\vspace{\baselineskip}

\begin{tabular}{llp{.5\textwidth}}
1. & \code{localhost} & The address of this machine\\

2. & \textit{w.x.y.z}\code{/}\textit{m1.m2.m3.m4} & An IPv4 address
     with the bits selected by the mask, e.g.\
     172.16.0.0/255.240.0.0.\\

3. & \code{*} & Wildcard that matches any address\\
\end{tabular}

\vspace{\baselineskip}

\noindent The action is one or more of the following:

\vspace{\baselineskip}

\begin{tabular}{llp{.5\textwidth}}
1. & \code{none} & Do not use this address\\
2. & \code{tcp}  & Use a TCP transport\\
3. & \code{ssl}  & Use an SSL transport\\
4. & \code{unix} & Use a Unix socket transport\\
5. & \code{bidir}& Any connection to this address should be used
                   bidirectionally (see section~\ref{sec:bidir})\\
\end{tabular}

\vspace{\baselineskip}

\noindent The transport-selecting actions form a prioritised list, so
an action of `\code{unix,tcp,ssl}' means to use a Unix transport if
there is one, failing that a TCP transport, failing \emph{that} an SSL
transport. In the absence of any explicit rules, the client uses the
implicit rule of `\code{* unix,tcp,ssl}'.

If more than one rule is specified, they are prioritised in the order
they are specified. For example, the configuration file might contain:

\begin{verbatim}
  clientTransportRule = 192.168.1.0/255.255.255.0  unix,tcp
  clientTransportRule = 172.16.0.0/255.240.0.0     unix,tcp
                      =       *                    none
\end{verbatim}

\noindent This would be useful if there is a fast network
(192.168.1.0) which should be used in preference to another network
(172.16.0.0), and connections to other networks are not permitted at
all.

In general, the result of filtering the end point specifications in an
IOR with the client transport rule will be a prioritised list of
transports and networks. (If the transport rules are do not prioritise
one end point over another, the order the end points are listed in the
IOR is used.)  When trying to contact an object, the ORB tries its
possible end points in turn, until it finds one with which it can
contact the object. Only after it has unsuccessfully tried all
permissible transports will it raise a \code{TRANSIENT} exception to
indicate that the connect failed.



\subsection{Server transport rules}
\label{sec:serverRule}

The server transport rules gave the same format as client transport
rules. Rather than being used to select which of a set of ways to
contact a machine, they are used to determine whether or not to accept
connections from particular clients. In this example, we only allow
connections from our intranet:

\begin{verbatim}
  serverTransportRule = localhost                  unix,tcp,ssl
                      = 172.16.0.0/255.240.0.0     tcp,ssl
                      = *                          none
\end{verbatim}

\noindent And in this one, we only accept SSL connections if the
client is not on the intranet:

\begin{verbatim}
  serverTransportRule = localhost                  unix,tcp,ssl
                      = 172.16.0.0/255.240.0.0     tcp,ssl
                      = *                          ssl,bidir
\end{verbatim}




\section{Bidirectional GIOP}
\label{sec:bidir}

omniORB supports bidirectional GIOP, which allows callbacks to be made
using a connection opened by the original client, rather than the
normal model where the server opens a new connection for the callback.
This is important for negotiating firewalls, since they tend not to
allow connections back on arbitrary ports.

There are several steps required for bidirectional GIOP to be enabled
for a callback. Both the client and server must be configured
correctly. On the client side, these conditions must be met:

\begin{itemize}

\item The \code{offerBiDirectionalGIOP} parameter must be set to true. 
\item The client transport rule for the target server must contain the
      \code{bidir} action.
\item The POA containing the callback object (or objects) must have
      been created with a \code{BidirectionalPolicy} value of
      \code{BOTH}.

\end{itemize}

\noindent On the server side, these conditions must be met:

\begin{itemize}

\item The \code{acceptBiDirectionalGIOP} parameter must be set to true. 
\item The server transport rule for the requesting client must contain
      the \code{bidir} action.
\item The POA hosting the object contacted by the client must have
      been created with a \code{BidirectionalPolicy} value of
      \code{BOTH}.

\end{itemize}


\section{SSL transport}

omniORB 4.0 supports an SSL transport, using OpenSSL. It is only built
if OpenSSL is available. On platforms using Autoconf, it is
autodetected in many locations, or its location can be given with the
\code{-{}-with-openssl=} argument to \code{configure}. On other
platforms, the \code{OPEN\_SSL\_ROOT} make variable must be set in the
platform file.

To use the SSL transport, you must link your application with the
\file{omnisslTP} library, and correctly set up certificates. See the
\file{src/examples/ssl_echo} directory for an example. That directory
contains a \file{README} file with more details.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Code set conversion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:codesets}

omniORB 4.0 supports full code set negotiation, used to select and
translate between different character code sets, for the transmission
of chars, strings, wchars and wstrings. The support is mostly
transparent to application code, but there are a number of options
that can be selected. This chapter covers the options, and also gives
some pointers about how to implement your own code sets, in case the
ones that come with omniORB are not sufficient.


\section{Native code sets}

For the ORB to know how to handle strings and wstrings given to it by
the application, it must know what code set they are represented
with, so it can properly translate them if need be. The defaults are
ISO 8859-1 (Latin 1) for char and string, and UTF-16 for wchar and
wstring. Different code sets can be chosen at initialisation time with
the \code{nativeCharCodeSet} and \code{nativeWCharCodeSet}
parameters. The supported code sets are printed out at initialisation
time if the ORB traceLevel is 15 or greater.

For most applications, the defaults are fine. Some applications may
need to set the native char code set to UTF-8, allowing the full
Unicode range to be supported in strings.

Note that the default for wchar is always UTF-16, even on Unix
platforms where wchar is a 32-bit type. Select the UCS-4 code set to
select characters outside the first plane without having to use UTF-16
surrogates\footnote{If you have no idea what this means, don't
worry---you're better off not knowing unless you \emph{really} have
to.}.


\section{Code set library}

To save space in the main ORB core library, most of the code set
implementations are in a separate library named omniCodeSets4. To use
the extra code sets, you must link your application with that
library. On most platforms, if you are using dynamic linking,
specifying the omniCodeSets4 library in the link command is sufficient
to have it initialised, and for the code sets to be available. With
static linking, or platforms with less intelligent dynamic linkers,
you must force the linker to initialise the library. You do that by
including the \file{omniORB4/optionalFeatures.h} header. By default,
that header enables several optional features. Look at the file
contents to see how to turn off particular features.


\section{Implementing new code sets}

It is quite easy to implement new code sets, if you need support for
code sets (or marshalling formats) that do not come with the omniORB
distribution. There are extensive comments in the headers and ORB code
that explain how to implement a code set; this section just serves to
point you in the right direction.

The main definitions for the code set support are in
\file{include/omniORB4/codeSets.h}. That defines a set of base classes
use to implement code sets, plus some derived classes that use look-up
tables to convert simple 8-bit and 16-bit code sets to Unicode.

When sending or receiving string data, there are a total of four code
sets in action: a native char code set, and transmission char code
set, a native wchar code set, and a transmission wchar code set. The
native code sets are as described above; the transmission code sets
are the ones selected to communicate with a remote machine. They are
responsible for understanding the GIOP marshalling formats, as well as
the code sets themselves. Each of the four code sets has an object
associated with it which contains methods for converting data.

There are two ways in which a string/wstring can be transmitted or
received. If the transmission code set in action knows how to deal
directly with the native code set (the trivial case being that they
are the same code set, but more complex cases are possible too), the
transmission code set object can directly marshal or unmarshal the
data into or out of the application buffer. If the transmission code
set does not know how to handle the native code set, it converts the
string/wstring into UTF-16, and passes that to the native code set
object (or vice-versa). All code set implementations must therefore
know how to convert to and from UTF-16.

With this explanation, the classes in \file{codeSets.h} should be easy
to understand. The next place to look is in the various existing code
set implementations, which are files of the form \file{cs-*.cc} in the
\file{src/lib/omniORB/orbcore} and \file{src/lib/omniORB/codesets}.
Note how all the 8-bit code sets (the ISO 8859-* family) consist
entirely of data and no code, since they are driven by look-up tables.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Interceptors}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:interceptors}

omniORB 4.0 supports interceptors that allow the application to insert
processing in various points along the call chain, and in various
other locations. It does not support the standard Portable
Interceptors API.

The interceptor interfaces are defined in a single header,
\file{include/omniORB4/omniInterceptors.h}. Each interception point
consists of a singleton object with \op{add} and \op{remove} methods,
and the definition of an `interceptor info' class. For example:

\begin{cxxlisting}
class omniInterceptors {
  ...
  class clientSendRequest_T {
  public:

    class info_T {
    public:
      giopStream&              giopstream;
      const omniIOR&           ior;
      const char*              opname;
      CORBA::Boolean           oneway;
      CORBA::Boolean           response_expected;
      IOP::ServiceContextList  service_contexts;

      info_T(giopStream& s, const omniIOR& i, const char* op,
	     CORBA::Boolean ow, CORBA::Boolean re) :
	giopstream(s),ior(i),opname(op),oneway(ow),response_expected(re),
	service_contexts(5) {}

    private:
      info_T();
      info_T(const info_T&);
      info_T& operator=(const info_T&);
    };

    typedef CORBA::Boolean (*interceptFunc)(info_T& info);

    void add(interceptFunc);
    void remove(interceptFunc);
  };
  ...
};
\end{cxxlisting}

\noindent You can see that the interceptors themselves are functions
which take the \code{info\_T} object as their argument and return
boolean. Interceptors are called in the order they are registered;
normally, all interceptor functions return true, meaning that
processing should continue with subsequent interceptors. If an
interceptor returns false, later interceptors are not called. You
should only do that if you really know what you are doing.

Notice that the \code{info\_T} contains references to several omniORB
internal data types. The definitions of these can be found in other
header files within \file{include/omniORB4} and
\file{include/omniORB4/internal}.


\section{Interceptor registration}

All the interceptor singletons are registered within another singleton
object of class \code{omniInterceptors}. You retrieve a pointer to
that singleton with the \op{omniORB::\dsc{}getInterceptors} function.
The code to register an interceptor looks, for example, like:

\begin{cxxlisting}
omniInterceptors* interceptors = omniORB::getInterceptors();
interceptors->clientSendRequest.add(myInterceptorFunc);
\end{cxxlisting}


\section{Available interceptors}

The following interceptors are available:

\begin{description}

\item[encodeIOR]\mbox{}\\
%
Called when encoding an IOR to represent an object reference. This
interception point allows the application to insert extra profile
components into IORs. Note that you must understand and adhere to the
rules about data stored in IORs, otherwise the IORs created may be
invalid. omniORB itself uses this interceptor to insert various items,
so you can see an example of its use in the
\op{insertSupportedComponents} function defined in
\file{src/lib/omniORB/orbcore/ior.cc}.


\item[decodeIOR]\mbox{}\\
%
Called when decoding an IOR. The application can use this to get out
whatever information they put into IORs with encodeIOR. Again, see
\op{extract\dsc{}SupportedComponents} in
\file{src/lib/omniORB/orbcore/ior.cc} for an example.


\item[clientSendRequest]\mbox{}\\
%
Called just before a request header is sent over the network. The
application can use it to insert service contexts in the header. See
\op{setCodeSetService\dsc{}Context} in
\file{src/lib/omniORB/orbcore/cdrStream.cc} for an example of its use.


\item[clientReceiveReply]\mbox{}\\
%
Called as the client receives a reply, just after unmarshalling the
reply header. *** NOT IMPLEMENTED YET!


\item[clientReceiveException]\mbox{}\\
%
Called as the client receives an exception, just after unmarshalling
the exception reply header. *** NOT IMPLEMENTED YET!


\item[serverReceiveRequest]\mbox{}\\
%
Called when the server receives a request, just after unmarshalling
the request header. See the \op{getCodeSetServiceContext} function in
\file{src/lib/omniORB/orbcore/cdrStream.cc} for an example.


\item[serverSendReply]\mbox{}\\
%
Called just before the server marshals a reply header. *** NOT
IMPLEMENTED YET!


\item[serverSendException]\mbox{}\\
%
Called just before the server marshals an exception reply header. ***
NOT IMPLEMENTED YET!


\item[createIdentity]\mbox{}\\
%
Called when the ORB is about to create an `identity' object to
represent a CORBA object. It allows application code to provide its
own identity implementations. It is very unlikely that an application
will need to do this.


\item[createORBServer]\mbox{}\\
%
Used internally by the ORB to register different kinds of server. At
present, only a GIOP server is registered. It is very unlikely that
application code will need to do this.

\end{description}








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Type Any and TypeCode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{chap:any}

The CORBA specification provides for a type that can hold the value of
any OMG IDL type. This type is known as type Any. The OMG also
specifies a pseudo-object, TypeCode, that can encode a description of
any type specifiable in OMG IDL.

In this chapter, an example demonstrating the use of type Any is
presented.  This is followed by sections describing the behaviour of
type Any and TypeCode in omniORB.  For further information on type
Any, refer to the C++ Mapping specification., and for more information
on TypeCode, refer to the Interface Repository chapter in the CORBA
core section of the CORBA specification.


\begin{statement}
\centerline{\textbf{Warning}}

Since 2.8.0, omniORB has been updated to CORBA 2.3 and above. In order
to comply with the 2.3 specification, it was necessary to change the
semantics of \emph{the extraction of string, object reference and
typecode from an Any}. The memory of the extracted values of these
types now belongs to the Any value. The storage is freed when the Any
value is deallocated.  Previously the extracted value was a copy and
the application was responsible for releasing the storage. It is not
possible to detect the old usage at compile time. In particular,
unmodified code that uses the affected Any extraction operators will
most certainly cause runtime errors to occur.  To smooth the
transition from the old usage to the new, an ORB configuration
parameter \code{omniORB\_27\_CompatibleAnyExtraction} can be set to
revert the Any extraction operators to the old semantics.

\end{statement}


\section{Example using type Any}

Before going through this example, you should make sure that you have
read and understood the examples in chapter~\ref{chap:basic}.  The
source code for this example is included in the omniORB distribution,
in the directory \file{src/examples/anyExample}. A listing of the
source code is provided at the end of this chapter.

\subsection{Type Any in IDL}
Type Any allows one to delay the decision on the type used in an
operation until run-time. To use type any in IDL, use the keyword
\code{any}, as in the following example:

\begin{idllisting}
// IDL

interface anyExample {
  any testOp(in any mesg);
};
\end{idllisting}


\noindent The operation \op{testOp()} in this example can now take any
value expressible in OMG IDL as an argument, and can also return any
type expressible in OMG IDL.

Type Any is mapped into C++ as the type \type{CORBA::Any}. When passed
as an argument or as a result of an operation, the following rules
apply:

\mbox{}

{\small
\begin{tabular}{llll}
{\bf In }                & {\bf InOut }       & {\bf Out }           & 
{\bf Return }                                                   \\ \hline
{\tt const CORBA::Any\& }& {\tt CORBA::Any\& }& {\tt CORBA::Any*\& } & 
{\tt CORBA::Any* }
\end{tabular}
}

\mbox{}

\noindent So, the above IDL would map to the following C++:

\begin{cxxlisting}
// C++

class anyExample_i : public virtual POA_anyExample {
public:
  anyExample_i() { }
  virtual ~anyExample_i() { }
  virtual CORBA::Any* testOp(const CORBA::Any& a);
};
\end{cxxlisting}


\subsection{Inserting and Extracting Basic Types from an Any}

The question now arises as to how values are inserted into and removed
from an Any. This is achieved using two overloaded operators:
\code{<{}<=} and \code{>{}>=}.

To insert a value into an Any, the \code{<{}<=} operator is used, as
in this example:

\begin{cxxlisting}
// C++
CORBA::Any an_any;
CORBA::Long l = 100;
an_any <<= l;
\end{cxxlisting}

\noindent Note that the overloaded \code{<{}<=} operator has a return
type of \type{void}.

To extract a value, the \code{>{}>=} operator is used, as in this
example (where the Any contains a long):

\begin{cxxlisting}
// C++
CORBA::Long l;
an_any >>= l;

cout << "This is a long: " << l << endl;
\end{cxxlisting}


The overloaded \code{>{}>=} operator returns a \type{CORBA::Boolean}.
If an attempt is made to extract a value from an Any when it contains
a different type of value (e.g.\ an attempt to extract a long from an
Any containing a double), the overloaded \code{>{}>=} operator will
return False; otherwise it will return True. Thus, a common tactic to
extract values from an Any is as follows:

\begin{cxxlisting}
// C++
CORBA::Long l;
CORBA::Double d;
const char* str;     // From CORBA 2.3 onwards, uses const char*
                     // instead of char*. 

if (an_any >>= l) {
    cout << "Long: " << l << endl;
}
else if (an_any >>= d) {
    cout << "Double: " << d << endl;
}
else if (an_any >>= str) {
    cout << "String: " << str << endl;
    // Since 2.8.0 the storage of the extracted string is still
    // owned by the any.
    // In pre-omniORB 2.8.0 releases, the string returned is a copy.
}
else {
    cout << "Unknown value." << endl;
}
\end{cxxlisting}


\subsection{Inserting and Extracting Constructed Types from an Any}

It is also possible to insert and extract constructed types and object
references from an Any. omniidl will generate insertion and extraction
operators for the constructed type. Note that it is necessary to
specify the \texttt{-WBa} command-line flag when running omniidl in
order to generate these operators. The following example illustrates
the use of constructed types with type Any:

\begin{idllisting}
// IDL
struct testStruct {
  long l;
  short s;
};

interface anyExample {
  any testOp(in any mesg);
};
\end{idllisting}

Upon compiling the above IDL with \texttt{omniidl -bcxx -Wba}, the
following overloaded operators are generated:

\begin{enumerate}
\item \verb|void operator<<=(CORBA::Any&, const testStruct&)|
\item \verb|void operator<<=(CORBA::Any&, testStruct*)|
\item \verb|CORBA::Boolean operator>>=(const CORBA::Any&,|\\
      \verb|const testStruct*&)|
\end{enumerate}

Operators of this form are generated for all constructed types, and
for interfaces.

The first operator, \emph{(1)}, copies the constructed type, and
inserts it into the Any. The second operator, \emph{(2)}, inserts the
constructed type into the Any, and then manages it. Note that if the
second operator is used, the Any consumes the constructed type, and
the caller should not use the pointer to access the data after
insertion. The following is an example of how to insert a value into
an Any using operator \emph{(1)}:

\begin{cxxlisting}
// C++
CORBA::Any an_any;

testStruct t;
t.l = 456;
t.s = 8;

an_any <<= t;
\end{cxxlisting}


The third operator, \emph{(3)}, is used to extract the constructed
type from the Any, and can be used as follows:

\begin{cxxlisting}
const testStruct* tp;   // From CORBA 2.3 onwards, use 
                        // const testStruct* instead of testStruct*

if (an_any >>= tp) {
    cout << "testStruct: l: " << tp->l << endl;
    cout << "            s: " << tp->s << endl;
}
else {
    cout << "Unknown value contained in Any." << endl;
}
\end{cxxlisting}

As with basic types, if an attempt is made to extract a type from an
Any that does not contain a value of that type, the extraction
operator returns False. If the Any does contain that type, the
extraction operator returns True. If the extraction is successful, the
caller's pointer will point to memory managed by the Any. The caller
must not delete or otherwise change this storage, and should not use
this storage after the contents of the Any are replaced (either by
insertion or assignment), or after the Any has been destroyed. In
particular, management of the pointer should not be assigned to a
\type{\_var} type.

If the extraction fails, the caller's pointer will be set to point to
null.

Note that there are special rules for inserting and extracting arrays
(using the \type{\_forany} types), and for inserting and extracting
bounded strings, booleans, chars, and octets. Please refer to the C++
Mapping specification for further information.



\section{Type Any in omniORB}
\label{anyOmniORB}

This section contains some notes on the use and behaviour of type Any
in omniORB.

\paragraph*{Generating Insertion and Extraction Operators.}
To generate type Any insertion and extraction operators for
constructed types and interfaces, the \texttt{-Wba} command line flag
should be specified when running omniidl.

\paragraph*{TypeCode comparison when extracting from an Any.}
When an attempt is made to extract a type from an Any, the TypeCode of
the type is checked for \emph{equivalence} with the TypeCode of the
type stored by the Any. The \op{equivalent} test in the TypeCode
interface is used for this purpose\footnote{In pre-omniORB 2.8.0
releases, omniORB performs an equality test and will ignore any alias
TypeCodes (\code{tk\_alias}) when making this comparison. The
semantics is similar to the \op{equivalent} test in the TypeCode
interface of CORBA 2.3.}.

Examples:

\begin{idllisting}
// IDL 1
typedef double Double1;

struct Test1 {
  Double1 a;
};
\end{idllisting}

\begin{idllisting}
// IDL 2
typedef double Double2;

struct Test1 {
  Double2 a;
};
\end{idllisting}
    
If an attempt is made to extract the type \type{Test1} defined in IDL
1 from an Any containing the \type{Test1} defined in IDL 2, this will
succeed (and vice-versa), as the two types differ only by an alias.

\paragraph*{Top-level aliases.}
When a type is inserted into an Any, the Any stores both the value of
the type and the TypeCode for that type. The treatment of top-level
aliases from omniORB 2.8.0 onwards is different from pre-omniORB 2.8.0
releases.

In pre-omniORB 2.8.0 releases, if there are any top-level
\code{tk\_alias} TypeCodes in the TypeCode, they will be removed from
the TypeCode stored in the Any. Note that this does not affect the
\code{\_tc\_} TypeCode generated to represent the type (see section on
TypeCode, below). This behaviour is necessary, as two types that
differ only by a top-level alias can use the same insertion and
extraction operators. If the \code{tk\_alias} is not removed, one of
the types could be transmitted with an incorrect \code{tk\_alias}
TypeCode. Example:

\begin{idllisting}
// IDL 3
typedef sequence<double> seqDouble1;
typedef sequence<double> seqDouble2;
typedef seqDouble2       seqDouble3;
\end{idllisting}

If either \type{seqDouble1} or \type{seqDouble2} is inserted into an
Any, the TypeCode stored in the Any will be for a
\code{sequence<double>}, and not for an alias to a
\code{sequence<double>}.

From omniORB 2.8.0 onwards, there are two changes. Firstly, in the
example, \type{seqDouble1} and \type{seqDouble2} are now distinct
types and therefore each has its own set of C++ operators for Any
insertion and extraction. Secondly, the top level aliases are not
removed. For example, if \type{seqDouble3} is inserted into an Any,
the insertion operator for \type{seqDouble2} is invoked (because
\type{seqDouble3} is just a C++ typedef of
\type{seqDouble2}). Therefore, the TypeCode in the Any would be that
of seqDouble2. If this is not desirable, one can use the new member
function `\code{void type(TypeCode\_ptr)}' of the Any interface to
explicitly set the TypeCode to the correct one.


\paragraph*{Removing aliases from TypeCodes.}
Some ORBs (such as Orbix) will not accept TypeCodes containing
\code{tk\_alias} TypeCodes. When using type Any while interoperating
with these ORBs, it is necessary to remove \code{tk\_alias} TypeCodes
from throughout the TypeCode representing a constructed type.

To remove all \code{tk\_alias} TypeCodes from TypeCodes stored in
Anys, supply the \texttt{-ORBtcAliasExpand 1} command-line flag when
running an omniORB executable. There will be some (small) performance
penalty when inserting values into an Any.

Note that the \code{\_tc\_} TypeCodes generated for all constructed
types will contain the complete TypeCode for the type (including any
\code{tk\_alias} TypeCodes), regardless of whether the
\texttt{-ORBtcAliasExpand} flag is set to 1 or not.

\paragraph*{Recursive TypeCodes.}
omniORB (as of version 2.7) supports recursive TypeCodes. This means
that types such as the following can be inserted or extracted from an
Any:

\begin{idllisting}
// IDL 4
struct Test4 {
  sequence<Test4> a;
};
\end{idllisting}


\paragraph*{Threads and type Any.}
Inserting and extracting simultaneously from the same Any (in 2
different threads) is undefined behaviour.

Extracting simultaneously from the same Any (in 2 or more different
threads) also leads to undefined behaviour.  It was decided not to
protect the Any with a mutex, as this condition should rarely arise,
and adding a mutex would lead to performance penalties.


\section{TypeCode in omniORB}

This section contains some notes on the use and behaviour of TypeCode
in omniORB

\paragraph*{TypeCodes in IDL.}

When using TypeCodes in IDL, note that they are defined in the CORBA
scope.  Therefore, \type{CORBA::TypeCode} should be used. Example:

\begin{idllisting}
// IDL 5
struct Test5 {
  long length;
  CORBA::TypeCode desc;
};
\end{idllisting}

\paragraph*{orb.idl}

Inclusion of the file \file{orb.idl} in IDL using
\type{CORBA::TypeCode} is optional.  An empty \file{orb.idl} file is
provided for compatibility purposes.

\paragraph*{Generating TypeCodes for constructed types.}

To generate a TypeCode for constructed types, specify the
\texttt{-Wba} command-line flag when running omniidl. This will
generate a \code{\_tc\_} TypeCode describing the type, at the same
scope as the type (as per the CORBA 2.3 specification). Example:

\begin{idllisting}
// IDL 6
struct Test6 {
  double a;
  sequence<long> b;
};
\end{idllisting}

A TypeCode, \code{\_tc\_Test6}, will be generated to describe the
struct \type{Test6}. The operations defined in the TypeCode interface
can be used to query the TypeCode about the type it represents.


\paragraph*{TypeCode equality.}

The behaviour of \op{CORBA::TypeCode::equal} member function from
omniORB 2.8.0 onwards is different from pre-omniORB 2.8.0 releases.
In summary, the pre-omniORB 2.8.0 is close to the semantics of the new
\op{CORBA::TypeCode::equivalent} member function. Details are as
follows:

The \op{CORBA::TypeCode::equal} member function will now return true
only if the two TypeCodes are \emph{exactly} the same.
\code{tk\_alias} TypeCodes are included in this comparison, unlike the
comparison made when values are extracted from an Any (see section on
Any, above).

In pre-omniORB 2.8.0 releases, equality test would ignore the optional
fields when one of the fields in the two typecodes is empty. For
example, if one of the TypeCodes being checked is a \code{tk\_struct},
\code{tk\_union}, \code{tk\_enum}, or \code{tk\_alias}, and has an
empty repository ID parameter, then the repository ID parameter will
be ignored when checking for equality.  Similarly, if the \code{name}
or \code{member\_name} parameters of a TypeCode are empty strings,
they will be ignored for equality checking purposes. This is because a
CORBA 2 ORB does not have to include these parameters in a TypeCode
(see the Interoperability section of the CORBA specification). Note
that these (optional) parameters are included in TypeCodes generated
by omniORB.

Since CORBA 2.3, the issue of TypeCode equality has been clarified.
There is now a new member \op{CORBA::TypeCode::equivalent} which
provides the semantics of the \op{CORBA::TypeCode::equal} as
implemented in omniORB releases prior to 2.8.0. So from omniORB 2.8.0
onwards, the \op{CORBA::TypeCode::\dsc{}equal} function has been
changed to enforce strict equality.  The pre-2.8.0 behaviour can be
obtained with \op{equivalent}.


\clearpage

\section{Source Listing}

\subsection{anyExample\_impl.cc}

\begin{cxxlisting}
// anyExample_impl.cc - This is the source code of the example used in
//                      Chapter 9 "Type Any and TypeCode" of the omniORB
//                      users guide.
//
//                      This is the object implementation.
//
// Usage: anyExample_impl
//
//        On startup, the object reference is printed to cerr as a
//        stringified IOR. This string should be used as the argument to 
//        anyExample_clt.
//

#include <iostream.h>
#include <anyExample.hh>

class anyExample_i : public POA_anyExample {
public:
  inline anyExample_i() {}
  virtual ~anyExample_i() {}
  virtual CORBA::Any* testOp(const CORBA::Any& a);
};

CORBA::Any* anyExample_i::testOp(const CORBA::Any& a)
{
  cout << "Any received, containing: " << endl;

#ifndef NO_FLOAT
  CORBA::Double d;
#endif

  CORBA::Long l;
  const char* str;

  testStruct* tp;

  if (a >>= l) {
    cout << "Long: " << l << endl;
  }
#ifndef NO_FLOAT
  else if (a >>= d) {
    cout << "Double: " << d << endl;
  }
#endif
  else if (a >>= str) {
    cout << "String: " << str << endl;
  }
  else if (a >>= tp) {
    cout << "testStruct: l: " << tp->l << endl;
    cout << "            s: " << tp->s << endl;
  }
  else {
    cout << "Unknown value." << endl;
  }

  CORBA::Any* ap = new CORBA::Any;

  *ap <<= (CORBA::ULong) 314;

  cout << "Returning Any containing: ULong: 314\n" << endl;
  return ap;
}

//////////////////////////////////////////////////////////////////////

int main(int argc, char** argv)
{
  try {
    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv, "omniORB3");

    CORBA::Object_var obj = orb->resolve_initial_references("RootPOA");
    PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);

    anyExample_i* myobj = new anyExample_i();

    PortableServer::ObjectId_var myobjid = poa->activate_object(myobj);

    obj = myobj->_this();
    CORBA::String_var sior(orb->object_to_string(obj));
    cerr << "'" << (char*)sior << "'" << endl;

    myobj->_remove_ref();

    PortableServer::POAManager_var pman = poa->the_POAManager();
    pman->activate();

    orb->run();
    orb->destroy();
  }
  catch(CORBA::SystemException&) {
    cerr << "Caught CORBA::SystemException." << endl;
  }
  catch(CORBA::Exception&) {
    cerr << "Caught CORBA::Exception." << endl;
  }
  catch(omniORB::fatalException& fe) {
    cerr << "Caught omniORB::fatalException:" << endl;
    cerr << "  file: " << fe.file() << endl;
    cerr << "  line: " << fe.line() << endl;
    cerr << "  mesg: " << fe.errmsg() << endl;
  }
  catch(...) {
    cerr << "Caught unknown exception." << endl;
  }
  return 0;
}
\end{cxxlisting}


\clearpage

\subsection{anyExample\_clt.cc}

\begin{cxxlisting}
// anyExample_clt.cc -  This is the source code of the example used in 
//                      Chapter 9 "Type Any and TypeCode" of the omniORB 
//                      users guide.
//
//                      This is the client.
//
// Usage: anyExample_clt <object reference>
//

#include <iostream.h>
#include <anyExample.hh>

static void invokeOp(anyExample_ptr& tobj, const CORBA::Any& a)
{
  CORBA::Any_var bp;

  cout << "Invoking operation." << endl;
  bp = tobj->testOp(a);

  cout << "Operation completed. Returned Any: ";
  CORBA::ULong ul;

  if (bp >>= ul) {
    cout << "ULong: " << ul << "\n" << endl;
  }
  else {
    cout << "Unknown value." << "\n" << endl;
  }
}

static void hello(anyExample_ptr tobj)
{
  CORBA::Any a;

  // Sending Long
  CORBA::Long l = 100;
  a <<= l;
  cout << "Sending Any containing Long: " << l << endl; 
  invokeOp(tobj,a);
    
  // Sending Double
#ifndef NO_FLOAT
  CORBA::Double d = 1.2345;
  a <<= d;
  cout << "Sending Any containing Double: " << d << endl; 
  invokeOp(tobj,a);
#endif
  
  // Sending String
  const char* str = "Hello";
  a <<= str;
  cout << "Sending Any containing String: " << str << endl;
  invokeOp(tobj,a);
    
  // Sending testStruct  [Struct defined in IDL]
  testStruct t;
  t.l = 456;
  t.s = 8;
  a <<= t;
  cout << "Sending Any containing testStruct: l: " << t.l << endl;
  cout << "                                   s: " << t.s << endl;
  invokeOp(tobj,a);
}

//////////////////////////////////////////////////////////////////////

int main(int argc, char** argv)
{
  try {
    CORBA::ORB_var orb = CORBA::ORB_init(argc, argv, "omniORB3");

    if( argc != 2 ) {
      cerr << "usage:  anyExample_clt <object reference>" << endl;
      return 1;
    }

    CORBA::Object_var obj = orb->string_to_object(argv[1]);
    anyExample_var ref = anyExample::_narrow(obj);
    if( CORBA::is_nil(ref) ) {
      cerr << "Can't narrow reference to type anyExample (or it was nil)."
	   << endl;
      return 1;
    }
    hello(ref);

    orb->destroy();
  }
  catch(CORBA::COMM_FAILURE& ex) {
    cerr << "Caught system exception COMM_FAILURE -- unable to contact the "
         << "object." << endl;
  }
  catch(CORBA::SystemException&) {
    cerr << "Caught a CORBA::SystemException." << endl;
  }
  catch(CORBA::Exception&) {
    cerr << "Caught CORBA::Exception." << endl;
  }
  catch(omniORB::fatalException& fe) {
    cerr << "Caught omniORB::fatalException:" << endl;
    cerr << "  file: " << fe.file() << endl;
    cerr << "  line: " << fe.line() << endl;
    cerr << "  mesg: " << fe.errmsg() << endl;
  }
  catch(...) {
    cerr << "Caught unknown exception." << endl;
  }
  return 0;
}
\end{cxxlisting}


\backmatter

\bibliography{omniORB}

\end{document}
















\endinput



%
%
% The following is obsolete material from the old omniORB 2 and 3 manuals.
% It's left here in case it's useful.
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{The Basic Object Adaptor (BOA)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This chapter describes the BOA implementation in omniORB. The CORBA
specification defines the Basic Object Adaptor as the entity that
mediates between object implementations and the ORB. Unfortunately,
the BOA specification is incomplete and does not address the
multi-threading issues appropriately. The end result is that different
ORB vendors implement different extensions to their BOAs. Worse, the
implementation of the operations defined in the specification are
different in different ORBs. Recently, a new Object Adaptor
specification (the Portable Object Adaptor- POA) has been adopted and
will replace the BOA as the standard Object Adaptor in CORBA. The new
specification recognises the compatibility problems of BOA and
recommends that all BOAs should be considered propriety extensions.
omniORB will support POA in future releases. Until then, you have to
use the BOA to attach object implementations to the ORB.

The rest of this chapter describes the interface of the BOA in detail. It
is important to recognise that the interface described below is omniORB
specific and hence the code using this interface is unlikely to be portable
to other ORBs.

Unless it is stated otherwise, the term ``object'' will be used below to
refer to object implementations. This should not be confused with ``object
references'' which are handles held by clients.

\section{BOA Initialisation}

It takes two steps to put the BOA into service. The BOA has to be
initialised using {\tt BOA\_init} and activated using {\tt
impl\_is\_ready}.


\noindent {\tt BOA\_init} is a member of the {\tt CORBA::ORB} class. Its signature is:

{\small
\begin{verbatim}
BOA_ptr BOA_init(int & argc,
                 char ** argv,
                 const char * boa_identifier);
\end{verbatim}
}

\noindent Typically, it is used in the startup code as follows:

{\small
\begin{verbatim}
CORBA::ORB_ptr orb = CORBA::ORB_init(argc,argv,"omniORB2");   // line 1
CORBA::BOA_ptr boa = orb->BOA_init(argc,argv,"omniORB2_BOA"); // line 2
\end{verbatim}
}

The {\tt argv} parameters may contain BOA options. These options will be
removed from the {\tt argv} list when {\tt BOA\_init} returns. Other
parameters in {\tt argv} will remain. The supported options are:

\begin{description}

\item[-BOAiiop\_port {\tt <port number (0-65535)>}] Use the port number to receive
IIOP requests. This option can be specified multiple times in the command
line and the BOA would be initialised to listen on all of the ports.

\item[-BOAid {\tt <id (string)>}] If this option is used the id must be
``omniORB2\_BOA''. 

\item[-BOAiiop\_name\_port {\tt <hostname{[:port number]}>}] Similar to {\tt
{-BOAiiop\_port}}, this options tells the BOA the hostname and optionally the port number to use.

\end{description}

If the third argument of {\tt BOA\_init} is non-nil, it must be the string
constant ``omniORB2\_BOA''. If the argument is nil, -BOAid must be present
in {\tt argv}.

If there is any problem in the initialisation process, a {\tt
CORBA::INITIALIZE} exception would be raised.

To register an object with the BOA, the method
{\tt \_obj\_is\_ready} should be called with the return value of {\tt
BOA\_init} as the argument.

{\tt BOA\_init} is thread-safe. It can be called multiple times and the
same {\tt BOA\_ptr} will be returned. However, only the {\tt argv} in the
first call will be scanned, the argument is ignored in subsequent calls.

{\tt BOA\_init} returns a pseudo object of type {\tt
CORBA::BOA\_ptr}. Similar to {\tt CORBA::Object\_ptr}, the pointer can be
managed using {\tt CORBA::BOA\_var}, {\tt BOA::\_duplicate} and {\tt
CORBA::release}. The pointer can be tested using {\tt CORBA::is\_nil} which
returns true if the pointer is equivalent to the return value of {\tt
BOA::\_nil}. 

After {\tt BOA\_init} is called, objects can be registered. However,
incoming IIOP requests would not be despatched until {\tt impl\_is\_ready}
is called.

{\small
\begin{verbatim}
class BOA {
public:
   impl_is_ready(CORBA::ImplementationDef_ptr p = 0,
                 CORBA::Boolean NonBlocking = 0);
};
\end{verbatim}
}

One of the common pitfall in using the BOA is to forget to call
impl\_is\_ready. Until this call returns, there is no thread listening on
the port from which IIOP requests are received. The remote client may hang
because of this.

When {\tt impl\_is\_ready} is called with no argument. The calling thread
would be blocked indefinitely in the function until {\tt impl\_shutdown}
(see below) is called. The thread that is calling {\tt impl\_is\_ready}
is not used by the BOA to perform its internal functions. The BOA has its
own set of threads to process incoming requests and general
housekeeping. Therefore, it is not necessary to have a thread blocked in
the call if it can be put into use elsewhere. For example, the main thread
may call {\tt impl\_is\_ready} once in non-blocking mode (see below) and
then enter the event loop to handle the GUI frontend.

If non-blocking behaviour is needed, the {\tt NonBlocking} argument should be
set to 1. For instance, if you creates a callback object, you might call
impl\_is\_ready in non-blocking mode to tell the BOA to start receiving
IIOP requests before sending the callback object to the remote object. The
first argument {\tt ImplementationDef\_ptr} is ignored by the BOA. Just set
the argument to nil.

{\tt impl\_is\_ready} is thread safe and can be called multiple
times. Multiple threads can be blocked in {\tt impl\_is\_ready}.

\section{Object Registration}

Once the BOA is initialised, objects can be registered. The
purpose of object registration is to let the BOA know of the existence of
the object and to dispatch requests for the object as upcalls into the
object. 

To register an object, the {\tt \_obj\_is\_ready} function should be
called. {\tt \_obj\_is\_ready} is a member function of the implementation
skeleton class. The function should be called only once for each object.
The call should be made only after the object is fully initialised.

The member function {\tt obj\_is\_ready} of the BOA may also be used to
register an object. However, this function has been superseded by {\tt
\_obj\_is\_ready} and should not be used in new application code.

\section{Object Disposal}

Once an object is registered, it is under the
management of the BOA. To remove the object from the BOA and to delete it
(when it is safe to do so), the {\tt \_dispose} function should be called.
{\tt \_dispose} is a member function of the implementation skeleton class.
The function should be called only once for each object.

Notice the asymmetry in object instantiation and destruction. To instantiate
an object, the application code has to call the {\bf new}
operator. To remove the object, the application should never
call the delete operator on the object directly.

At the time the {\tt \_dispose} call is made, there may be other threads
invoking on the object, the BOA ensures that all these calls are completed
before removing the object from its internal tables and calling the
{\bf delete} operator.

Internally, the BOA keeps a reference count on each object. Initially, the
reference count is 0. After a call to {\tt \_obj\_is\_ready}, the reference
count is 1. The BOA increases the reference count by 1 before
an upcall into the object is made. The count is decreased by 1 when the
upcall returns.  {\tt \_dispose} decreases the reference count by 1, if
the reference count is 0, the delete operator is called. If the count is
non-zero, the object is marked as disposed. The object will be deleted when
the reference count eventually goes to zero.

The reference count is also increased by 1 for each object reference held
in the same address space. Hence, the {\bf delete} operator will not be
called when there are outstanding object references in the same address
space. To ensure that an object is deleted, all its object references in
the same address space should be released using {\tt CORBA::release}.

Unlike colocated object references, references held by clients in other
address spaces would not prevent the deletion of objects. If these clients
invoke on the object after it is disposed, the system exception INV\_OBJREF
would be raised. The difference in semantics is an undesirable side-effect
of the current BOA implementation. In future, colocated references will
have the same semantics as remote references, i.e. their presence will not
delay the deletion of the objects.

Instead of {\tt \_dispose}, it may be useful to have a method to deactivate
the object but not deleting it. This feature is not supported in the
current BOA implementation.

\section{BOA Shutdown}

The BOA can be withdrawn from service using member functions {\tt
impl\_shutdown} and {\tt destroy}.

{\small
\begin{verbatim}
class BOA {
public:
   void impl_shutdown();
   void destroy();
};
\end{verbatim}
}

{\tt impl\_shutdown} and {\tt destroy} are the inverse of {\tt
impl\_is\_ready} and {\tt BOA\_init} respectively.

{\tt impl\_shutdown} deactivates the BOA. When the call returns, all the
internal threads and network connections will be shutdown. Any thread
blocking in {\tt impl\_is\_ready} would be unblocked. After the call, no
request from other address spaces will be processed. In other words, the
BOA will be in the same state as it was in before {\tt impl\_is\_ready} was
called. For example, a remote client may hang if it tries to connect to the
server after {\tt impl\_shutdown} was called because no thread is listening
on the IIOP port. 

{\tt impl\_shutdown} does not wait for incoming requests to complete before
it closes the network connections. The remote clients will see the network
connections shutdown and the replies may not  reach them even if the
upcalls have been completed. Therefore, if the application is to define an
operation in an IDL interface to shutdown the BOA,  the operation should be
defined as an oneway operation.

{\tt impl\_shutdown} is thread-safe and can be called multiple times. The
call is silently ignored if the BOA has already been shutdown. After {\tt
impl\_shutdown} is called, the BOA can be reactivated by another call to
{\tt impl\_is\_ready}.

It should be noted that {\tt impl\_shutdown} does not affect outgoing
network connections. That is, clients in the same address space will
still be able to make calls to objects in other address spaces.

While remote requests are not delivered after {\tt impl\_shutdown} is
called, the current implementation does not stop colocated clients from
calling the objects. In future, colocated clients will exhibit the same
behaviour as remote clients.

{\tt destroy} permanently removed the BOA. This function will call {\tt
impl\_shutdown} implicitly if it has not been called. When this call
returns, the IIOP port(s) held by the BOA will be freed. Remote clients
will see their requests refused by the operating system when they try to
open a connection to the IIOP port(s). 

After {\tt destroy} is called, the BOA should not be used. If there is any
objects still registered with the BOA, the objects should not be invoked
afterwards. The objects are not disposed. Invoking on the objects after
{\tt destroy} would result in undefined behaviour. Initialisation of
another BOA using {\tt BOA\_init} is not supported. The behaviour of {\tt
BOA\_init} after this call is undefined.

\section{Unsupported functions}

The following member functions are not implemented. Calling these functions
do not have any effect.

\begin{itemize}
\item {\tt Object\_ptr create(...)}
\item {\tt ReferenceData* get\_id(Object\_ptr)}
\item {\tt Principal\_ptr get\_principal(Object\_ptr,Environment\_ptr)}
\item {\tt void change\_implementation(Object\_ptr, ImplementationDef\_ptr)}
\item {\tt void deactivate\_impl(ImplementationDef\_ptr)}
\item {\tt void deactivate\_obj(Object\_ptr)}
\end{itemize}


\section{Loading Objects On Demand}
\label{load_on_demand}

Since 2.5.0, there is limited support for loading objects on demand. 
An application can register a handler for loading objects dynamically. The
handler should have the signature {\tt omniORB::loader::mapKeyToObject\_t}:

{\small
\begin{verbatim}
  namespace omniORB {
    ...
    class loader {
    public:
      typedef CORBA::Object_ptr (*mapKeyToObject_t) (const objectKey& key);
      static void set(mapKeyToObject_t NewKeyToObject);
    };
  };
\end{verbatim}
}


When the ORB cannot locate the target object in this address space, it
calls the handler with the object key of the target. The handler is expected
to instantiate the object, either in this address space or in another
address space, and returns the object reference to the newly instantiated
object. The ORB will then reply with a LOCATION\_FORWARD message to instruct
the client to retry using the object reference returned by the handler.
When the handler returns, the ORB assumes ownership of the returned
value. It will call CORBA::release() on the returned value when it has
finished with it.
                                                                      
The handler may be called concurrently by multi-threads. Hence it  
must be thread-safe.                                               
                                                                      
If the handler cannot load the target object, it should return     
CORBA::Object::\_nil(). The object will be treated as non-existing. 
                                                                      
The application registers the handler with the ORB at runtime      
using omniORB::loader::set(). This function is not thread-safe.    
Calling this function again will replace the old handler with      
the new one.                                                       




\section{Object Keys}

omniORB uses a data type {\tt omniORB::objectKey} to uniquely
identify each object implementation. This is an opaque data type and 
can only be manipulated by the following functions:

{\small
\begin{verbatim}
void omniORB::generateNewKey(omniORB::objectKey &k);
\end{verbatim}
}

{\tt omniORB::generateNewKey} returns a new {\tt objectKey}. The return
value is guaranteed to be unique among the keys generated during this program
run. On the platforms that have a realtime clock and unique process
identifiers, a stronger assertion can be made, i.e. the keys are guaranteed
to be unique among all keys ever generated on the same machine.

{\small
\begin{verbatim}
const unsigned int omniORB::hash_table_size;
int omniORB::hash(omniORB::objectKey& k);
\end{verbatim}
}

{\tt omniORB::hash} returns the hash value of an {\tt objectKey}. The value
returned by this function is always between 0 and {\tt
omniORB:hash\_table\_size - 1} inclusively.

{\small
\begin{verbatim}
omniORB::objectKey omniORB::nullkey();
\end{verbatim}
}

{\tt omniORB::nullkey} always returns the same {\tt objectKey} value. This
key is guaranteed to hash to 0.

{\small
\begin{verbatim}
int operator==(const omniORB::objectKey &k1,const omniORB::objectKey &k2);
int operator!=(const omniORB::objectKey &k1,const omniORB::objectKey &k2);
\end{verbatim}
}

{\tt ObjectKeys} can be tested for equality using the overloaded {\tt
operator==} and {\tt operator!=}.

{\small
\begin{verbatim}
omniORB::seqOctets*
omniORB::keyToOctetSequence(const omniORB::objectKey &k1);

omniORB::objectKey
omniORB::octetSequenceToKey(const omniORB::seqOctets& seq);
\end{verbatim}
}

{\tt omniORB::keyToOctetSequence} takes an {\tt objectKey} and returns its
externalised representation in the form of a sequence of octets. The same
sequence can be converted back to an {\tt objectKey} using {\tt
omniORB::octetSequenceToKey}. If the supplied sequence is not an {\tt
objectKey}, {\tt omniORB::octetSequenceToKey} raises a {\tt CORBA::MARSHAL}
exception.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Proxy Objects}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

When a client acquires a reference to an object in another address
space, omniORB creates a local representation of the object and
returns a pointer to this object as its object reference. The local
representation is known as the proxy object.

The proxy object maps each IDL operation into a method to deliver
invocations to the remote object. The method implements argument
marshalling using the ORB runtime. When the ORB runtime detects an
error condition, it may raise a system exception. These exceptions
will normally be propagated by the proxy object to the application
code. However, there may be applications that prefer to have the
system exceptions trapped in the proxy object. For these applications,
it is possible to install exception handlers for individual proxy
objects or all proxy objects. The API to do this is explained in this
chapter.

As described in section~\ref{sec_intf}, proxy objects are created by
instances of the \type{proxyObjectFactory} class. For each IDL
interface A, the stubs of A contains a derived class of
\type{proxyObjectFactory} (\type{\_pof\_A}). This derived class is
responsible for creating proxy objects for A. This process is
completely transparent to the application. However, there may be
applications that require greater control on the creation of proxy
objects or even want to change the behavior of the proxy objects. To
cater for this requirement, applications can override the default
proxyObjectFactories and install their own versions of
proxyObjectFactories. The way to do this is explained in this chapter.




\section{Proxy Object Factories}

This section describes how an application can control the creation or
change the behaviour of proxy objects.


\subsection{Background}

For each interface A, its stub contains a proxy factory class
\type{\_pof\_A}. This class is derived from \type{proxyObjectFactory}
and implements three virtual functions:

\begin{cxxlisting}
class proxyObjectFactory {
public:

  const char *irRepoId() const;

  virtual CORBA::Boolean is_a(const char *base_repoId) const = 0;
       
  virtual CORBA::Object_ptr newObjRef(const char* mostDerivedTypeId,
                                      IOP::TaggedProfileList* profiles,
                                      omniIdentity* id,
                                      omniLocalIdentity* lid) = 0;Rope *r,
};
\end{cxxlisting}

As described in chapter~\ref{ch_intf}, the functions allow the ORB
runtime to perform type checking. The function \op{newObjRef} creates
a proxy object for A based on its input arguments. The return value is
a pointer to the class {\tt \_proxy\_A} which is automatically
re-casted into a {\tt CORBA::Object\_ptr}.  {\tt \_proxy\_A}
implements the proxy object for A:

{\small
\begin{verbatim}
class _proxy_A :  public virtual A {
public:

  _proxy_A (Rope *r,
            CORBA::Octet *key,
            size_t keysize,IOP::TaggedProfileList *profiles,
            CORBA::Boolean release);
  virtual ~_proxy_A();

  // plus other internal functions.

};
\end{verbatim}
}

The stub of A guarantees that exactly {\bf one} instance of
{\tt A\_proxyObjectFactory} is instantiated when an application is
executed. The constructor of {\tt A\_proxyObjectFactory}, via its
base class {\tt proxyObjectFactory} links the instance into the ORB's
proxy factory list. 

Newly instantiated proxy object factories are always entered at the front
of the ORB's proxy factory list. Moreover, when the ORB searches for a
match on the type, it always stops at the first match. In other words, when
additional instances of {\tt A\_proxyObjectFactory} or derived classes of
it are created, the last instantiation will override earlier instantiations
to be the proxy factory selected to create proxy objects of A. This
property can be used by an application to install its
own proxy object factories.

\subsection{An Example}

Using the {\tt Echo} example in chapter~\ref{chap:basic} as the basis, one
can tell the ORB to use a modified proxy object class to create proxy
objects. The steps involved are as follows:

\subsubsection{Define a new proxy class}

We define a new proxy class to cache the result of the last
invocation of {\tt echoString}.

{\small
\begin{verbatim}
class _new_proxy_Echo : public virtual _proxy_Echo {
public:
  _new_proxy_Echo (Rope *r,
                  CORBA::Octet *key,
                  size_t keysize,IOP::TaggedProfileList *profiles,
                  CORBA::Boolean release) 
         : _proxy_Echo(r,key,keysize,profiles,release),
           omniObject(Echo_IntfRepoID,r,key,keysize,profiles,release) 
   {
     // You have to look at the _proxy_Echo class and copy from its
     // ctor all the explicit ctor calls to its base member.
   }
   virtual ~_new_proxy_Echo() {}


   virtual char* echoString(const char* mesg) {
     //
     // Only calls the remote object if the argument is different from the
     // last invocation.

     omni_mutex_lock sync(lock);
     if ((char*)last_arg) {
       if (strcmp(mesg,(char*)last_arg) == 0) {
          return CORBA::string_dup(last_result);
       }
     }
     char* res = _proxy_Echo::echoString(mesg);
     last_arg = mesg;
     last_result = (const char*) res;
     return res;
   }

private:
  omni_mutex        lock;
  CORBA::String_var last_arg;
  CORBA::String_var last_result;
};
\end{verbatim}
}

\subsubsection{Define a new proxy factory class}

Next, we define a new proxy factory class to instantiate {\tt
\_new\_proxy\_Echo} as proxy objects for {\tt Echo}.

{\small
\begin{verbatim}
class _new_Echo_proxyObjectFactory : public virtual Echo_proxyObjectFactory
{
public:
   _new_Echo_proxyObjectFactory () {}
   virtual ~_new_Echo_proxyObjectFactory() {}

   // Only have to override newProxyObject
   virtual CORBA::Object_ptr newProxyObject(Rope *r,
                                            CORBA::Octet *key,
                                            size_t keysize,
                                            IOP::TaggedProfileList *profiles,
                                            CORBA::Boolean release) {
      _new_proxy_Echo *p = new _new_proxy_Echo(r,key,keysize,profiles,release);
      return p;
   }
};
\end{verbatim}
}

Finally, we have to instantiate a single instance of the new proxy factory
in the application code.

{\small
\begin{verbatim}
int main(int argc, char** argv)
{
   // Other initialisation steps

   _new_Echo_proxyObjectFactory* f =  new _new_Echo_proxyObjectFactory;

   // Use the new operator to instantiate the proxy factory and never
   // call the delete operator on this instance.

   // From this point onwards, _new_proxy_Echo will be used to create
   // proxy objects for Echo.

}
\end{verbatim}
}

\subsection{Further Considerations}

Notice that the ORB may call {\tt newProxyObject} multiple times to create
proxy objects for the same remote object. In other words, the ORB does not
guarantee that only one proxy object is created for each remote
object. For applications that require this guarantee, it is necessary to
check within {\tt newProxyObject} whether a proxy object has already been
created for the current request. If the argument {\tt Rope* r} points to
the same structure and the content of the sequence {\tt CORBA::Octet* key} is
the same, then an existing proxy object can be returned to satisfy the
current request. Do not forget to call {\tt CORBA::duplicate()} before
returning the object reference.

{\tt newProxyObject} may be called concurrently by different threads within
the ORB. Needless to say, the function must be thread-safe.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Dynamic Management of Any Values}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hyphenation{Dyn-Any}

In CORBA specification 2.2, a new facility---\term{DynAny} was
introduced. Previously, it was not possible to insert or extract
constructed and other complex types from an Any without using the stub
code generated by an idl compiler for these types. This makes it
impossible to write generic servers (bridges, event channels
supporting filtering, etc.) because these servers can not have static
knowledge of all the possible data types that they have to handle.

To fill this gap, the DynAny facility is defined to enable traversal
of the data value associated with an Any at runtime and extraction of
its constituents. This facility also enables the construction of an
Any at runtime, without having static knowledge of its types.

This chapter describes how DynAny may be used. For completeness, you
should also read the DynAny specification defined in Chapter 9 of the
CORBA 2.3 specification. Where possible, the implementation in omniORB
adheres closely to the specification. However, there are areas in the
specification that are ambiguous or lacking in details. A number of
these issues are currently opened with the ORB revision task force.
Until the issues are resolved, it is possible that a different
implementation may choose to interpret the specification differently.
This chapter provides clarifications to the specification, explains
the interpretation used and offers some advice and warnings on
potential portability problems.

Notice that the DynAny interface has been changed in CORBA 2.3,
particularly with the addition of the support for the IDL type
\type{valuetype}.  Future releases of omniORB will be updated to
implement the interface as defined in CORBA 2.3.

\section{C++ mapping}

\begin{cxxlisting}
// namespace CORBA

class ORB {
public:
  ...

  class InconsistentTypeCode : public UserException { ... };

  DynAny_ptr create_dyn_any(const Any& value);

  DynAny_ptr create_basic_dyn_any(TypeCode_ptr tc);

  DynStruct_ptr create_dyn_struct(TypeCode_ptr tc);

  DynSequence_ptr create_dyn_sequence(TypeCode_ptr tc);

  DynArray_ptr create_dyn_array(TypeCode_ptr tc);

  DynUnion_ptr create_dyn_union(TypeCode_ptr tc);

  DynEnum_ptr create_dyn_enum(TypeCode_ptr tc);

};

typedef DynAny* DynAny_ptr;
class DynAny_var { ... };

class DynAny {
public:    

  class Invalid : public UserException { ... };
  class InvalidValue : public UserException { ... };
  class TypeMismatch : public UserException { ... };
  class InvalidSeq : public UserException { ... };

  typedef _CORBA_Unbounded_Sequence__Octet OctetSeq;

  TypeCode_ptr type() const;

  void assign(DynAny_ptr dyn_any) throw(Invalid,SystemException);
  void from_any(const Any& value) throw(Invalid,SystemException);
  Any* to_any() throw(Invalid,SystemException);
  void destroy();
  DynAny_ptr copy();

  DynAny_ptr current_component();
  Boolean next();
  Boolean seek(Long index);
  void rewind();

  void insert_boolean(Boolean value) throw(InvalidValue,SystemException);
  void insert_octet(Octet value) throw(InvalidValue,SystemException);
  void insert_char(Char value) throw(InvalidValue,SystemException);
  void insert_short(Short value) throw(InvalidValue,SystemException);
  void insert_ushort(UShort value) throw(InvalidValue,SystemException);
  void insert_long(Long value) throw(InvalidValue,SystemException);
  void insert_ulong(ULong value) throw(InvalidValue,SystemException);
  void insert_float(Float value) throw(InvalidValue,SystemException);
  void insert_double(Double value) throw(InvalidValue,SystemException);
  void insert_string(const char* value) throw(InvalidValue,SystemException);
  void insert_reference(Object_ptr v) throw(InvalidValue,SystemException);
  void insert_typecode(TypeCode_ptr v) throw(InvalidValue,SystemException);
  void insert_any(const Any& value) throw(InvalidValue,SystemException);

  Boolean get_boolean() throw(TypeMismatch,SystemException);
  Octet get_octet() throw(TypeMismatch,SystemException);
  Char get_char() throw(TypeMismatch,SystemException);
  Short get_short() throw(TypeMismatch,SystemException);
  UShort get_ushort() throw(TypeMismatch,SystemException);
  Long get_long() throw(TypeMismatch,SystemException);
  ULong get_ulong() throw(TypeMismatch,SystemException);
  Float get_float() throw(TypeMismatch,SystemException);
  Double get_double() throw(TypeMismatch,SystemException);
  char* get_string() throw(TypeMismatch,SystemException);
  Object_ptr get_reference() throw(TypeMismatch,SystemException);
  TypeCode_ptr get_typecode() throw(TypeMismatch,SystemException);
  Any* get_any() throw(TypeMismatch,SystemException);

  static DynAny_ptr _duplicate(DynAny_ptr);
  static DynAny_ptr _narrow(DynAny_ptr);
  static DynAny_ptr _nil();
};

// DynFixed is not supported.

typedef DynEnum* DynEnum_ptr;
class DynEnum_var { ... };

class DynEnum :  public DynAny {
public:

  char* value_as_string();
  void value_as_string(const char* value);
  ULong value_as_ulong();
  void value_as_ulong(ULong value);

  static DynEnum_ptr _duplicate(DynEnum_ptr);
  static DynEnum_ptr _narrow(DynAny_ptr);
  static DynEnum_ptr _nil();
};

typedef char* FieldName;
typedef String_var FieldName_var;

struct NameValuePair {
  String_member id;
  Any value;
};

typedef _CORBA_ConstrType_Variable_Var<NameValuePair> NameValuePair_var;
typedef _CORBA_Unbounded_Sequence<NameValuePair > NameValuePairSeq;

typedef DynStruct* DynStruct_ptr;
class DynStruct_var { ... };

class DynStruct :  public DynAny {
public:

  char*  current_member_name();
  TCKind current_member_kind();
  NameValuePairSeq* get_members();
  void set_members(const NameValuePairSeq& NVSeqVal)
                   throw(InvalidSeq,SystemException);

  static DynStruct_ptr _duplicate(DynStruct_ptr);
  static DynStruct_ptr _narrow(DynAny_ptr);
  static DynStruct_ptr _nil();
};

typedef DynUnion* DynUnion_ptr;
class DynUnion_var { ... };

class DynUnion :  public DynAny {
public:

  Boolean set_as_default();
  void set_as_default(Boolean value);
  DynAny_ptr discriminator();
  TCKind discriminator_kind();
  DynAny_ptr member();
  char*  member_name();
  void member_name(const char* value);
  TCKind member_kind();

  static DynUnion_ptr _duplicate(DynUnion_ptr);
  static DynUnion_ptr _narrow(DynAny_ptr);
  static DynUnion_ptr _nil();
};

typedef _CORBA_Unbounded_Sequence<Any > AnySeq;

typedef DynSequence* DynSequence_ptr;
class DynSequence_var { ... };

class DynSequence :  public DynAny {
public:

  ULong length();
  void length (ULong value);
  AnySeq* get_elements();
  void set_elements(const AnySeq& value) throw(InvalidValue,SystemException);

  static DynSequence_ptr _duplicate(DynSequence_ptr);
  static DynSequence_ptr _narrow(DynAny_ptr);
  static DynSequence_ptr _nil();
};

typedef DynArray* DynArray_ptr;
class DynArray_var { ... };

class DynArray : public DynAny {
public:

  AnySeq* get_elements();
  void set_elements(const AnySeq& value) throw(InvalidValue,SystemException);

  static DynArray_ptr _duplicate(DynArray_ptr);
  static DynArray_ptr _narrow(DynAny_ptr);
  static DynArray_ptr _nil();
};
\end{cxxlisting}

\section{The DynAny Interface}
\label{dynany}

\subsection{Example: extract data values from an Any}

If an Any contains a value of one of the basic data types, its value
can be extracted using the pre-defined operators in the Any interface.
When the value is a struct or other non-basic types, one can use the
DynAny interface to extract its constituent values.

In this section, we use a struct as an example to illustrate how the
DynAny interface can be used.

The example struct is as follows:

\begin{idllisting}
// IDL
struct exampleStruct1 {
  string s;
  double d;
  long   l;
};
\end{idllisting}

To create a DynAny from an Any value, one uses the
\op{create\_dyn\_any} method:

\begin{cxxlisting}
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
  
Any v;
...       // Initialise v to contain a value of type exampleStruct1.
  
CORBA::DynAny_var dv = orb->create_dyn_any(v);
\end{cxxlisting}

Like CORBA object and pseudo object references, a \type{DynAny\_ptr}
can be managed by a \type{\_var} type (\type{DynAny\_var}) which will
release the \type{DynAny\_ptr} automatically when the variable goes
out of scope.

\subsubsection{Iterate through the components}
\label{dynanyiterate}

Once the DynAny object is created, we can use the DynAny interface to
extract the individual components in \type{exampleStruct1}. The DynAny
interface provides a number of functions to extract and insert
component values. These functions are defined to operate on the
component identified by the \term{current component} pointer.

A \term{current component} pointer is an internal state of a DynAny
object. When a DynAny object is created, the pointer is initialised
to point to the first component of the any value.

The pointer can be advanced to the next component with the \op{next}
operation. The function returns FALSE (0) if there are no more
components.  Otherwise it returns TRUE (1). When the any value in the
DynAny object contains only one component, the \op{next()} operation
always returns FALSE(0).

Another way of adjusting the pointer is the \op{seek} operation. The
function returns FALSE (0) if there is no component at the specified
index. Otherwise it returns TRUE (1). The index value of the first
component is zero. Therefore, a \code{seek(0)} call rewinds the
pointer to the first component, this is also equivalent to a call to
the \op{rewind} operation.

For completeness, we should also mention here the
\op{current\_component} operation. This operation causes the DynAny
object to return a reference to another DynAny object that can be used
to access the current component. It is possible that the current
component pointer is not pointing to a valid component, for instance,
the \op{next} operation has been invoked and there is no more
component. Under this circumstance, the \op{current\_component}
operation returns a nil DynAny object reference\footnote{Testing a nil
DynAny object with CORBA::is\_nil() returns TRUE(1). The CORBA 2.2
specification does not specify what is the return value of this
function when the current component pointer is invalid. To ensure
portability, it is best to avoid calling \op{current\_component} under
this condition.}. For components which are just basic data types,
calling \op{current\_component} is an overkill because we can just use
the basic type extraction and insertion functions directly.

\subsubsection{Extract basic type components}

In our example, the component values can be extracted as follows:

\begin{cxxlisting}
CORBA::String_var s = dv->get_string();
CORBA::Double     d = dv->get_double();
CORBA::Long       l = dv->get_long();
\end{cxxlisting}

Each get basic type operation has the side-effect of advancing the
current component pointer. For instance:

\begin{cxxlisting}
CORBA::String_var s = dv->get_string();
\end{cxxlisting}

is equivalent to:

\begin{cxxlisting}
CORBA::DynAny_var temp = dv->current_component();
CORBA::String_var s = temp->get_string();
dv->next();
\end{cxxlisting}

The get operations ensure that the current component is of the same
type as requested. Otherwise, the object throws a \code{TypeMismatch}
exception. If the current component pointer is invalid when a get
operation is called, the object also throws a \code{TypeMismatch}
exception\footnote{The CORBA 2.2 specification does not define the
behavior of this error condition. To ensure portability, it is best to
avoid calling the get operations when the current component pointer is
known to be invalid.}.

To repeatedly access the components, one can use the \op{rewind} or
\op{seek} operations to manipulate the current component pointer. For
instance, to access the \code{d} member in \type{exampleStruct1}
directly:

\begin{cxxlisting}
dv->seek(1);       // position current component to member d.
CORBA::Double d = dv->get_double();
\end{cxxlisting}

\subsubsection{Extract complex components}

When a component is not one of the basic data types, it is not
possible to extract its value using the get operations. Instead, a
DynAny object has to be created from which the component is accessed.

Consider this example:

\begin{idllisting}
// IDL
struct exampleStruct2 {
  string m1;
  exampleStruct1 m2;
};
\end{idllisting}

In order to extract the data members within \code{m2} (of type
\type{exampleStruct1}), we use \op{current\_component} as follows:

\begin{cxxlisting}
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
Any v;
...       // Initialise v to contain a value of type exampleStruct2.

CORBA::DynAny_var dv = orb->create_dyn_any(v);

CORBA::String_var m1 = dv->get_string();  // extract member m1
CORBA::DynAny_var dm = dv->current_component(); // DynAny reference to m2
CORBA::String_var s = dm->get_string();   // m2.s
CORBA::Double     d = dm->get_double();   // m2.d
CORBA::Long       l = dm->get_long();     // m2.l
\end{cxxlisting}


\subsubsection{Clean-up}
Now we finish off this example with a description on destroying DynAny
objects. There are two points to remember:

\begin{enumerate}
\item A DynAny reference (\type{DynAny\_ptr}) is like any CORBA object
or psuedo object reference and should be handled in the same way. In
particular, one has to call the \op{CORBA::release} operation to
indicate that a DynAny reference will no longer be accessed. In the
example, this is done automatically by \type{DynAny\_var}.

\item A DynAny object and its references are separate entities, just
as a CORBA object implementation and its object references are
different entities. While \op{CORBA::release} will release any
resources associated with a \type{DynAny\_\dsc{}ptr}, one has to
separately destroy the DynAny object to avoid any memory leak. This is
done by calling the \op{destroy()} operation.
\end{enumerate}

In the example, the DynAny object can be destroyed as follows:

\begin{cxxlisting}
// C++
...
CORBA::DynAny_var dv = orb->create_dyn_any(v);
...
dv->destroy();

// From now on, one should not invoke any operation in dv.
// Otherwise the behaviour is undefined.
\end{cxxlisting}


\subsection{Example: insert data values into an Any}

Using the DynAny interface, one can create an Any value from scratch.
In this example, we are going to create an Any containing a value of
the \type{exampleStruct1} type.

First, we have to create a DynAny to store the value using one of the
\op{create\_\dsc{}dyn} functions. Because \type{exampleStruct1} is a
struct, we use the \op{create\_\dsc{}dyn\_\dsc{}struct} operation.

\begin{cxxlisting}
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.

// create the TypeCode for exampleStruct.
StructMemberSeq tc_members;
tc_members.length(3);
tc_members[0].name = (const char*)"s";
tc_members[0].type = CORBA::TypeCode::_duplicate(CORBA::_tc_string);
tc_members[0].type_def = CORBA::IDLType::_nil();
tc_members[1].name = (const char*)"d";
tc_members[1].type = CORBA::TypeCode::_duplicate(CORBA::_tc_double);
tc_members[1].type_def = CORBA::IDLType::_nil();
tc_members[2].name = (const char*)"l";
tc_members[2].type = CORBA::TypeCode::_duplicate(CORBA::_tc_long);
tc_members[2].type_def = CORBA::IDLType::_nil();
CORBA::TypeCode_var tc = orb->create_struct_tc("IDL:exampleStruct1:1.0",
                                               "exampleStruct1",
                                               tc_members);

// create the DynAny object to represent the any value
CORBA::DynAny_var dv = orb->create_dyn_struct(tc);
\end{cxxlisting}


\subsubsection{Insert basic type components}

Once the DynAny object is created, we can use the DynAny interface to
insert the components. The DynAny interface provides a number of
insert operations to insert basic types into the any value. In our
example, the component values can be inserted as follows:

\begin{cxxlisting}
CORBA::String_var s = (const char*)"Hello";
CORBA::Double     d = 3.1416;
CORBA::Long       l = 1;

dv->insert_string(s);
dv->insert_double(d);
dv->insert_long(l);
\end{cxxlisting}

Each insert basic type operation has the side-effect of advancing the
current component pointer. For instance:

\begin{cxxlisting}
dv->insert_string(s);
\end{cxxlisting}

is equivalent to:

\begin{cxxlisting}
CORBA::DynAny_var temp = dv->current_component();
temp->insert_string(s);
dv->next();
\end{cxxlisting}

The insert operations ensure that the current component is of the same
type as the inserted value. Otherwise, the object throws an
\code{InvalidValue} exception. If the current component pointer is
invalid when an insert operation is called, the object also throws a
\code{InvalidValue} exception\footnote{The CORBA 2.2 specification
does not define the behavior of this error condition. To ensure
portability, it is best to avoid calling the insert operations when
the current component pointer is known to be invalid.}.

Sometimes, one may just want to modify one component in an Any
value. For instance, one may just want to change the value of the
double member in \type{exampleStruct1}. This can be done as follows:

\begin{cxxlisting}
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.

Any v;
...       // Initialise v to contain a value of type exampleStruct1.

CORBA::Double d = 6.28;

CORBA::DynAny_var dv = orb->create_dyn_any(v);

dv->seek(1);
dv->insert_double(d);    // Change the value of the member d.
\end{cxxlisting}

Finally, the any value can be obtained from the DynAny object using
the \op{to\_any} operation:

\begin{cxxlisting}
CORBA::Any_var v = dv->to_any();    // Obtain the any value.
\end{cxxlisting}


\subsubsection{Insert complex components}

When a component is not one of the basic data types, it is not
possible to insert its value using the insert operations. Instead, a
DynAny object has to be created through which the component can be
inserted.

In our example, one can insert component values into
\type{exampleStruct2} as follows:

\begin{cxxlisting}
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
  
CORBA::TypeCode_var tc;
// create the TypeCode for exampleStruct2.
...
// create the DynAny object to represent the any value
CORBA::DynAny_var dv = orb->create_dyn_struct(tc);
  
CORBA::String_var m1  = (const char*)"Greetings";
CORBA::String_var m2s = (const char*)"Hello";
CORBA::Double     m2d = 3.1416;
CORBA::Long       m2l = 1;
  
dv->insert_string(m1);   // insert member m1
CORBA::DynAny_var dm = dv->current_component(); // DynAny reference to m2
dm->insert_string(m2s);  // insert member m2.s
dm->insert_double(m2d);  // insert member m2.d
dm->insert_long(m2l);    // insert member m2.l
  
CORBA::Any_var v = dv->to_any();  // obtain the any value
  
dv->destroy();          // destroy the DynAny object.
                        // No operation should be invoked on dv
                        // from this point on except CORBA::release.
\end{cxxlisting}


In addition to the DynAny interface, a number of derived interfaces
are defined. These interfaces are specialisation of the DynAny
interface to facilitate the handling of any values containing
non-basic types: struct, sequence, array, enum and union\footnote{In
the CORBA 2.2 specification, the DynFixed interface is defined to
handle the fixed data type. This is not supported in this
implementation.}. The next few sections will provide more details on
these interfaces.

\section{The DynStruct Interface}

When a DynAny object is created through the \op{create\_dyn\_any}
operation and the any value contains a struct type, a \type{DynStruct}
object is created. The DynAny reference returned can be narrowed to a
\type{DynStruct} reference using the \op{CORBA::DynStruct::\_narrow}
operation.

In the previous example, the components are extracted using the get
operations. Alternatively, the DynStruct interface provides an
additional operation (\op{get\_members}) to return all the components
in a single call. The returned value is a sequence of name value
pairs. The member name is given in the name field and its value is
returned as an Any value.  For example, an alternative way to extract
the components in the previous example is as follows:

\begin{cxxlisting}
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
Any v;
...       // Initialise v to contain a value of type exampleStruct1.
CORBA::DynAny_var dv = orb->create_dyn_any(v);
  
CORBA::DynStruct_var ds = CORBA::DynStruct::_narrow(dv);
  
CORBA::NameValuePairSeq* sq = ds->get_members();
  
char*         s;
CORBA::Double d;
CORBA::Long   l;
  
(*sq)[0].value >>= s;        // 1st element contains member s
(*sq)[1].value >>= d;        // 2nd element contains member d
(*sq)[2].value >>= l;        // 3rd element contains member l
\end{cxxlisting}


Similarly, the DynStruct interface provides an additional operation
(\op{set\_members}) to insert all the components in a single call. The
following is an alternative way to insert the components of the type
\type{exampleStruct1} into an Any value:

\begin{cxxlisting}
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
  
CORBA::TypeCode_var tc;
// create the TypeCode for exampleStruct1.
...
// create the DynAny object to represent the any value
CORBA::DynAny_var dv = orb->create_dyn_struct(tc);
  
CORBA::String_var s = (const char*)"Hello";
CORBA::Double     d = 3.1416;
CORBA::Long       l = 1;
  
CORBA::NameValuePairSeq sq;
sq.length(3);
sq[0].id = (const char*)"s";
sq[0].value <<= CORBA::Any::from_string(s,0); 
                               // 1st element contains member s
sq[1].id = (const char*)"d";
sq[1].value <<= d;             // 2nd element contains member d
sq[2].id = (const char*)"l";
sq[2].value <<= l;             // 3rd element contains member l
  
dv->set_members(sq);    
\end{cxxlisting}

Notice that the name-value pairs in the argument to \op{set\_members}
must match the members of the struct exactly or the object would throw
the \code{InvalidSeq} exception.

In addition to the \op{current\_component} operation, the DynStruct
interface provides two operations: \op{current\_member\_name} and
\op{current\_member\_\dsc{}kind}, to return information about the
current component.

\section{The DynSequence Interface}

Like struct values, sequence values can be traversed using the
operations introduced in section~\ref{dynany}. The first sequence
element can be accessed as the first DynAny component, the second
sequence element as the second DynAny component and so on.

To extract component values from an Any containing a sequence, the
length of the sequence can be obtained using the get length operation
in the DynSequence interface. Here is an example to extract the
components of a sequence of long:

\begin{cxxlisting}
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
Any v;
...       // Initialise v to contain a value of a sequence of long
CORBA::DynAny_var dv = orb->create_dyn_any(v);
  
CORBA::DynSequence_var ds = CORBA::DynSequence::_narrow(dv);
CORBA::ULong len = ds->length();     // extract the length of the sequence
CORBA::ULong index;
for (index = 0; index < len; index++) {
  CORBA::Long v = ds->get_long();
  cerr << "[" << index << "] = " << v << endl;
}
\end{cxxlisting}

Conversely, the set length operation is provided to set the length of
the sequence. Here is an example to insert the components of a
sequence of long:

\begin{cxxlisting}
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
  
CORBA::TypeCode_var tc;
// create the TypeCode for a sequence of long.
...
// create the DynAny object to represent the any value
CORBA::DynSequence_var ds = orb->create_dyn_sequence(tc);
  
CORBA::ULong len = 3;
  
ds->length(len);             // set the length of the sequence
  
CORBA::ULong index;
for (index = 0; index < len; index++) {
  ds->insert_long(index);    // insert a sequence element
}
\end{cxxlisting}

Similar to the DynStruct interface, the \op{get\_elements} operation
is provided to return all the sequence elements and the
\op{set\_elements} operation is provided to insert all the sequence
elements.

\section{The DynArray Interface}

Array values are handled by the DynArray interface. The DynArray
interface is the same as the DynSequence interface except that the
former does not provide the set length and get length operations.

\section{The DynEnum Interface}

Enum values are handled by the DynEnum interface. A DynEnum object
contains a single component which is the enum value. This value cannot
be extracted or inserted using the get and insert operations of the
DynAny interface. Instead, two pairs of operations are provided to
handle this value.

The \op{value\_as\_string} operation allows the enum value to be
extracted or inserted as a string. The \op{value\_as\_ulong} operation
allows the enum value to be extracted or inserted as an unsigned long.


\section{The DynUnion Interface}

Union values are handled by the DynUnion interface. Unfortunately, the
CORBA 2.2 specification does not define the DynUnion interface in
sufficient details to nail down its intended usage\footnote{This
interface is currently an open issue with the ORB revision task
force.}. In this section, we try to fill in the gaps and describe a
sensible way to use the DynUnion interface. Where necessary, the
semantics of the operations is clarified. It is possible that the
behavior of this interface in another ORB is different from this
implementation. Where appropriate, we give warnings on usage that
might cause problems with portability.

In relation to the current component pointer
(section~\ref{dynanyiterate}), a DynUnion object contains two
components. The first component (with the index value equals 0) is the
discriminator value, the second one is the member value.  Therefore,
one can use the \op{seek} and \op{current\_component} operations to
obtain a reference to the DynAny objects that handle the two
components. However, it is better to use the operations defined in the
DynUnion interface to manipulate these components as the semantics of
the operations is easier to understand.

\subsection{Three Categories of Union}
\label{dynunioncat}

Before we continue, it is important to understand that unions can be
classified into the following categories:

\begin{enumerate}
\item One that has a default branch defined in the IDL. This will be
called \term{explicit default union} in the rest of this section.
\item One that has no default branch and not all the possible values
of the discriminator type are covered by the branch labels in the IDL.
This will be called \term{implicit default union}.
\item One that has no default branch but all the possible values of
the discriminator type are covered. This will be called \term{no
default union}.
\end{enumerate}

Of the three categories, the implicit default union is interesting
because by definition if the discriminator value is not equal to any
of the branch labels, the union has \emph{no} member. That is, the
union value consists solely of the discriminator value.

\subsection{Example: extract data values from a union}

\subsubsection{Explicit default union}

Consider a union of the following type:

\begin{idllisting}
// IDL
union exampleUnion1 switch(boolean) {
case TRUE: long l;
default:   double d; 
};
\end{idllisting}

The most straightforward way to extract the member value is as
follows:

\begin{cxxlisting}
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
  
Any v;
...       // Initialise v to contain a value of type exampleUnion1.
  
CORBA::DynAny_var dv = orb->create_dyn_any(v);
CORBA::DynUnion_var du = CORBA::DynUnion::_narrow(dv);
  
CORBA::String_var di = du->member_name();
CORBA::DynAny_var dm = du->member();
  
if (strcmp((const char*)di,"l") == 0) {
  // branch label is TRUE
  CORBA::Long v = dm->get_long();
  cerr << "l = " << v << endl;
}
  
if (strcmp((const char*)di,"d") == 0) {
  // Is default branch
  CORBA::Double v = dm->get_double();
  cerr << "d = " << v << endl;
}
\end{cxxlisting}

In the example, the operation \op{member\_name} is used to determine
which branch the union has been instantiated. The operation
\op{member} is used to obtain a reference to the DynAny object that
handles the member.

Alternatively, the branch can be determined by reading the
discriminator value:

\begin{cxxlisting}
// C++
CORBA::DynAny_var di = du->discriminator();
CORBA::DynAny_var dm = du->member();
  
CORBA::Boolean di_v = di->get_boolean();
  
switch (di_v) {
case 1:
  CORBA::Long v = dm->get_long();
  cerr << "l = " << v << endl;
  break;
default:
  CORBA::Double v = dm->get_double();
  cerr << "d = " << v << endl;
}
\end{cxxlisting}

The operation \op{discriminator} is used to obtain the value of the
discriminator.

Finally, the third way to determine the branch is to test if the
default is selected:

\begin{cxxlisting}
// C++
switch (dv->set_as_default()) {
case 1:
  CORBA::Double v = dm->get_double();
  cerr << "d = " << v << endl;
  break;
default:
  CORBA::Long v = dm->get_long();
  cerr << "l = " << v << endl;
}
\end{cxxlisting}

The operation \op{set\_as\_default()} returns TRUE (1) if the
discriminator has been assigned a valid default value.


\subsubsection{Implicit default union}

Consider a union of the following type:

\begin{idllisting}
// IDL
union exampleUnion2 switch(long) {
case 1: long l;
case 2: double d; 
};
\end{idllisting}

This example is similar to the previous one but there is no default
branch.  The description above also applies to this example. However,
the discriminator may be set to neither 1 nor 2. Under this condition,
the implicit default is selected and the union value contains the
discriminator only!

When the discriminator contains an implicit default value, one might
ask what is the value returned by the \op{member\_name} and
\op{member} operation. Since there is no member in the union value,
omniORB returns a null string and a nil DynAny reference respectively.
This behavior is not specified in the CORBA 2.2 specification. To
ensure that your application is portable, it is best to avoid calling
these operations when the DynUnion object might contain an implicit
default value.

\subsubsection{No default union}

This is the last union category. For instance:

\begin{idllisting}
// IDL
union exampleUnion3 switch(boolean) {
case TRUE: long l;
case FALSE: double d; 
};
\end{idllisting}

In this example, all the possible values of the discriminator are used
as union labels. There is no default branch. The only difference
between this category and the explicit default union is that the
\op{set\_as\_default} operation always returns FALSE (0).


\subsection{Example: insert data values into a union}

Writing into a union involves selecting the union branch with the
appropriate discriminator value and then writing the member value.
There are three ways to set the discriminator value:

\begin{enumerate}

\item Use the \op{member\_name()} write operation to specify the union
branch by specifying the union member directly. This operation has the
side effect of setting the discriminator to the label value of the
branch.

\item Write the label value of a union branch into the DynAny object
that handles the discriminator.

\item If the union has a default branch, either explicitly or
implicitly, use the \op{set\_\dsc{}as\_default()} write operation to
set the discriminator to a valid default value.

\end{enumerate}

The following example shows the three ways of writing into a union:

\begin{cxxlisting}
// C++
CORBA::ORB_ptr orb;  // orb initialised by CORBA::ORB_init.
  
CORBA::TypeCode_var tc;
// create the TypeCode for exampleUnion1.
...
// create the DynAny object to represent the any value
CORBA::DynUnion_var dv = orb->create_dyn_union(tc);
  
CORBA::Any_var v;
DynAny_ptr dm;
  
// Use member_name to select the union branch
dv->member_name("l");
dm = dv->member();
dm->insert_long(10);
v = dv->to_any();          // transfer to an Any
CORBA::release(dm);

// Setting the discriminator value to select the union branch
CORBA::DynAny_var di = dv->discriminator();
di->insert_boolean(1);     // set discriminator to label TRUE
dm = dv->member();
dm->insert_long(20);
v = dv->to_any();          // transfer to an Any
CORBA::release(dm);

// Use set_as_default to select the default union branch
dv->set_as_default(1);
dm = dv->member();
dm->insert_double(3.14);
v = dv->to_any();          // transfer to an Any
CORBA::release(dm);

dv->destroy();
\end{cxxlisting}


\subsubsection{Ambiguous usage}

\begin{enumerate}

\item When the discriminator is set to a different value, a different
member branch is selected. Suppose the application has previously
obtained a DynAny reference to a union member when it changes the
discriminator value. As a result of the value change, the union is now
instantiated to another union branch, i.e.\ a call to the \op{member}
operation will now return a reference to a different DynAny object. If
the application continues to access the DynAny object of the old union
member, the behavior of the ORB under this condition is not defined by
the CORBA 2.2 specification. With omniORB, the DynAny object of the
old union member is detached from the union when a new union branch is
selected. Therefore reading or writing this object will not have any
relation to the current value of the union. To avoid this ambiguity,
the reference to the old union member should be released before a
different union branch is selected.

\item The write operation \op{set\_as\_default} takes a boolean
argument. It is ambiguous to call this function with the argument set
to FALSE (0). With omniORB, such a call will be silently ignored.

\item It is also ambiguous to pass the value TRUE (1) to the
\op{set\_as\_default} operation when the union is a no default union
(\ref{dynunioncat}). With omniORB, such a call will be silently
ignored.

\item When the discriminator value is not set, calling the \op{member}
operation is ambiguous. With omniORB, such a call will return a nil
DynAny reference. Similarly, a call to the \op{member\_kind} operation
under this condition will return \code{tk\_null}.

\end{enumerate}

To ensure portability, it is best to avoid using the DynUnion
interface and not to rely on the ORB to behave as omniORB does under
these ambiguous conditions.

\section{Duplicate DynAny References}

Like any CORBA object and psuedo object references, a DynAny reference
can be duplicated using the \op{\_duplicate()} operations. When an
application has obtained multiple DynAny references to the same DynAny
object, it should be noted that a change made to the object by
invoking on one reference is also visible through the other
references. In particular, if a call through one reference has caused
the current component pointer to be changed, subsequent calls through
other references will operate on the new current component pointer.


\section{Other Operations}

The following is a short summary of the other operations in the DynAny
interface which have not been covered in previous sections:

\begin{description}
\item[\op{assign}] initialises a DynAny object with another DynAny
object. The two objects must have the same typecode.

\item[\op{from\_any}] initialises a DynAny object from the value in an
any. The typecode in the two objects must be the same.

\item[\op{copy}] creates a new DynAny object whose value is a deep
copy of the current object.

\item[\op{type}] returns the typecode associated with the DynAny
object.

\end{description}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{The Dynamic Invocation Interface}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The Dynamic Invocation Interface (or DII) allows applications to
invoke operations on CORBA objects about which they have no static
information. That is to say the application has not been linked with
stub code which performs the remote operation invocation. Thus using
the DII applications may invoke operations on \emph{any} CORBA object,
possibly determining the object's interface dynamically by using an
Interface Repository.
% ?? Ref IR section?

This chapter presents an overview of the Dynamic Invocation Interface.
A toy example use of the DII can be found in the omniORB distribution
in the \file{src/examples/dii} directory.  The DII makes extensive use
of the type Any, so ensure that you have read chapter~\ref{ch_any}.
For more information refer to the Dynamic Invocation Interface and C++
Mapping sections of the CORBA specification~\cite{corba23-spec}.


\section{Overview}

To invoke an operation on a CORBA object an application needs an
object reference, the name of the operation and a list of the
parameters. In addition the application must know whether the
operation is one-way, what user-defined exceptions it may throw, any
user-context strings which must be supplied, a `context' to take these
values from and the type of the returned value. This information is
given by the IDL interface declaration, and so is normally made
available to the application via the stub code. In the DII this
information is encapsulated in the \type{CORBA::Request}
pseudo-object.

To perform an operation invocation the application must obtain an
instance of a \type{Request} object, supply the information listed
above and call one of the methods to actually make the invocation. If
the invocation causes an exception to be thrown then this may be
retrieved and inspected, or the return value on success.


\section{Pseudo Objects}

The DII defines a number of psuedo-object types, all defined in the
\code{CORBA} namespace. These objects behave in many ways like CORBA
objects. They should only be accessed by reference (through
\type{foo\_ptr} or \type{foo\_var}), may not be instantiated directly
and should be released by calling \op{CORBA::release}\footnote{if not
managed by a \type{\_var} type.}.  A nil reference should only be
represented by \code{foo::\_nil()}.

These pseudo objects, although defined in pseudo-IDL in the
specification do not follow the normal mapping for CORBA objects. In
particular the memory management rules are different---see the CORBA
2.3 specification~\cite{corba23-spec} for more details. New instances
of these objects may only be created by the ORB. A number of methods
are defined in \type{CORBA::ORB} to do this.


\subsection{Request}

A \type{Request} encapsulates a single operation invocation. It may
\emph{not} be re-used---even for another call with the same arguments.

\begin{cxxlisting}
class Request {
public:
  virtual Object_ptr        target() const;
  virtual const char*       operation() const;
  virtual NVList_ptr        arguments();
  virtual NamedValue_ptr    result();
  virtual Environment_ptr   env();
  virtual ExceptionList_ptr exceptions();
  virtual ContextList_ptr   contexts();
  virtual Context_ptr       ctxt() const;
  virtual void              ctx(Context_ptr);

  virtual Any& add_in_arg();
  virtual Any& add_in_arg(const char* name);
  virtual Any& add_inout_arg();
  virtual Any& add_inout_arg(const char* name);
  virtual Any& add_out_arg();
  virtual Any& add_out_arg(const char* name);

  virtual void set_return_type(TypeCode_ptr tc);
  virtual Any& return_value();

  virtual Status  invoke();
  virtual Status  send_oneway();
  virtual Status  send_deferred();
  virtual Status  get_response();
  virtual Boolean poll_response();

  static Request_ptr _duplicate(Request_ptr);
  static Request_ptr _nil();
};
\end{cxxlisting}


\subsection{NamedValue}

A pair consisting of a string and a value---encapsulated in an Any.
The name is optional. This type is used to encapsulate parameters and
returned values.

\begin{cxxlisting}
class NamedValue {
public:
  virtual const char* name() const;
  // Retains ownership of return value.

  virtual Any* value() const;
  // Retains ownership of return value.

  virtual Flags flags() const;

  static NamedValue_ptr _duplicate(NamedValue_ptr);
  static NamedValue_ptr _nil();
};
\end{cxxlisting}


\subsection{NVList}

A list of \type{NamedValue} objects.

\begin{cxxlisting}
class NVList {
public:
  virtual ULong count() const;
  virtual NamedValue_ptr add(Flags);
  virtual NamedValue_ptr add_item(const char*, Flags);
  virtual NamedValue_ptr add_value(const char*, const Any&, Flags);
  virtual NamedValue_ptr add_item_consume(char*,Flags);
  virtual NamedValue_ptr add_value_consume(char*, Any*, Flags);
  virtual NamedValue_ptr item(ULong index);
  virtual Status remove (ULong);

  static NVList_ptr _duplicate(NVList_ptr);
  static NVList_ptr _nil();
};
\end{cxxlisting}


\subsection{Context}

Represents a set of context strings.

\begin{cxxlisting}
class Context {
public:
  virtual const char* context_name() const;
  virtual CORBA::Context_ptr parent() const;
  virtual CORBA::Status create_child(const char*, Context_out);
  virtual CORBA::Status set_one_value(const char*, const CORBA::Any&);
  virtual CORBA::Status set_values(CORBA::NVList_ptr);
  virtual CORBA::Status delete_values(const char*);
  virtual CORBA::Status get_values(const char* start_scope,
                                   CORBA::Flags op_flags,
                                   const char* pattern,
                                   CORBA::NVList_out values);
  // Throws BAD_CONTEXT if <start_scope> is not found.
  // Returns a nil NVList in <values> if no matches are found.

  static Context_ptr _duplicate(Context_ptr);
  static Context_ptr _nil();
};
\end{cxxlisting}


\subsection{ContextList}

A \type{ContextList} is a list of strings, and is used to specify
which strings from the `context' should be sent with an operation.

\begin{cxxlisting}
class ContextList {
public:
  virtual ULong count() const;
  virtual void add(const char* ctxt);
  virtual void add_consume(char* ctxt);
  // consumes ctxt

  virtual const char* item(ULong index);
  // retains ownership of return value

  virtual Status remove(ULong index);

  static ContextList_ptr _duplicate(ContextList_ptr);
  static ContextList_ptr _nil();
};
\end{cxxlisting}



\subsection{ExceptionList}

\type{ExceptionList}s contain a list of TypeCodes---and are used to
specify which user-defined exceptions an operation may throw.

\begin{cxxlisting}
class ExceptionList {
public:
  virtual ULong count() const;
  virtual void add(TypeCode_ptr tc);
  virtual void add_consume(TypeCode_ptr tc);
  // Consumes <tc>.

  virtual TypeCode_ptr item(ULong index);
  // Retains ownership of return value.

  virtual Status remove(ULong index);

  static ExceptionList_ptr _duplicate(ExceptionList_ptr);
  static ExceptionList_ptr _nil();
};
\end{cxxlisting}



\subsection{UnknownUserException}

When a user-defined exception is thrown by an operation it is
unmarshalled into a value of type Any. This is encapsulated in an
\type{UnknownUserException}. This type follows all the usual rules for
user-defined exceptions---it is not a pseudo object, and its resources
may be released by using \code{delete}.

\begin{cxxlisting}
class UnknownUserException : public UserException {
public:
  UnknownUserException(Any* ex);
  // Consumes <ex> which MUST be a UserException.

  virtual ~UnknownUserException();

  Any& exception();

  virtual void _raise();
  static const UnknownUserException* _downcast(const Exception*);
  static UnknownUserException* _downcast(Exception*);
  static UnknownUserException* _narrow(Exception*); 
  // _narrow is a deprecated function from CORBA 2.2, 
  // use _downcast instead.
};
\end{cxxlisting}



\subsection{Environment}

An \type{Environment} is used to hold an instance of a system
exception or an \type{UnknownUserException}.

\begin{cxxlisting}
class Environment {
  virtual void exception(Exception*);
  virtual Exception* exception() const;
  virtual void clear();

  static Environment_ptr _duplicate(Environment_ptr);
  static Environment_ptr _nil();
};
\end{cxxlisting}



\section{Creating Requests}

\type{CORBA::Object} defines three methods which may be used to create
a \type{Request} object which may be used to perform a single
operation invocation on that object:

\begin{cxxlisting}
class Object {
  ...
  Status _create_request(Context_ptr ctx,
                         const char* operation,
                         NVList_ptr arg_list,
                         NamedValue_ptr result,
                         Request_out request,
                         Flags req_flags);

  Status _create_request(Context_ptr ctx,
                         const char* operation,
                         NVList_ptr arg_list,
                         NamedValue_ptr result,
                         ExceptionList_ptr exceptions,
                         ContextList_ptr ctxlist,
                         Request_out request,
                         Flags req_flags);

  Request_ptr _request(const char* operation);
  ...
};
\end{cxxlisting}


\code{operation} is the name of the operation---which is the same as
the name given in IDL. To access attributes the name should be
prefixed by \code{\_get\_} or \code{\_set\_}.

In the first two cases above the list of parameters may be supplied.
If the parameters are not supplied in these cases, or \op{\_request}
is used then the parameters (if any) may be specified using the
\op{add\_*\_arg} methods on the \type{Request}. You must use one
method or the other---not a mixture of the two. For
\emph{in}/\emph{inout} arguments the value must be initialised, for
\emph{out} arguments only the type need be given.  Similarly the type
of the result may be specified by passing a \type{NamedValue} which
contains an Any which has been initialised to contain a value of that
type, or it may be specified using the \op{set\_return\_type} method
of \type{Request}.

When using \op{\_create\_request}, the management of any pseudo-object
references passed in remains the responsibility of the
application. That is, the values are not consumed---and must be
released using \op{CORBA::release}. The CORBA specification is unclear
about when these values may be released, so to be sure of portability
do not release them until after the request has been released.  Values
which are not needed need not be supplied---so if no parameters are
specified then it defaults to an empty parameter list. If no result
type is specified then it defaults to void. A \type{Context} need only
be given if a non-empty \type{ContextList} is specified. The
\code{req\_flags} argument is not used in the C++ mapping.


\subsection{Examples}

An operation might be specified in IDL as:

\begin{idllisting}
short anOpn(in string a);
\end{idllisting}

\noindent An operation invocation may be created as follows:

\begin{cxxlisting}
CORBA::ORB_var orb = CORBA::ORB_init(argc, argv, "omniORB3");
...
CORBA::NVList_var args;
orb->create_list(1, args);
*(args->add(CORBA::ARG_IN)->value()) <<= (const char*) "Hello World!";

CORBA::NamedValue_var result;
orb->create_named_value(result);
result->value()->replace(CORBA::_tc_short, 0);

CORBA::Request_var req = obj->_create_request(CORBA::Context::_nil(),
                                        "anOpn", args, result, 0);
\end{cxxlisting}

\noindent or alternatively and much more concisely:

\begin{cxxlisting}
CORBA::Request_var req = obj->_request("anOpn");
req->add_in_arg() <<= (const char*) "Hello World!";
req->set_return_type(CORBA::_tc_short);
\end{cxxlisting}


\section{Invoking Operations}
\label{dii_invoke}

Once the \type{Request} object has been properly constructed, the
operation may be invoked by calling one of the following methods on
the request object:

\paragraph{\op{invoke}}

blocks until the request has completed. The application should then
test to see if an exception was raised. Since the CORBA spec is not
clear about whether or not system exceptions should be thrown from
this method, a runtime configuration variable is supplied so that you
can specify the behavior:

\begin{cxxlisting}
namespace omniORB {
  ...
  CORBA::Boolean diiThrowsSysExceptions;
  ...
};
\end{cxxlisting}

If this is FALSE, and the application should call the \op{env} method
of the request to retrieve an exception (it returns 0 (nil) if no
exception was generated). If it is TRUE then system exceptions will be
thrown out of \op{invoke}. User-defined exceptions are always passed
via \op{env}, which will return a pointer to a
\type{CORBA::UnknownUserException}.  The application can determine
which type of exception was returned by \op{env()} by calling the
\op{\_narrow} method defined for each exception type.

\begin{statement}
\centerline{\textbf{Warning}}

In pre-omniORB 2.8.0 releases, the default value of
\code{diiThrowsSysExceptions} is FALSE. From omniORB 2.8.0 onwards,
the default value is TRUE.

\end{statement}

After determining that no exception was thrown the application may
retrieve any returned values by calling \op{return\_value} and
\op{arguments}.

\paragraph{\op{send\_oneway}}

has the same semantics as a \emph{oneway} IDL operation. It is
important to note that oneway operations have at-most-once semantics,
and it is not guaranteed that they will not block. Any operation may
be invoked `oneway' using the DII, even if it was not declared as
`oneway' in IDL. A system exception may be generated, in which case it
will either be thrown or may be retrieved using \op{env} depending on
\code{diiThrowsSysExceptions} as above.

\paragraph{\op{send\_deferred}}

initiates the invocation, and then returns without waiting for the
result. At some point in the future the application must retrieve the
result of the operation---but other than testing for completion of the
operation the application must not call any of the request's methods
in the meantime.

\begin{itemize}
\item \op{get\_response} blocks until the reply is received.
\item \op{poll\_response} returns TRUE if the reply has been received,
      and FALSE if not. It does not block.
\end{itemize}

Once \op{poll\_response} has returned TRUE, or \op{get\_response} has
been called and returned, the application may test for an exception
and retrieve returned values as above. If
\code{diiThrowsSysExceptions} is true, then a system exception may be
thrown from \op{get\_response}.  From omniORB 2.8.0 onwards,
\op{poll\_response} will raise a system exception if one has occurred
during the invocation. Previously, \op{poll\_response} would not raise
an exception, so if polling, the application also had to call another
method to give the request an opportunity to raise the exception. This
could be one of the methods to retrieve values from the request, or
\op{get\_response}.


\section{Multiple Requests}

The following methods are provided by the ORB to enable multiple requests to
be invoked asynchronously.

\begin{cxxlisting}
namespace CORBA {
  ...
  class ORB {
  public:
    ...
    Status send_multiple_requests_oneway(const RequestSeq&);
    Status send_multiple_requests_deferred(const RequestSeq&);
    Boolean poll_next_response();
    Status get_next_response(Request_out);
    ...
  };
  ...
};
\end{cxxlisting}

\paragraph{\op{send\_multiple\_requests\_oneway}}

is used to invoke a number of oneway requests. An attempt will be made
to invoke each of the requests, even if one or more of the early
requests fails.  The application may check for failure of any of the
requests by testing the request's \op{env} method. System exceptions
are never raised by this method.

\paragraph{\op{send\_multiple\_requests\_deferred}}

will initiate an invocation of each of the given requests, and return
without waiting for the reply.  At some point in the future the
application must retrieve the reply by calling
\op{get\_next\_response}, which returns a completed request.  If no
requests have yet completed it will block.  This method never throws
exceptions---the request's \op{env} method must be used to determine
if an exception was generated. If not then any returned values may
then be queried.

\op{poll\_next\_response} returns TRUE if there are any completed
requests, and FALSE otherwise, without blocking. If this returns true
then the next call to \op{get\_next\_response} will not block.
However, if another thread may also be calling
\op{get\_next\_response} then it could retrieve the completed message
first---in which case this thread might block.

There are no guarantee as to the order in which replies will be
received.  If multiple threads are using this interface then it is not
even guaranteed that a thread will receive replies to the requests it
sent. Any thread may receive replies to requests sent by any other
thread. It is legal to call \op{get\_next\_response} even if no
requests have yet been invoked---in which case the calling thread
blocks until another thread invokes a request and the reply is
received.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{The Dynamic Skeleton Interface}
\label{chap:dsi}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The Dynamic Skeleton Interface (or DSI) allows applications to provide
implementations of the operations on CORBA objects without static
knowledge of the object's interface. It is the server-side equivalent
of the Dynamic Invocation Interface.

This chapter presents the Dynamic Skeleton Interface and explains how
to use it.  A toy example use of the DSI can be found in the omniORB
distribution in the \file{src/examples/dsi} directory.  For further
information refer to the Dynamic Skeleton Interface and C++ Mapping
sections of the CORBA 2.3 specification.

The DSI interface has changed in CORBA 2.3. omniORB 3 uses the new
mapping, but since the mapping depends on
\type{PortableServer::Current}, which is not yet implemented, not all
facilities are available. This chapter describes an approach to
building DSI servers which works with omniORB 3.

\section{Overview}

When an ORB receives an invocation request, the information includes
the object reference and the name of the operation. Typically this
information is used by the ORB to select a servant object and call
into the implementation of the operation (which knows how to unmarshal
the parameters etc.).  The Dynamic Skeleton Interface however makes
this information directly available to the application---so that it
can implement the operation (or pass it on to another server) without
static knowledge of the interface. In fact it is not even necessary
for the server to always implement the same interface on any
particular object!

To provide an implementation for one or more objects an application
must sub-class \type{PortableServer::DynamicImplementation} and
override the method \op{invoke}.  An instance of this class is
registered with a POA and is assigned an object reference (see below).
When the ORB receives a request for that object the \op{invoke} method
is called and will be passed a \type{CORBA::ServerRequest} object
which provides:

\begin{itemize}
\item the operation name
\item context strings
\item access to the parameters
\item a way to set the returned values
\item a way to throw user-defined exceptions.
\end{itemize}


\section{DSI Types}

\subsection{PortableServer::DynamicImplementation}

This class must be sub-classed by the application to provide an
implementation for DSI objects. The method \op{invoke} will be called
for each operation invocation.

\begin{cxxlisting}
namespace PortableServer {
  ...

  class DynamicImplementation : public virtual ServantBase {
  public:
    virtual ~DynamicImplementation();

    CORBA::Object_ptr _this();
    // Must only be called from within invoke(). Caller must release
    // the reference returned.

    virtual void invoke(CORBA::ServerRequest_ptr request) = 0;
    virtual char* _primary_interface(const ObjectId& oid, POA_ptr poa) = 0;

    virtual CORBA::Boolean _is_a(const char* logical_type_id);
    // The default implementation uses _primary_interface(),
    // but may be overridden by subclasses.
  };
  ...
};
\end{cxxlisting}


\subsection{ServerRequest}

A \type{ServerRequest} object provides the interface between a dynamic
implementation and the ORB.

\begin{cxxlisting}
namespace CORBA {
  ...

  class ServerRequest {
  public:
    virtual const char* operation() = 0;
    virtual void        arguments(NVList_ptr& parameters) = 0;
    virtual Context_ptr ctx() = 0;
    virtual void        set_result(const Any& value) = 0;
    virtual void        set_exception(const Any& value) = 0;

  protected:
    inline ServerRequest() {}
    virtual ~ServerRequest();
  };
  ...
};
\end{cxxlisting}


\section{Creating Dynamic Implementations}

The application must override the \op{invoke} method of
\type{DynamicImplementation} to provide an implementation for DSI
objects.  This method must behave as follows:

\begin{itemize}
\item It may be called concurrently by multiple threads of execution,
and so must be thread-safe.

\item It may not throw any exceptions. Both user-defined and system
exceptions are passed in a value of type Any via a call to
\op{ServerRequest::set\_\dsc{}exception}.

\item The operations on the \type{ServerRequest} object must be
carried out in the correct order, as described below.
\end{itemize}


\subsection{Operations on the ServerRequest}

\op{operation} will return the name of the operation, and may be
called at any time. For attribute access the operation name is the IDL
name of the attribute, prefixed by \texttt{\_get\_} or
\texttt{\_set\_}. If the operation name is not recognised a
\code{CORBA::\dsc{}BAD\_OPERATION} exception should be passed back
through \op{set\_exception}. This will allow the ORB to then see if it
is one of the standard object operations.

Firstly \op{arguments} must be called passing a
\type{CORBA::NVList}\footnote{obtained by calling
\op{CORBA::ORB::create\_list}} which must be initialised to contain
the type and mode of the parameters.  The ORB consumes this value and
will release it when the operation is complete. At this point any
\emph{in}/\emph{inout} arguments will be unmarshalled, and when this
operation returns, their values will be in the \type{NVList}. The
application may set the value of \emph{inout}/\emph{out} arguments by
modifying this parameter list.

If the operation has user-context information, then \op{ctx} must be
called after \op{arguments} to retrieve it.

\op{set\_result} must then be called exactly once if the operation has
a non-void return value (unless an exception is thrown). The value
passed should be an Any allocated with \code{new}, and will be freed
by the ORB.

At any point in the above sequence \op{set\_exception} may be called
to set a user-defined exception or a system exception. If this happens
then no further operations should be invoked on the
\type{ServerRequest} object, and the \op{invoke} method should return.

Within the \op{invoke} method \op{\_this} may be called to obtain the
object reference. This method may not be used at any other time.


\section{Registering Dynamic Objects}

To use a \type{DynamicImplementation} servant, a CORBA object must be
created and associated with it, just as for any other servant. Dynamic
servants can also be created on demand by Servant Managers, just like
static servants.


\section{Example}

This implementation of \op{DynamicImplementation::invoke} is taken
from an example which can be found in the omniORB distribution. The
\op{echoString} operation is declared in IDL as:

\begin{idllisting}
string echoString(in string mesg);
\end{idllisting}



\noindent Here is the Dynamic Implementation Routine:

\begin{cxxlisting}
void
MyDynImpl::invoke(CORBA::ServerRequest_ptr request)
{
  try {
    if( strcmp(request->operation(), "echoString") )
      throw CORBA::BAD_OPERATION(0, CORBA::COMPLETED_NO);

    CORBA::NVList_ptr args;
    orb->create_list(0, args);
    CORBA::Any a;
    a.replace(CORBA::_tc_string, 0);
    args->add_value("", a, CORBA::ARG_IN);

    request->arguments(args);

    const char* mesg;
    *(args->item(0)->value()) >>= mesg;

    CORBA::Any* result = new CORBA::Any();
    *result <<= CORBA::Any::from_string(mesg, 0);
    request->set_result(*result);
  }
  catch(CORBA::SystemException& ex){
    CORBA::Any a;
    a <<= ex;
    request->set_exception(a);
  }
  catch(...){
    cout << "echo_dsiimpl: MyDynImpl::invoke - caught an unknown exception."
	 << endl;
    CORBA::Any a;
    a <<= CORBA::UNKNOWN(0, CORBA::COMPLETED_NO);
    request->set_exception(a);
  }
}
\end{cxxlisting}





\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{hosts\_access(5)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{apx:hostsaccess}

\subsection*{DESCRIPTION}

This manual page describes a simple access control language that is
based on client (host name/address, user name), and server (process
name, host name/address) patterns.  Examples are given at the end. The
impatient reader is encouraged to skip to the EXAMPLES section for a
quick introduction.

An extended version of the access control language is described in the
hosts\_\dsc{}options(5) document. The extensions are turned on at
program build time by building with -DPROCESS\_OPTIONS.

In the following text, \term{daemon} is the process name of a network
daemon process, and \term{client} is the name and/or address of a host
requesting service. Network daemon process names are specified in the
inetd configuration file.

\subsection*{ACCESS CONTROL FILES}

The access control software consults two files. The search stops
at the first match:

\begin{itemize}
\item Access will be granted when a (daemon,client) pair matches an
entry in the \file{/etc/hosts.allow} file.

\item Otherwise, access will be denied when a (daemon,client) pair
matches an entry in the \file{/etc/hosts.deny} file.

\item Otherwise, access will be granted.

\end{itemize}

A non-existing access control file is treated as if it were an empty
file. Thus, access control can be turned off by providing no access
control files.

\subsection*{ACCESS CONTROL RULES}

Each access control file consists of zero or more lines of text.
These lines are processed in order of appearance. The search
terminates when a match is found.

\begin{itemize}

\item A newline character is ignored when it is preceded by a
backslash character. This permits you to break up long lines so that
they are easier to edit.

\item Blank lines or lines that begin with a \texttt{\#} character are
ignored.  This permits you to insert comments and whitespace so that
the tables are easier to read.

\item All other lines should satisfy the following format, things
between [] being optional: \texttt{daemon\_list : client\_list [ :
shell\_command ] }

\end{itemize}

\texttt{daemon\_list} is a list of one or more daemon process names
(argv[0] values) or wildcards (see below).  

\texttt{client\_list} is a list of one or more host names, host
addresses, patterns or wildcards (see below) that will be matched
against the client host name or address.

The more complex forms \texttt{daemon@host} and \texttt{user@host} are
explained in the sections on server endpoint patterns and on client
username lookups, respectively.

List elements should be separated by blanks and/or commas.  

With the exception of NIS (YP) netgroup lookups, all access control
checks are case insensitive.

\subsection*{PATTERNS}

The access control language implements the following patterns:

\begin{itemize}

\item A string that begins with a \texttt{.} character. A host name is
matched if the last components of its name match the specified
pattern.  For example, the pattern \texttt{.tue.nl} matches the host
name \texttt{wzv.win.tue.nl}.

\item A string that ends with a \texttt{.} character. A host address
is matched if its first numeric fields match the given string.  For
example, the pattern \texttt{131.155.} matches the address of (almost)
every host on the Eindhoven University network (\texttt{131.155.x.x}).

\item A string that begins with an \texttt{\@} character is treated as
an NIS (formerly YP) netgroup name. A host name is matched if it is a
host member of the specified netgroup. Netgroup matches are not
supported for daemon process names or for client user names.

\item An expression of the form \texttt{n.n.n.n/m.m.m.m} is
interpreted as a `net/mask' pair. A host address is matched if `net'
is equal to the bitwise AND of the address and the `mask'. For
example, the net/mask pattern
\texttt{131.155.72.0/\dsc{}255.255.254.0} matches every address in the
range \texttt{131.155.72.0} to \texttt{131.155.73.255}.

\end{itemize}

\subsection*{WILDCARDS}

The access control language supports explicit wildcards:

\begin{description}
\item[\tt ALL]\mbox{}\\
The universal wildcard, always matches.

\item[\tt LOCAL]\mbox{}\\
Matches any host whose name does not contain a dot
character.

\item[\tt UNKNOWN]\mbox{}\\
Matches any user whose name is unknown, and matches
any host whose name or address are unknown.  This pattern should be
used with care: host names may be unavailable due to temporary name
server problems. A network address will be unavailable when the
software cannot figure out what type of network it is talking to.

\item[\tt KNOWN]\mbox{}\\
Matches any user whose name is known, and matches any
host whose name and address are known. This pattern should be used
with care: host names may be unavailable due to temporary name server
problems.  A network address will be unavailable when the software
cannot figure out what type of network it is talking to.

\item[\tt PARANOID]\mbox{}\\
Matches any host whose name does not match its
address.  When tcpd is built with -DPARANOID (default mode), it drops
requests from such clients even before looking at the access control
tables.  Build without -DPARANOID when you want more control over such
requests.

\end{description}

\subsection*{OPERATORS}

\begin{description}

\item[\tt EXCEPT]\mbox{}\\
Intended use is of the form: \texttt{list\_1} \texttt{EXCEPT}
\texttt{list\_2}; this construct matches anything that matches
\texttt{list\_1} unless it matches \texttt{list\_2}.  The
\texttt{EXCEPT} operator can be used in \texttt{daemon\_lists} and in
\texttt{client\_lists}. The \texttt{EXCEPT} operator can be nested: if
the control language would permit the use of parentheses, \texttt{a
EXCEPT b EXCEPT c} would parse as \texttt{(a EXCEPT (b EXCEPT c))}.

\end{description}

\subsection*{SHELL COMMANDS}

If the first-matched access control rule contains a shell command,
that command is subjected to \texttt{\%<letter>} substitutions (see
next section).  The result is executed by a /bin/sh child process with
standard input, output and error connected to /dev/null.  Specify an
\texttt{\&} at the end of the command if you do not want to wait until
it has completed.

Shell commands should not rely on the PATH setting of the inetd.
Instead, they should use absolute path names, or they should begin
with an explicit \texttt{PATH=\dsc{}whatever} statement.

The hosts\_options(5) document describes an alternative language that
uses the shell command field in a different and incompatible way.

\subsection*{\% EXPANSIONS}

The following expansions are available within shell commands:

\begin{itemize}

\item[\tt \%a (\%A)] The client (server) host address.
\item[\tt \%c] Client information: user@host, user@address, a host
name, or just an address, depending on how much information is
available.
\item[\tt \%d] The daemon process name (argv[0] value).
\item[\tt \%h (\%H)]
The client (server) host name or address, if the host name is
unavailable.
\item[\tt \%n (\%N)] The client (server) host name (or "unknown" or
"paranoid").
\item[\tt \%p] The daemon process id.
\item[\tt \%s] Server information: daemon@host, daemon@address, or
just a daemon name, depending on how much information is available.
\item [\tt \%u] The client user name (or "unknown").
\item [\tt \%\%] Expands to a single \texttt{\%} character.

\end{itemize}

Characters in \% expansions that may confuse the shell are replaced by
underscores.

\subsection*{SERVER ENDPOINT PATTERNS}

In order to distinguish clients by the network address that they
connect to, use patterns of the form:

\texttt{process\_name@host\_pattern : client\_list ... }

Patterns like these can be used when the machine has different
internet addresses with different internet hostnames.  Service
providers can use this facility to offer FTP, GOPHER or WWW archives
with internet names that may even belong to different
organisations. See also the `twist' option in the hosts\_options(5)
document. Some systems (Solaris, FreeBSD) can have more than one
internet address on one physical interface; with other systems you may
have to resort to SLIP or PPP pseudo interfaces that live in a
dedicated network address space. The \texttt{host\_pattern} obeys
the same syntax rules as host names and addresses in
\texttt{client\_list} context. Usually, server endpoint information is
available only with connection-oriented services.


\subsection*{CLIENT USERNAME LOOKUP}

When the client host supports the RFC 931 protocol or one of its
descendants (TAP, IDENT, RFC 1413) the wrapper programs can retrieve
additional information about the owner of a connection. Client
username information, when available, is logged together with the
client host name, and can be used to match patterns like:

\texttt{daemon\_list : ... user\_pattern@host\_pattern ...}

The daemon wrappers can be configured at compile time to perform
rule-driven username lookups (default) or to always interrogate the
client host.  In the case of rule-driven username lookups, the above
rule would cause username lookup only when both the
\texttt{daemon\_list} and the \texttt{host\_pattern} match.

A user pattern has the same syntax as a daemon process pattern, so the
same wildcards apply (netgroup membership is not supported).  One
should not get carried away with username lookups, though.

\begin{itemize}

\item The client username information cannot be trusted when it is
needed most, i.e. when the client system has been compromised.  In
general, ALL and (UN)KNOWN are the only user name patterns that make
sense.

\item Username lookups are possible only with TCP-based services, and
only when the client host runs a suitable daemon; in all other cases
the result is `unknown'.

\item A well-known UNIX kernel bug may cause loss of service when
username lookups are blocked by a firewall. The wrapper README
document describes a procedure to find out if your kernel has this
bug.

\item Username lookups may cause noticeable delays for non-UNIX users.
The default timeout for username lookups is 10 seconds: too short to
cope with slow networks, but long enough to irritate PC users.

\end{itemize}

Selective username lookups can alleviate the last problem. For
example, a rule like:

\texttt{daemon\_list : @pcnetgroup ALL@ALL }

would match members of the pc netgroup without doing username lookups,
but would perform username lookups with all other systems.

\subsection*{DETECTING ADDRESS SPOOFING ATTACKS}

A flaw in the sequence number generator of many TCP/IP implementations
allows intruders to easily impersonate trusted hosts and to break in
via, for example, the remote shell service.  The IDENT (RFC931 etc.)
service can be used to detect such and other host address spoofing
attacks.

Before accepting a client request, the wrappers can use the IDENT
service to find out that the client did not send the request at all.
When the client host provides IDENT service, a negative IDENT lookup
result (the client matches \texttt{UNKNOWN@host}) is strong evidence
of a host spoofing attack.

A positive IDENT lookup result (the client matches
\texttt{KNOWN@host}) is less trustworthy. It is possible for an
intruder to spoof both the client connection and the IDENT lookup,
although doing so is much harder than spoofing just a client
connection. It may also be that the client's IDENT server is lying.

Note: IDENT lookups don't work with UDP services. 

\subsection*{EXAMPLES}

The language is flexible enough that different types of access control
policy can be expressed with a minimum of fuss. Although the language
uses two access control tables, the most common policies can be
implemented with one of the tables being trivial or even empty.

When reading the examples below it is important to realise that the
allow table is scanned before the deny table, that the search
terminates when a match is found, and that access is granted when no
match is found at all.

The examples use host and domain names. They can be improved by
including address and/or network/netmask information, to reduce the
impact of temporary name server lookup failures.

\subsection*{MOSTLY CLOSED}

In this case, access is denied by default. Only explicitly authorised
hosts are permitted access.

The default policy (no access) is implemented with a trivial deny
file:

{\small
\begin{verbatim}
/etc/hosts.deny:
    ALL: ALL
\end{verbatim}
}

This denies all service to all hosts, unless they are permitted access
by entries in the allow file.

The explicitly authorised hosts are listed in the allow file.  For
example:

{\small
\begin{verbatim}
/etc/hosts.allow:
   ALL: LOCAL @some_netgroup
   ALL: .foobar.edu EXCEPT terminalserver.foobar.edu
\end{verbatim}
}

The first rule permits access from hosts in the local domain (no .  in
the host name) and from members of the \texttt{some\_netgroup}
netgroup.  The second rule permits access from all hosts in the
\texttt{foobar.edu} domain (notice the leading dot), with the
exception of \texttt{terminalserver.foobar.edu}.

\subsection*{MOSTLY OPEN}

Here, access is granted by default; only explicitly specified hosts
are refused service.

The default policy (access granted) makes the allow file redundant so
that it can be omitted.  The explicitly non-authorised hosts are
listed in the deny file. For example:

{\small
\begin{verbatim}
/etc/hosts.deny:
   ALL: some.host.name, .some.domain
   ALL EXCEPT in.fingerd: other.host.name, .other.domain
\end{verbatim}
}

The first rule denies some hosts and domains all services; the second
rule still permits finger requests from other hosts and domains.


\subsection*{BOOBY TRAPS}

The next example permits tftp requests from hosts in the local domain
(notice the leading dot).  Requests from any other hosts are denied.
Instead of the requested file, a finger probe is sent to the offending
host. The result is mailed to the superuser.

{\small
\begin{verbatim}
/etc/hosts.allow:
   in.tftpd: LOCAL, .my.domain

/etc/hosts.deny:
   in.tftpd: ALL: (/some/where/safe\_finger -l @%h | \
       /usr/ucb/mail -s %d-%h root) &
\end{verbatim}
}

The \texttt{safe\_finger} command comes with the tcpd wrapper and
should be installed in a suitable place. It limits possible damage
from data sent by the remote finger server.  It gives better
protection than the standard finger command.

The expansion of the \%h (client host) and \%d (service name)
sequences is described in the section on shell commands.

Warning: do not booby-trap your finger daemon, unless you are prepared
for infinite finger loops.

On network firewall systems this trick can be carried even further.
The typical network firewall only provides a limited set of services
to the outer world. All other services can be "bugged" just like the
above tftp example. The result is an excellent early-warning system.

\subsection*{DIAGNOSTICS}

An error is reported when a syntax error is found in a host access
control rule; when the length of an access control rule exceeds the
capacity of an internal buffer; when an access control rule is not
terminated by a newline character; when the result of %<letter>
expansion would overflow an internal buffer; when a system call fails
that shouldn\'t.  All problems are reported via the syslog daemon.


\subsection*{FILES}

\noindent \file{/etc/hosts.allow}, (daemon,client) pairs that are granted access.

\noindent \file{/etc/hosts.deny}, (daemon,client) pairs that are denied access.

\subsection*{SEE ALSO}

\noindent tcpd(8) tcp/ip daemon wrapper program.

\noindent tcpdchk(8), tcpdmatch(8), test programs.

\subsection*{BUGS}

If a name server lookup times out, the host name will not be available
to the access control software, even though the host is registered.

Domain name server lookups are case insensitive; NIS (formerly YP)
netgroup lookups are case sensitive.

\subsection*{AUTHOR}

Wietse Venema (wietse@wzv.win.tue.nl)\\
Department of Mathematics and Computing Science\\
Eindhoven University of Technology\\
Den Dolech 2, P.O. Box 513,\\
5600 MB Eindhoven, The Netherlands\\
