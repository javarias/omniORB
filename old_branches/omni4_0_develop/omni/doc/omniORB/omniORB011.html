<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.06">
<TITLE>
 Interceptors
</TITLE>
</HEAD>
<BODY >
<A HREF="omniORB010.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="omniORB012.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1><A NAME="htoc110">Chapter&nbsp;10</A>&nbsp;&nbsp;Interceptors</H1>
<A NAME="chap:interceptors"></A>
omniORB 4.0 supports interceptors that allow the application to insert
processing in various points along the call chain, and in various
other locations. It does not support the standard Portable
Interceptors API.<BR>
<BR>
The interceptor interfaces are defined in a single header,
<TT>include/omniORB4/omniInterceptors.h</TT>. Each interception point
consists of a singleton object with <TT>add()</TT> and <TT>remove()</TT> methods,
and the definition of an `interceptor info' class. For example:
<PRE>
class omniInterceptors {
  ...
  class clientSendRequest_T {
  public:

    class info_T {
    public:
      giopStream&amp;              giopstream;
      const omniIOR&amp;           ior;
      const char*              opname;
      CORBA::Boolean           oneway;
      CORBA::Boolean           response_expected;
      IOP::ServiceContextList  service_contexts;

      info_T(giopStream&amp; s, const omniIOR&amp; i, const char* op,
      CORBA::Boolean ow, CORBA::Boolean re) :
 giopstream(s),ior(i),opname(op),oneway(ow),response_expected(re),
 service_contexts(5) {}

    private:
      info_T();
      info_T(const info_T&amp;);
      info_T&amp; operator=(const info_T&amp;);
    };

    typedef CORBA::Boolean (*interceptFunc)(info_T&amp; info);

    void add(interceptFunc);
    void remove(interceptFunc);
  };
  ...
};
</PRE>
You can see that the interceptors themselves are functions
which take the <TT>info_T</TT> object as their argument and return
boolean. Interceptors are called in the order they are registered;
normally, all interceptor functions return true, meaning that
processing should continue with subsequent interceptors. If an
interceptor returns false, later interceptors are not called. You
should only do that if you really know what you are doing.<BR>
<BR>
Notice that the <TT>info_T</TT> contains references to several omniORB
internal data types. The definitions of these can be found in other
header files within <TT>include/omniORB4</TT> and
<TT>include/omniORB4/internal</TT>.<BR>
<BR>
<A NAME="toc48"></A>
<H2><A NAME="htoc111">10.1</A>&nbsp;&nbsp;Interceptor registration</H2>
All the interceptor singletons are registered within another singleton
object of class <TT>omniInterceptors</TT>. You retrieve a pointer to
that singleton with the <TT>omniORB::getInterceptors()</TT> function.
The code to register an interceptor looks, for example, like:
<PRE>
omniInterceptors* interceptors = omniORB::getInterceptors();
interceptors-&gt;clientSendRequest.add(myInterceptorFunc);
</PRE>
<A NAME="toc49"></A>
<H2><A NAME="htoc112">10.2</A>&nbsp;&nbsp;Available interceptors</H2>
The following interceptors are available:
<DL COMPACT=compact><DT><B>encodeIOR</B><DD><BR>
Called when encoding an IOR to represent an object reference. This
interception point allows the application to insert extra profile
components into IORs. Note that you must understand and adhere to the
rules about data stored in IORs, otherwise the IORs created may be
invalid. omniORB itself uses this interceptor to insert various items,
so you can see an example of its use in the
<TT>insertSupportedComponents()</TT> function defined in
<TT>src/lib/omniORB/orbcore/ior.cc</TT>.<BR>
<BR>
<DT><B>decodeIOR</B><DD><BR>
Called when decoding an IOR. The application can use this to get out
whatever information they put into IORs with encodeIOR. Again, see
<TT>extractSupportedComponents()</TT> in
<TT>src/lib/omniORB/orbcore/ior.cc</TT> for an example.<BR>
<BR>
<DT><B>clientSendRequest</B><DD><BR>
Called just before a request header is sent over the network. The
application can use it to insert service contexts in the header. See
<TT>setCodeSetServiceContext()</TT> in
<TT>src/lib/omniORB/orbcore/cdrStream.cc</TT> for an example of its use.<BR>
<BR>
<DT><B>clientReceiveReply</B><DD><BR>
Called as the client receives a reply, just after unmarshalling the
reply header. *** NOT IMPLEMENTED YET!<BR>
<BR>
<DT><B>clientReceiveException</B><DD><BR>
Called as the client receives an exception, just after unmarshalling
the exception reply header. *** NOT IMPLEMENTED YET!<BR>
<BR>
<DT><B>serverReceiveRequest</B><DD><BR>
Called when the server receives a request, just after unmarshalling
the request header. See the <TT>getCodeSetServiceContext()</TT> function in
<TT>src/lib/omniORB/orbcore/cdrStream.cc</TT> for an example.<BR>
<BR>
<DT><B>serverSendReply</B><DD><BR>
Called just before the server marshals a reply header. *** NOT
IMPLEMENTED YET!<BR>
<BR>
<DT><B>serverSendException</B><DD><BR>
Called just before the server marshals an exception reply header. ***
NOT IMPLEMENTED YET!<BR>
<BR>
<DT><B>createIdentity</B><DD><BR>
Called when the ORB is about to create an `identity' object to
represent a CORBA object. It allows application code to provide its
own identity implementations. It is very unlikely that an application
will need to do this.<BR>
<BR>
<DT><B>createORBServer</B><DD><BR>
Used internally by the ORB to register different kinds of server. At
present, only a GIOP server is registered. It is very unlikely that
application code will need to do this.</DL>
<HR>
<A HREF="omniORB010.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="omniORB012.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
