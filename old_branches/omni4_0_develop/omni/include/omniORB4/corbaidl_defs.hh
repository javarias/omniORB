// This file is generated by omniidl (C++ backend)- omniORB_3_0. Do not edit.
#ifndef __corbaidl_defs_hh__
#define __corbaidl_defs_hh__

#ifndef __CORBA_mIDLType__
#define __CORBA_mIDLType__

class IDLType;
class _objref_IDLType;
class _impl_IDLType;
typedef _objref_IDLType* IDLType_ptr;
typedef IDLType_ptr IDLTypeRef;

class IDLType_Helper {
public:
  typedef IDLType_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_IDLType, IDLType_Helper> IDLType_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_IDLType,IDLType_Helper > IDLType_out;

#endif

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_Identifier;

typedef char* Identifier;
typedef CORBA::String_var Identifier_var;

struct StructMember {
  typedef _CORBA_ConstrType_Variable_Var<StructMember> _var_type;

  CORBA::String_member name;

  CORBA::TypeCode_member type;

  _CORBA_ObjRef_Member< _objref_IDLType, IDLType_Helper>  type_def;

  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef StructMember::_var_type StructMember_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< StructMember,StructMember_var > StructMember_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_StructMember;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_StructMemberSeq;

class StructMemberSeq_var;

class StructMemberSeq : public _CORBA_Unbounded_Sequence< StructMember>  {
public:
  typedef StructMemberSeq_var _var_type;
  inline StructMemberSeq() {}
  inline StructMemberSeq(const StructMemberSeq& s)
    : _CORBA_Unbounded_Sequence< StructMember> (s) {}

  inline StructMemberSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< StructMember> (_max) {}
  inline StructMemberSeq(_CORBA_ULong _max, _CORBA_ULong _len, StructMember* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< StructMember> (_max, _len, _val, _rel) {}

  inline StructMemberSeq& operator = (const StructMemberSeq& s) {
    _CORBA_Unbounded_Sequence< StructMember> ::operator=(s);
    return *this;
  }
};

class StructMemberSeq_out;

class StructMemberSeq_var {
public:
  typedef StructMemberSeq T;
  typedef StructMemberSeq_var T_var;

  inline StructMemberSeq_var() : _pd_seq(0) {}
  inline StructMemberSeq_var(T* s) : _pd_seq(s) {}
  inline StructMemberSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~StructMemberSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline StructMember& operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class StructMemberSeq_out;

private:
  T* _pd_seq;
};

class StructMemberSeq_out {
public:
  typedef StructMemberSeq T;
  typedef StructMemberSeq_var T_var;

  inline StructMemberSeq_out(T*& s) : _data(s) { _data = 0; }
  inline StructMemberSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline StructMemberSeq_out(const StructMemberSeq_out& s) : _data(s._data) {}
  inline StructMemberSeq_out& operator = (const StructMemberSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline StructMemberSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline StructMember& operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  StructMemberSeq_out();
  StructMemberSeq_out& operator=(const T_var&);
};

struct UnionMember {
  typedef _CORBA_ConstrType_Variable_Var<UnionMember> _var_type;

  CORBA::String_member name;

  CORBA::Any label;

  CORBA::TypeCode_member type;

  _CORBA_ObjRef_Member< _objref_IDLType, IDLType_Helper>  type_def;

  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef UnionMember::_var_type UnionMember_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< UnionMember,UnionMember_var > UnionMember_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_UnionMember;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_UnionMemberSeq;

class UnionMemberSeq_var;

class UnionMemberSeq : public _CORBA_Unbounded_Sequence< UnionMember>  {
public:
  typedef UnionMemberSeq_var _var_type;
  inline UnionMemberSeq() {}
  inline UnionMemberSeq(const UnionMemberSeq& s)
    : _CORBA_Unbounded_Sequence< UnionMember> (s) {}

  inline UnionMemberSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< UnionMember> (_max) {}
  inline UnionMemberSeq(_CORBA_ULong _max, _CORBA_ULong _len, UnionMember* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< UnionMember> (_max, _len, _val, _rel) {}

  inline UnionMemberSeq& operator = (const UnionMemberSeq& s) {
    _CORBA_Unbounded_Sequence< UnionMember> ::operator=(s);
    return *this;
  }
};

class UnionMemberSeq_out;

class UnionMemberSeq_var {
public:
  typedef UnionMemberSeq T;
  typedef UnionMemberSeq_var T_var;

  inline UnionMemberSeq_var() : _pd_seq(0) {}
  inline UnionMemberSeq_var(T* s) : _pd_seq(s) {}
  inline UnionMemberSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~UnionMemberSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline UnionMember& operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class UnionMemberSeq_out;

private:
  T* _pd_seq;
};

class UnionMemberSeq_out {
public:
  typedef UnionMemberSeq T;
  typedef UnionMemberSeq_var T_var;

  inline UnionMemberSeq_out(T*& s) : _data(s) { _data = 0; }
  inline UnionMemberSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline UnionMemberSeq_out(const UnionMemberSeq_out& s) : _data(s._data) {}
  inline UnionMemberSeq_out& operator = (const UnionMemberSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline UnionMemberSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline UnionMember& operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  UnionMemberSeq_out();
  UnionMemberSeq_out& operator=(const T_var&);
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_EnumMemberSeq;

class EnumMemberSeq_var;

class EnumMemberSeq : public _CORBA_Unbounded_Sequence__String {
public:
  typedef EnumMemberSeq_var _var_type;
  inline EnumMemberSeq() {}
  inline EnumMemberSeq(const EnumMemberSeq& s)
    : _CORBA_Unbounded_Sequence__String(s) {}

  inline EnumMemberSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence__String(_max) {}
  inline EnumMemberSeq(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence__String(_max, _len, _val, _rel) {}

  inline EnumMemberSeq& operator = (const EnumMemberSeq& s) {
    _CORBA_Unbounded_Sequence__String::operator=(s);
    return *this;
  }
};

class EnumMemberSeq_out;

class EnumMemberSeq_var {
public:
  typedef EnumMemberSeq T;
  typedef EnumMemberSeq_var T_var;

  inline EnumMemberSeq_var() : _pd_seq(0) {}
  inline EnumMemberSeq_var(T* s) : _pd_seq(s) {}
  inline EnumMemberSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~EnumMemberSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline _CORBA_String_element operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class EnumMemberSeq_out;

private:
  T* _pd_seq;
};

class EnumMemberSeq_out {
public:
  typedef EnumMemberSeq T;
  typedef EnumMemberSeq_var T_var;

  inline EnumMemberSeq_out(T*& s) : _data(s) { _data = 0; }
  inline EnumMemberSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline EnumMemberSeq_out(const EnumMemberSeq_out& s) : _data(s._data) {}
  inline EnumMemberSeq_out& operator = (const EnumMemberSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline EnumMemberSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline _CORBA_String_element operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  EnumMemberSeq_out();
  EnumMemberSeq_out& operator=(const T_var&);
};

#endif

