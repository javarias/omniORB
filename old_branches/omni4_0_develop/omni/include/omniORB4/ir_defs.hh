// This file is generated by omniidl (C++ backend)- omniORB_3_0. Do not edit.
#ifndef __ir_defs_hh__
#define __ir_defs_hh__

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ScopedName;

typedef char* ScopedName;
typedef CORBA::String_var ScopedName_var;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_RepositoryId;

typedef char* RepositoryId;
typedef CORBA::String_var RepositoryId_var;

enum DefinitionKind { dk_none, dk_all, dk_Attribute, dk_Constant, dk_Exception, dk_Interface, dk_Module, dk_Operation, dk_Typedef, dk_Alias, dk_Struct, dk_Union, dk_Enum, dk_Primitive, dk_String, dk_Sequence, dk_Array, dk_Repository, dk_Wstring, dk_Fixed, dk_Value, dk_ValueBox, dk_Member, dk_Native, dk_AbstractInterface };
typedef DefinitionKind& DefinitionKind_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_DefinitionKind;

#ifndef __CORBA_mIRObject__
#define __CORBA_mIRObject__

class IRObject;
class _objref_IRObject;
class _impl_IRObject;
typedef _objref_IRObject* IRObject_ptr;
typedef IRObject_ptr IRObjectRef;

class IRObject_Helper {
public:
  typedef IRObject_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_IRObject, IRObject_Helper> IRObject_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_IRObject,IRObject_Helper > IRObject_out;

#endif

class IRObject {
public:
  // Declarations for this interface type.
  typedef IRObject_ptr _ptr_type;
  typedef IRObject_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
	return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
	return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_IRObject :
  public virtual CORBA::Object, public virtual omniObjRef
{
public:
  void destroy();
  
  DefinitionKind def_kind();
  
  inline _objref_IRObject() { _PR_setobj(0); }  // nil
  _objref_IRObject(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_IRObject();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_IRObject(const _objref_IRObject&);
  _objref_IRObject& operator = (const _objref_IRObject&);
  // not implemented
};

class _pof_IRObject : public proxyObjectFactory {
public:
  inline _pof_IRObject() : proxyObjectFactory(IRObject::_PD_repoId) {}
  virtual ~_pof_IRObject();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_IRObject :
  public virtual omniServant
{
public:
  virtual ~_impl_IRObject();

  virtual void destroy() = 0;
  
  virtual DefinitionKind def_kind() = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_IRObject;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_VersionSpec;

typedef char* VersionSpec;
typedef CORBA::String_var VersionSpec_var;

#ifndef __CORBA_mContained__
#define __CORBA_mContained__

class Contained;
class _objref_Contained;
class _impl_Contained;
typedef _objref_Contained* Contained_ptr;
typedef Contained_ptr ContainedRef;

class Contained_Helper {
public:
  typedef Contained_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_Contained, Contained_Helper> Contained_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_Contained,Contained_Helper > Contained_out;

#endif

#ifndef __CORBA_mRepository__
#define __CORBA_mRepository__

class Repository;
class _objref_Repository;
class _impl_Repository;
typedef _objref_Repository* Repository_ptr;
typedef Repository_ptr RepositoryRef;

class Repository_Helper {
public:
  typedef Repository_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_Repository, Repository_Helper> Repository_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_Repository,Repository_Helper > Repository_out;

#endif

#ifndef __CORBA_mContainer__
#define __CORBA_mContainer__

class Container;
class _objref_Container;
class _impl_Container;
typedef _objref_Container* Container_ptr;
typedef Container_ptr ContainerRef;

class Container_Helper {
public:
  typedef Container_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_Container, Container_Helper> Container_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_Container,Container_Helper > Container_out;

#endif

#ifndef __CORBA_mContained__
#define __CORBA_mContained__

class Contained;
class _objref_Contained;
class _impl_Contained;
typedef _objref_Contained* Contained_ptr;
typedef Contained_ptr ContainedRef;

class Contained_Helper {
public:
  typedef Contained_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_Contained, Contained_Helper> Contained_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_Contained,Contained_Helper > Contained_out;

#endif

class Contained {
public:
  // Declarations for this interface type.
  typedef Contained_ptr _ptr_type;
  typedef Contained_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  struct Description {
    typedef _CORBA_ConstrType_Variable_Var<Description> _var_type;

    DefinitionKind kind;

    CORBA::Any value;

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Description::_var_type Description_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Description,Description_var > Description_out;

  static _dyn_attr const CORBA::TypeCode_ptr _tc_Description;

};

class _objref_Contained :
  public virtual _objref_IRObject
{
public:
  Contained::Description* describe();
  void move(Container_ptr new_container, const char* new_name, const char* new_version);
  
  char* id();
  void id(const char*);
  char* name();
  void name(const char*);
  char* version();
  void version(const char*);
  Container_ptr defined_in();
  char* absolute_name();
  Repository_ptr containing_repository();
  
  inline _objref_Contained() { _PR_setobj(0); }  // nil
  _objref_Contained(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_Contained();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_Contained(const _objref_Contained&);
  _objref_Contained& operator = (const _objref_Contained&);
  // not implemented
};

class _pof_Contained : public proxyObjectFactory {
public:
  inline _pof_Contained() : proxyObjectFactory(Contained::_PD_repoId) {}
  virtual ~_pof_Contained();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_Contained :
  public virtual _impl_IRObject
{
public:
  virtual ~_impl_Contained();

  virtual Contained::Description* describe() = 0;
  virtual void move(Container_ptr new_container, const char* new_name, const char* new_version) = 0;
  
  virtual char* id() = 0;
  virtual void id(const char*) = 0;
  virtual char* name() = 0;
  virtual void name(const char*) = 0;
  virtual char* version() = 0;
  virtual void version(const char*) = 0;
  virtual Container_ptr defined_in() = 0;
  virtual char* absolute_name() = 0;
  virtual Repository_ptr containing_repository() = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_Contained;

#ifndef __CORBA_mModuleDef__
#define __CORBA_mModuleDef__

class ModuleDef;
class _objref_ModuleDef;
class _impl_ModuleDef;
typedef _objref_ModuleDef* ModuleDef_ptr;
typedef ModuleDef_ptr ModuleDefRef;

class ModuleDef_Helper {
public:
  typedef ModuleDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ModuleDef, ModuleDef_Helper> ModuleDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ModuleDef,ModuleDef_Helper > ModuleDef_out;

#endif

#ifndef __CORBA_mConstantDef__
#define __CORBA_mConstantDef__

class ConstantDef;
class _objref_ConstantDef;
class _impl_ConstantDef;
typedef _objref_ConstantDef* ConstantDef_ptr;
typedef ConstantDef_ptr ConstantDefRef;

class ConstantDef_Helper {
public:
  typedef ConstantDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ConstantDef, ConstantDef_Helper> ConstantDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ConstantDef,ConstantDef_Helper > ConstantDef_out;

#endif

#ifndef __CORBA_mIDLType__
#define __CORBA_mIDLType__

class IDLType;
class _objref_IDLType;
class _impl_IDLType;
typedef _objref_IDLType* IDLType_ptr;
typedef IDLType_ptr IDLTypeRef;

class IDLType_Helper {
public:
  typedef IDLType_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_IDLType, IDLType_Helper> IDLType_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_IDLType,IDLType_Helper > IDLType_out;

#endif

#ifndef __CORBA_mStructDef__
#define __CORBA_mStructDef__

class StructDef;
class _objref_StructDef;
class _impl_StructDef;
typedef _objref_StructDef* StructDef_ptr;
typedef StructDef_ptr StructDefRef;

class StructDef_Helper {
public:
  typedef StructDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_StructDef, StructDef_Helper> StructDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_StructDef,StructDef_Helper > StructDef_out;

#endif

#ifndef __CORBA_mUnionDef__
#define __CORBA_mUnionDef__

class UnionDef;
class _objref_UnionDef;
class _impl_UnionDef;
typedef _objref_UnionDef* UnionDef_ptr;
typedef UnionDef_ptr UnionDefRef;

class UnionDef_Helper {
public:
  typedef UnionDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_UnionDef, UnionDef_Helper> UnionDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_UnionDef,UnionDef_Helper > UnionDef_out;

#endif

#ifndef __CORBA_mEnumDef__
#define __CORBA_mEnumDef__

class EnumDef;
class _objref_EnumDef;
class _impl_EnumDef;
typedef _objref_EnumDef* EnumDef_ptr;
typedef EnumDef_ptr EnumDefRef;

class EnumDef_Helper {
public:
  typedef EnumDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_EnumDef, EnumDef_Helper> EnumDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_EnumDef,EnumDef_Helper > EnumDef_out;

#endif

#ifndef __CORBA_mAliasDef__
#define __CORBA_mAliasDef__

class AliasDef;
class _objref_AliasDef;
class _impl_AliasDef;
typedef _objref_AliasDef* AliasDef_ptr;
typedef AliasDef_ptr AliasDefRef;

class AliasDef_Helper {
public:
  typedef AliasDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_AliasDef, AliasDef_Helper> AliasDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_AliasDef,AliasDef_Helper > AliasDef_out;

#endif

#ifndef __CORBA_mInterfaceDef__
#define __CORBA_mInterfaceDef__

class InterfaceDef;
class _objref_InterfaceDef;
class _impl_InterfaceDef;
typedef _objref_InterfaceDef* InterfaceDef_ptr;
typedef InterfaceDef_ptr InterfaceDefRef;

class InterfaceDef_Helper {
public:
  typedef InterfaceDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_InterfaceDef, InterfaceDef_Helper> InterfaceDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_InterfaceDef,InterfaceDef_Helper > InterfaceDef_out;

#endif

#ifndef __CORBA_mValueDef__
#define __CORBA_mValueDef__

class ValueDef;
class _objref_ValueDef;
class _impl_ValueDef;
typedef _objref_ValueDef* ValueDef_ptr;
typedef ValueDef_ptr ValueDefRef;

class ValueDef_Helper {
public:
  typedef ValueDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ValueDef, ValueDef_Helper> ValueDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ValueDef,ValueDef_Helper > ValueDef_out;

#endif

#ifndef __CORBA_mValueBoxDef__
#define __CORBA_mValueBoxDef__

class ValueBoxDef;
class _objref_ValueBoxDef;
class _impl_ValueBoxDef;
typedef _objref_ValueBoxDef* ValueBoxDef_ptr;
typedef ValueBoxDef_ptr ValueBoxDefRef;

class ValueBoxDef_Helper {
public:
  typedef ValueBoxDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ValueBoxDef, ValueBoxDef_Helper> ValueBoxDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ValueBoxDef,ValueBoxDef_Helper > ValueBoxDef_out;

#endif

#ifndef __CORBA_mExceptionDef__
#define __CORBA_mExceptionDef__

class ExceptionDef;
class _objref_ExceptionDef;
class _impl_ExceptionDef;
typedef _objref_ExceptionDef* ExceptionDef_ptr;
typedef ExceptionDef_ptr ExceptionDefRef;

class ExceptionDef_Helper {
public:
  typedef ExceptionDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ExceptionDef, ExceptionDef_Helper> ExceptionDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ExceptionDef,ExceptionDef_Helper > ExceptionDef_out;

#endif

#ifndef __CORBA_mNativeDef__
#define __CORBA_mNativeDef__

class NativeDef;
class _objref_NativeDef;
class _impl_NativeDef;
typedef _objref_NativeDef* NativeDef_ptr;
typedef NativeDef_ptr NativeDefRef;

class NativeDef_Helper {
public:
  typedef NativeDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_NativeDef, NativeDef_Helper> NativeDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_NativeDef,NativeDef_Helper > NativeDef_out;

#endif

#ifndef __CORBA_mAbstractInterfaceDef__
#define __CORBA_mAbstractInterfaceDef__

class AbstractInterfaceDef;
class _objref_AbstractInterfaceDef;
class _impl_AbstractInterfaceDef;
typedef _objref_AbstractInterfaceDef* AbstractInterfaceDef_ptr;
typedef AbstractInterfaceDef_ptr AbstractInterfaceDefRef;

class AbstractInterfaceDef_Helper {
public:
  typedef AbstractInterfaceDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper> AbstractInterfaceDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_AbstractInterfaceDef,AbstractInterfaceDef_Helper > AbstractInterfaceDef_out;

#endif

#ifndef __CORBA_mWstringDef__
#define __CORBA_mWstringDef__

class WstringDef;
class _objref_WstringDef;
class _impl_WstringDef;
typedef _objref_WstringDef* WstringDef_ptr;
typedef WstringDef_ptr WstringDefRef;

class WstringDef_Helper {
public:
  typedef WstringDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_WstringDef, WstringDef_Helper> WstringDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_WstringDef,WstringDef_Helper > WstringDef_out;

#endif

#ifndef __CORBA_mFixedDef__
#define __CORBA_mFixedDef__

class FixedDef;
class _objref_FixedDef;
class _impl_FixedDef;
typedef _objref_FixedDef* FixedDef_ptr;
typedef FixedDef_ptr FixedDefRef;

class FixedDef_Helper {
public:
  typedef FixedDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_FixedDef, FixedDef_Helper> FixedDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_FixedDef,FixedDef_Helper > FixedDef_out;

#endif

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_InterfaceDefSeq;

class InterfaceDefSeq_var;

class InterfaceDefSeq : public _CORBA_Unbounded_Sequence_ObjRef< _objref_InterfaceDef, _CORBA_ObjRef_Element< _objref_InterfaceDef, InterfaceDef_Helper> , InterfaceDef_Helper>  {
public:
  typedef InterfaceDefSeq_var _var_type;
  inline InterfaceDefSeq() {}
  inline InterfaceDefSeq(const InterfaceDefSeq& s)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_InterfaceDef, _CORBA_ObjRef_Element< _objref_InterfaceDef, InterfaceDef_Helper> , InterfaceDef_Helper> (s) {}

  inline InterfaceDefSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_InterfaceDef, _CORBA_ObjRef_Element< _objref_InterfaceDef, InterfaceDef_Helper> , InterfaceDef_Helper> (_max) {}
  inline InterfaceDefSeq(_CORBA_ULong _max, _CORBA_ULong _len, InterfaceDef_ptr* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_InterfaceDef, _CORBA_ObjRef_Element< _objref_InterfaceDef, InterfaceDef_Helper> , InterfaceDef_Helper> (_max, _len, _val, _rel) {}

  inline InterfaceDefSeq& operator = (const InterfaceDefSeq& s) {
    _CORBA_Unbounded_Sequence_ObjRef< _objref_InterfaceDef, _CORBA_ObjRef_Element< _objref_InterfaceDef, InterfaceDef_Helper> , InterfaceDef_Helper> ::operator=(s);
    return *this;
  }
};

class InterfaceDefSeq_out;

class InterfaceDefSeq_var {
public:
  typedef InterfaceDefSeq T;
  typedef InterfaceDefSeq_var T_var;

  inline InterfaceDefSeq_var() : _pd_seq(0) {}
  inline InterfaceDefSeq_var(T* s) : _pd_seq(s) {}
  inline InterfaceDefSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~InterfaceDefSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline _CORBA_ObjRef_Element< _objref_InterfaceDef, InterfaceDef_Helper>  operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class InterfaceDefSeq_out;

private:
  T* _pd_seq;
};

class InterfaceDefSeq_out {
public:
  typedef InterfaceDefSeq T;
  typedef InterfaceDefSeq_var T_var;

  inline InterfaceDefSeq_out(T*& s) : _data(s) { _data = 0; }
  inline InterfaceDefSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline InterfaceDefSeq_out(const InterfaceDefSeq_out& s) : _data(s._data) {}
  inline InterfaceDefSeq_out& operator = (const InterfaceDefSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline InterfaceDefSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline _CORBA_ObjRef_Element< _objref_InterfaceDef, InterfaceDef_Helper>  operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  InterfaceDefSeq_out();
  InterfaceDefSeq_out& operator=(const T_var&);
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ValueDefSeq;

class ValueDefSeq_var;

class ValueDefSeq : public _CORBA_Unbounded_Sequence_ObjRef< _objref_ValueDef, _CORBA_ObjRef_Element< _objref_ValueDef, ValueDef_Helper> , ValueDef_Helper>  {
public:
  typedef ValueDefSeq_var _var_type;
  inline ValueDefSeq() {}
  inline ValueDefSeq(const ValueDefSeq& s)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_ValueDef, _CORBA_ObjRef_Element< _objref_ValueDef, ValueDef_Helper> , ValueDef_Helper> (s) {}

  inline ValueDefSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_ValueDef, _CORBA_ObjRef_Element< _objref_ValueDef, ValueDef_Helper> , ValueDef_Helper> (_max) {}
  inline ValueDefSeq(_CORBA_ULong _max, _CORBA_ULong _len, ValueDef_ptr* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_ValueDef, _CORBA_ObjRef_Element< _objref_ValueDef, ValueDef_Helper> , ValueDef_Helper> (_max, _len, _val, _rel) {}

  inline ValueDefSeq& operator = (const ValueDefSeq& s) {
    _CORBA_Unbounded_Sequence_ObjRef< _objref_ValueDef, _CORBA_ObjRef_Element< _objref_ValueDef, ValueDef_Helper> , ValueDef_Helper> ::operator=(s);
    return *this;
  }
};

class ValueDefSeq_out;

class ValueDefSeq_var {
public:
  typedef ValueDefSeq T;
  typedef ValueDefSeq_var T_var;

  inline ValueDefSeq_var() : _pd_seq(0) {}
  inline ValueDefSeq_var(T* s) : _pd_seq(s) {}
  inline ValueDefSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ValueDefSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline _CORBA_ObjRef_Element< _objref_ValueDef, ValueDef_Helper>  operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class ValueDefSeq_out;

private:
  T* _pd_seq;
};

class ValueDefSeq_out {
public:
  typedef ValueDefSeq T;
  typedef ValueDefSeq_var T_var;

  inline ValueDefSeq_out(T*& s) : _data(s) { _data = 0; }
  inline ValueDefSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline ValueDefSeq_out(const ValueDefSeq_out& s) : _data(s._data) {}
  inline ValueDefSeq_out& operator = (const ValueDefSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline ValueDefSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline _CORBA_ObjRef_Element< _objref_ValueDef, ValueDef_Helper>  operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  ValueDefSeq_out();
  ValueDefSeq_out& operator=(const T_var&);
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_AbstractInterfaceDefSeq;

class AbstractInterfaceDefSeq_var;

class AbstractInterfaceDefSeq : public _CORBA_Unbounded_Sequence_ObjRef< _objref_AbstractInterfaceDef, _CORBA_ObjRef_Element< _objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper> , AbstractInterfaceDef_Helper>  {
public:
  typedef AbstractInterfaceDefSeq_var _var_type;
  inline AbstractInterfaceDefSeq() {}
  inline AbstractInterfaceDefSeq(const AbstractInterfaceDefSeq& s)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_AbstractInterfaceDef, _CORBA_ObjRef_Element< _objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper> , AbstractInterfaceDef_Helper> (s) {}

  inline AbstractInterfaceDefSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_AbstractInterfaceDef, _CORBA_ObjRef_Element< _objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper> , AbstractInterfaceDef_Helper> (_max) {}
  inline AbstractInterfaceDefSeq(_CORBA_ULong _max, _CORBA_ULong _len, AbstractInterfaceDef_ptr* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_AbstractInterfaceDef, _CORBA_ObjRef_Element< _objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper> , AbstractInterfaceDef_Helper> (_max, _len, _val, _rel) {}

  inline AbstractInterfaceDefSeq& operator = (const AbstractInterfaceDefSeq& s) {
    _CORBA_Unbounded_Sequence_ObjRef< _objref_AbstractInterfaceDef, _CORBA_ObjRef_Element< _objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper> , AbstractInterfaceDef_Helper> ::operator=(s);
    return *this;
  }
};

class AbstractInterfaceDefSeq_out;

class AbstractInterfaceDefSeq_var {
public:
  typedef AbstractInterfaceDefSeq T;
  typedef AbstractInterfaceDefSeq_var T_var;

  inline AbstractInterfaceDefSeq_var() : _pd_seq(0) {}
  inline AbstractInterfaceDefSeq_var(T* s) : _pd_seq(s) {}
  inline AbstractInterfaceDefSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~AbstractInterfaceDefSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline _CORBA_ObjRef_Element< _objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper>  operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class AbstractInterfaceDefSeq_out;

private:
  T* _pd_seq;
};

class AbstractInterfaceDefSeq_out {
public:
  typedef AbstractInterfaceDefSeq T;
  typedef AbstractInterfaceDefSeq_var T_var;

  inline AbstractInterfaceDefSeq_out(T*& s) : _data(s) { _data = 0; }
  inline AbstractInterfaceDefSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline AbstractInterfaceDefSeq_out(const AbstractInterfaceDefSeq_out& s) : _data(s._data) {}
  inline AbstractInterfaceDefSeq_out& operator = (const AbstractInterfaceDefSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline AbstractInterfaceDefSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline _CORBA_ObjRef_Element< _objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper>  operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  AbstractInterfaceDefSeq_out();
  AbstractInterfaceDefSeq_out& operator=(const T_var&);
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ContainedSeq;

class ContainedSeq_var;

class ContainedSeq : public _CORBA_Unbounded_Sequence_ObjRef< _objref_Contained, _CORBA_ObjRef_Element< _objref_Contained, Contained_Helper> , Contained_Helper>  {
public:
  typedef ContainedSeq_var _var_type;
  inline ContainedSeq() {}
  inline ContainedSeq(const ContainedSeq& s)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_Contained, _CORBA_ObjRef_Element< _objref_Contained, Contained_Helper> , Contained_Helper> (s) {}

  inline ContainedSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_Contained, _CORBA_ObjRef_Element< _objref_Contained, Contained_Helper> , Contained_Helper> (_max) {}
  inline ContainedSeq(_CORBA_ULong _max, _CORBA_ULong _len, Contained_ptr* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_Contained, _CORBA_ObjRef_Element< _objref_Contained, Contained_Helper> , Contained_Helper> (_max, _len, _val, _rel) {}

  inline ContainedSeq& operator = (const ContainedSeq& s) {
    _CORBA_Unbounded_Sequence_ObjRef< _objref_Contained, _CORBA_ObjRef_Element< _objref_Contained, Contained_Helper> , Contained_Helper> ::operator=(s);
    return *this;
  }
};

class ContainedSeq_out;

class ContainedSeq_var {
public:
  typedef ContainedSeq T;
  typedef ContainedSeq_var T_var;

  inline ContainedSeq_var() : _pd_seq(0) {}
  inline ContainedSeq_var(T* s) : _pd_seq(s) {}
  inline ContainedSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ContainedSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline _CORBA_ObjRef_Element< _objref_Contained, Contained_Helper>  operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class ContainedSeq_out;

private:
  T* _pd_seq;
};

class ContainedSeq_out {
public:
  typedef ContainedSeq T;
  typedef ContainedSeq_var T_var;

  inline ContainedSeq_out(T*& s) : _data(s) { _data = 0; }
  inline ContainedSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline ContainedSeq_out(const ContainedSeq_out& s) : _data(s._data) {}
  inline ContainedSeq_out& operator = (const ContainedSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline ContainedSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline _CORBA_ObjRef_Element< _objref_Contained, Contained_Helper>  operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  ContainedSeq_out();
  ContainedSeq_out& operator=(const T_var&);
};

struct Initializer {
  typedef _CORBA_ConstrType_Variable_Var<Initializer> _var_type;

  StructMemberSeq members;

  CORBA::String_member name;

  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef Initializer::_var_type Initializer_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< Initializer,Initializer_var > Initializer_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_Initializer;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_InitializerSeq;

class InitializerSeq_var;

class InitializerSeq : public _CORBA_Unbounded_Sequence< Initializer>  {
public:
  typedef InitializerSeq_var _var_type;
  inline InitializerSeq() {}
  inline InitializerSeq(const InitializerSeq& s)
    : _CORBA_Unbounded_Sequence< Initializer> (s) {}

  inline InitializerSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< Initializer> (_max) {}
  inline InitializerSeq(_CORBA_ULong _max, _CORBA_ULong _len, Initializer* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< Initializer> (_max, _len, _val, _rel) {}

  inline InitializerSeq& operator = (const InitializerSeq& s) {
    _CORBA_Unbounded_Sequence< Initializer> ::operator=(s);
    return *this;
  }
};

class InitializerSeq_out;

class InitializerSeq_var {
public:
  typedef InitializerSeq T;
  typedef InitializerSeq_var T_var;

  inline InitializerSeq_var() : _pd_seq(0) {}
  inline InitializerSeq_var(T* s) : _pd_seq(s) {}
  inline InitializerSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~InitializerSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline Initializer& operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class InitializerSeq_out;

private:
  T* _pd_seq;
};

class InitializerSeq_out {
public:
  typedef InitializerSeq T;
  typedef InitializerSeq_var T_var;

  inline InitializerSeq_out(T*& s) : _data(s) { _data = 0; }
  inline InitializerSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline InitializerSeq_out(const InitializerSeq_out& s) : _data(s._data) {}
  inline InitializerSeq_out& operator = (const InitializerSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline InitializerSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline Initializer& operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  InitializerSeq_out();
  InitializerSeq_out& operator=(const T_var&);
};

#ifndef __CORBA_mContainer__
#define __CORBA_mContainer__

class Container;
class _objref_Container;
class _impl_Container;
typedef _objref_Container* Container_ptr;
typedef Container_ptr ContainerRef;

class Container_Helper {
public:
  typedef Container_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_Container, Container_Helper> Container_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_Container,Container_Helper > Container_out;

#endif

class Container {
public:
  // Declarations for this interface type.
  typedef Container_ptr _ptr_type;
  typedef Container_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  struct Description {
    typedef _CORBA_ConstrType_Variable_Var<Description> _var_type;

    _CORBA_ObjRef_Member< _objref_Contained, Contained_Helper>  contained_object;

    DefinitionKind kind;

    CORBA::Any value;

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Description::_var_type Description_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Description,Description_var > Description_out;

  static _dyn_attr const CORBA::TypeCode_ptr _tc_Description;

  static _dyn_attr const CORBA::TypeCode_ptr _tc_DescriptionSeq;

  class DescriptionSeq_var;

  class DescriptionSeq : public _CORBA_Unbounded_Sequence< Description>  {
  public:
    typedef DescriptionSeq_var _var_type;
    inline DescriptionSeq() {}
    inline DescriptionSeq(const DescriptionSeq& s)
      : _CORBA_Unbounded_Sequence< Description> (s) {}

    inline DescriptionSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Description> (_max) {}
    inline DescriptionSeq(_CORBA_ULong _max, _CORBA_ULong _len, Description* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Description> (_max, _len, _val, _rel) {}

    inline DescriptionSeq& operator = (const DescriptionSeq& s) {
      _CORBA_Unbounded_Sequence< Description> ::operator=(s);
      return *this;
    }
  };

  class DescriptionSeq_out;

  class DescriptionSeq_var {
  public:
    typedef DescriptionSeq T;
    typedef DescriptionSeq_var T_var;

    inline DescriptionSeq_var() : _pd_seq(0) {}
    inline DescriptionSeq_var(T* s) : _pd_seq(s) {}
    inline DescriptionSeq_var(const T_var& s) {
      if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~DescriptionSeq_var() { if( _pd_seq )  delete _pd_seq; }

    inline T_var& operator = (T* s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = s;
      return *this;
    }
    inline T_var& operator = (const T_var& s) {
      if( s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new T;
        *_pd_seq = *s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }

    inline Description& operator [] (_CORBA_ULong s) {
      return (*_pd_seq)[s];
    }

    inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
    inline operator T& () const { return *_pd_seq; }
#else
    inline operator const T& () const { return *_pd_seq; }
    inline operator T& () { return *_pd_seq; }
#endif

    inline const T& in() const { return *_pd_seq; }
    inline T&       inout()    { return *_pd_seq; }
    inline T*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

    friend class DescriptionSeq_out;

  private:
    T* _pd_seq;
  };

  class DescriptionSeq_out {
  public:
    typedef DescriptionSeq T;
    typedef DescriptionSeq_var T_var;

    inline DescriptionSeq_out(T*& s) : _data(s) { _data = 0; }
    inline DescriptionSeq_out(T_var& s)
      : _data(s._pd_seq) { s = (T*) 0; }
    inline DescriptionSeq_out(const DescriptionSeq_out& s) : _data(s._data) {}
    inline DescriptionSeq_out& operator = (const DescriptionSeq_out& s) {
      _data = s._data;
      return *this;
    }  inline DescriptionSeq_out& operator = (T* s) {
      _data = s;
      return *this;
    }
    inline operator T*&()  { return _data; }
    inline T*& ptr()       { return _data; }
    inline T* operator->() { return _data; }

    inline Description& operator [] (_CORBA_ULong i) {
      return (*_data)[i];
    }

    T*& _data;

  private:
    DescriptionSeq_out();
    DescriptionSeq_out& operator=(const T_var&);
  };

};

class _objref_Container :
  public virtual _objref_IRObject
{
public:
  Contained_ptr lookup(const char* search_name);
  ContainedSeq* contents(DefinitionKind limit_type, CORBA::Boolean exclude_inherited);
  ContainedSeq* lookup_name(const char* search_name, CORBA::Long levels_to_search, DefinitionKind limit_type, CORBA::Boolean exclude_inherited);
  Container::DescriptionSeq* describe_contents(DefinitionKind limit_type, CORBA::Boolean exclude_inherited, CORBA::Long max_returned_objs);
  ModuleDef_ptr create_module(const char* id, const char* name, const char* version);
  ConstantDef_ptr create_constant(const char* id, const char* name, const char* version, IDLType_ptr type, const CORBA::Any& value);
  StructDef_ptr create_struct(const char* id, const char* name, const char* version, const StructMemberSeq& members);
  UnionDef_ptr create_union(const char* id, const char* name, const char* version, IDLType_ptr discriminator_type, const UnionMemberSeq& members);
  EnumDef_ptr create_enum(const char* id, const char* name, const char* version, const EnumMemberSeq& members);
  AliasDef_ptr create_alias(const char* id, const char* name, const char* version, IDLType_ptr original_type);
  InterfaceDef_ptr create_interface(const char* id, const char* name, const char* version, const InterfaceDefSeq& base_interfaces);
  ValueDef_ptr create_value(const char* id, const char* name, const char* version, CORBA::Boolean is_custom, CORBA::Boolean is_abstract, ValueDef_ptr base_value, CORBA::Boolean is_truncatable, const ValueDefSeq& abstract_base_values, const InterfaceDefSeq& supported_interfaces, const InitializerSeq& initializers);
  ValueBoxDef_ptr create_value_box(const char* id, const char* name, const char* version, IDLType_ptr original_type_def);
  ExceptionDef_ptr create_exception(const char* id, const char* name, const char* version, const StructMemberSeq& members);
  NativeDef_ptr create_native(const char* id, const char* name, const char* version);
  AbstractInterfaceDef_ptr create_abstract_interface(const char* id, const char* name, const char* version, const AbstractInterfaceDefSeq& base_interfaces);
  
  inline _objref_Container() { _PR_setobj(0); }  // nil
  _objref_Container(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_Container();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_Container(const _objref_Container&);
  _objref_Container& operator = (const _objref_Container&);
  // not implemented
};

class _pof_Container : public proxyObjectFactory {
public:
  inline _pof_Container() : proxyObjectFactory(Container::_PD_repoId) {}
  virtual ~_pof_Container();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_Container :
  public virtual _impl_IRObject
{
public:
  virtual ~_impl_Container();

  virtual Contained_ptr lookup(const char* search_name) = 0;
  virtual ContainedSeq* contents(DefinitionKind limit_type, CORBA::Boolean exclude_inherited) = 0;
  virtual ContainedSeq* lookup_name(const char* search_name, CORBA::Long levels_to_search, DefinitionKind limit_type, CORBA::Boolean exclude_inherited) = 0;
  virtual Container::DescriptionSeq* describe_contents(DefinitionKind limit_type, CORBA::Boolean exclude_inherited, CORBA::Long max_returned_objs) = 0;
  virtual ModuleDef_ptr create_module(const char* id, const char* name, const char* version) = 0;
  virtual ConstantDef_ptr create_constant(const char* id, const char* name, const char* version, IDLType_ptr type, const CORBA::Any& value) = 0;
  virtual StructDef_ptr create_struct(const char* id, const char* name, const char* version, const StructMemberSeq& members) = 0;
  virtual UnionDef_ptr create_union(const char* id, const char* name, const char* version, IDLType_ptr discriminator_type, const UnionMemberSeq& members) = 0;
  virtual EnumDef_ptr create_enum(const char* id, const char* name, const char* version, const EnumMemberSeq& members) = 0;
  virtual AliasDef_ptr create_alias(const char* id, const char* name, const char* version, IDLType_ptr original_type) = 0;
  virtual InterfaceDef_ptr create_interface(const char* id, const char* name, const char* version, const InterfaceDefSeq& base_interfaces) = 0;
  virtual ValueDef_ptr create_value(const char* id, const char* name, const char* version, CORBA::Boolean is_custom, CORBA::Boolean is_abstract, ValueDef_ptr base_value, CORBA::Boolean is_truncatable, const ValueDefSeq& abstract_base_values, const InterfaceDefSeq& supported_interfaces, const InitializerSeq& initializers) = 0;
  virtual ValueBoxDef_ptr create_value_box(const char* id, const char* name, const char* version, IDLType_ptr original_type_def) = 0;
  virtual ExceptionDef_ptr create_exception(const char* id, const char* name, const char* version, const StructMemberSeq& members) = 0;
  virtual NativeDef_ptr create_native(const char* id, const char* name, const char* version) = 0;
  virtual AbstractInterfaceDef_ptr create_abstract_interface(const char* id, const char* name, const char* version, const AbstractInterfaceDefSeq& base_interfaces) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_Container;

#ifndef __CORBA_mIDLType__
#define __CORBA_mIDLType__

class IDLType;
class _objref_IDLType;
class _impl_IDLType;
typedef _objref_IDLType* IDLType_ptr;
typedef IDLType_ptr IDLTypeRef;

class IDLType_Helper {
public:
  typedef IDLType_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_IDLType, IDLType_Helper> IDLType_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_IDLType,IDLType_Helper > IDLType_out;

#endif

class IDLType {
public:
  // Declarations for this interface type.
  typedef IDLType_ptr _ptr_type;
  typedef IDLType_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_IDLType :
  public virtual _objref_IRObject
{
public:
  
  CORBA::TypeCode_ptr type();
  
  inline _objref_IDLType() { _PR_setobj(0); }  // nil
  _objref_IDLType(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_IDLType();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_IDLType(const _objref_IDLType&);
  _objref_IDLType& operator = (const _objref_IDLType&);
  // not implemented
};

class _pof_IDLType : public proxyObjectFactory {
public:
  inline _pof_IDLType() : proxyObjectFactory(IDLType::_PD_repoId) {}
  virtual ~_pof_IDLType();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_IDLType :
  public virtual _impl_IRObject
{
public:
  virtual ~_impl_IDLType();

  virtual CORBA::TypeCode_ptr type() = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_IDLType;

#ifndef __CORBA_mPrimitiveDef__
#define __CORBA_mPrimitiveDef__

class PrimitiveDef;
class _objref_PrimitiveDef;
class _impl_PrimitiveDef;
typedef _objref_PrimitiveDef* PrimitiveDef_ptr;
typedef PrimitiveDef_ptr PrimitiveDefRef;

class PrimitiveDef_Helper {
public:
  typedef PrimitiveDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_PrimitiveDef, PrimitiveDef_Helper> PrimitiveDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_PrimitiveDef,PrimitiveDef_Helper > PrimitiveDef_out;

#endif

#ifndef __CORBA_mStringDef__
#define __CORBA_mStringDef__

class StringDef;
class _objref_StringDef;
class _impl_StringDef;
typedef _objref_StringDef* StringDef_ptr;
typedef StringDef_ptr StringDefRef;

class StringDef_Helper {
public:
  typedef StringDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_StringDef, StringDef_Helper> StringDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_StringDef,StringDef_Helper > StringDef_out;

#endif

#ifndef __CORBA_mSequenceDef__
#define __CORBA_mSequenceDef__

class SequenceDef;
class _objref_SequenceDef;
class _impl_SequenceDef;
typedef _objref_SequenceDef* SequenceDef_ptr;
typedef SequenceDef_ptr SequenceDefRef;

class SequenceDef_Helper {
public:
  typedef SequenceDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_SequenceDef, SequenceDef_Helper> SequenceDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_SequenceDef,SequenceDef_Helper > SequenceDef_out;

#endif

#ifndef __CORBA_mArrayDef__
#define __CORBA_mArrayDef__

class ArrayDef;
class _objref_ArrayDef;
class _impl_ArrayDef;
typedef _objref_ArrayDef* ArrayDef_ptr;
typedef ArrayDef_ptr ArrayDefRef;

class ArrayDef_Helper {
public:
  typedef ArrayDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ArrayDef, ArrayDef_Helper> ArrayDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ArrayDef,ArrayDef_Helper > ArrayDef_out;

#endif

enum PrimitiveKind { pk_null, pk_void, pk_short, pk_long, pk_ushort, pk_ulong, pk_float, pk_double, pk_boolean, pk_char, pk_octet, pk_any, pk_TypeCode, pk_Principal, pk_string, pk_objref, pk_longlong, pk_ulonglong, pk_longdouble, pk_wchar, pk_wstring, pk_value_base };
typedef PrimitiveKind& PrimitiveKind_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_PrimitiveKind;

#ifndef __CORBA_mRepository__
#define __CORBA_mRepository__

class Repository;
class _objref_Repository;
class _impl_Repository;
typedef _objref_Repository* Repository_ptr;
typedef Repository_ptr RepositoryRef;

class Repository_Helper {
public:
  typedef Repository_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_Repository, Repository_Helper> Repository_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_Repository,Repository_Helper > Repository_out;

#endif

class Repository {
public:
  // Declarations for this interface type.
  typedef Repository_ptr _ptr_type;
  typedef Repository_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_Repository :
  public virtual _objref_Container
{
public:
  Contained_ptr lookup_id(const char* search_id);
  CORBA::TypeCode_ptr get_canonical_typecode(CORBA::TypeCode_ptr tc);
  PrimitiveDef_ptr get_primitive(PrimitiveKind kind);
  StringDef_ptr create_string(CORBA::ULong bound);
  WstringDef_ptr create_wstring(CORBA::ULong bound);
  SequenceDef_ptr create_sequence(CORBA::ULong bound, IDLType_ptr element_type);
  ArrayDef_ptr create_array(CORBA::ULong length, IDLType_ptr element_type);
  FixedDef_ptr create_fixed(CORBA::UShort digits, CORBA::Short scale);
  
  inline _objref_Repository() { _PR_setobj(0); }  // nil
  _objref_Repository(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_Repository();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_Repository(const _objref_Repository&);
  _objref_Repository& operator = (const _objref_Repository&);
  // not implemented
};

class _pof_Repository : public proxyObjectFactory {
public:
  inline _pof_Repository() : proxyObjectFactory(Repository::_PD_repoId) {}
  virtual ~_pof_Repository();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_Repository :
  public virtual _impl_Container
{
public:
  virtual ~_impl_Repository();

  virtual Contained_ptr lookup_id(const char* search_id) = 0;
  virtual CORBA::TypeCode_ptr get_canonical_typecode(CORBA::TypeCode_ptr tc) = 0;
  virtual PrimitiveDef_ptr get_primitive(PrimitiveKind kind) = 0;
  virtual StringDef_ptr create_string(CORBA::ULong bound) = 0;
  virtual WstringDef_ptr create_wstring(CORBA::ULong bound) = 0;
  virtual SequenceDef_ptr create_sequence(CORBA::ULong bound, IDLType_ptr element_type) = 0;
  virtual ArrayDef_ptr create_array(CORBA::ULong length, IDLType_ptr element_type) = 0;
  virtual FixedDef_ptr create_fixed(CORBA::UShort digits, CORBA::Short scale) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_Repository;

#ifndef __CORBA_mModuleDef__
#define __CORBA_mModuleDef__

class ModuleDef;
class _objref_ModuleDef;
class _impl_ModuleDef;
typedef _objref_ModuleDef* ModuleDef_ptr;
typedef ModuleDef_ptr ModuleDefRef;

class ModuleDef_Helper {
public:
  typedef ModuleDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ModuleDef, ModuleDef_Helper> ModuleDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ModuleDef,ModuleDef_Helper > ModuleDef_out;

#endif

class ModuleDef {
public:
  // Declarations for this interface type.
  typedef ModuleDef_ptr _ptr_type;
  typedef ModuleDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_ModuleDef :
  public virtual _objref_Container,
  public virtual _objref_Contained
{
public:
  
  inline _objref_ModuleDef() { _PR_setobj(0); }  // nil
  _objref_ModuleDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_ModuleDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_ModuleDef(const _objref_ModuleDef&);
  _objref_ModuleDef& operator = (const _objref_ModuleDef&);
  // not implemented
};

class _pof_ModuleDef : public proxyObjectFactory {
public:
  inline _pof_ModuleDef() : proxyObjectFactory(ModuleDef::_PD_repoId) {}
  virtual ~_pof_ModuleDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_ModuleDef :
  public virtual _impl_Container, 
  public virtual _impl_Contained
{
public:
  virtual ~_impl_ModuleDef();

public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ModuleDef;

struct ModuleDescription {
  typedef _CORBA_ConstrType_Variable_Var<ModuleDescription> _var_type;

  CORBA::String_member name;

  CORBA::String_member id;

  CORBA::String_member defined_in;

  CORBA::String_member version;

  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef ModuleDescription::_var_type ModuleDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< ModuleDescription,ModuleDescription_var > ModuleDescription_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ModuleDescription;

#ifndef __CORBA_mConstantDef__
#define __CORBA_mConstantDef__

class ConstantDef;
class _objref_ConstantDef;
class _impl_ConstantDef;
typedef _objref_ConstantDef* ConstantDef_ptr;
typedef ConstantDef_ptr ConstantDefRef;

class ConstantDef_Helper {
public:
  typedef ConstantDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ConstantDef, ConstantDef_Helper> ConstantDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ConstantDef,ConstantDef_Helper > ConstantDef_out;

#endif

class ConstantDef {
public:
  // Declarations for this interface type.
  typedef ConstantDef_ptr _ptr_type;
  typedef ConstantDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_ConstantDef :
  public virtual _objref_Contained
{
public:
  
  CORBA::TypeCode_ptr type();
  IDLType_ptr type_def();
  void type_def(IDLType_ptr);
  CORBA::Any* value();
  void value(const CORBA::Any&);
  
  inline _objref_ConstantDef() { _PR_setobj(0); }  // nil
  _objref_ConstantDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_ConstantDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_ConstantDef(const _objref_ConstantDef&);
  _objref_ConstantDef& operator = (const _objref_ConstantDef&);
  // not implemented
};

class _pof_ConstantDef : public proxyObjectFactory {
public:
  inline _pof_ConstantDef() : proxyObjectFactory(ConstantDef::_PD_repoId) {}
  virtual ~_pof_ConstantDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_ConstantDef :
  public virtual _impl_Contained
{
public:
  virtual ~_impl_ConstantDef();

  virtual CORBA::TypeCode_ptr type() = 0;
  virtual IDLType_ptr type_def() = 0;
  virtual void type_def(IDLType_ptr) = 0;
  virtual CORBA::Any* value() = 0;
  virtual void value(const CORBA::Any&) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ConstantDef;

struct ConstantDescription {
  typedef _CORBA_ConstrType_Variable_Var<ConstantDescription> _var_type;

  CORBA::String_member name;

  CORBA::String_member id;

  CORBA::String_member defined_in;

  CORBA::String_member version;

  CORBA::TypeCode_member type;

  CORBA::Any value;

  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef ConstantDescription::_var_type ConstantDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< ConstantDescription,ConstantDescription_var > ConstantDescription_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ConstantDescription;

#ifndef __CORBA_mTypedefDef__
#define __CORBA_mTypedefDef__

class TypedefDef;
class _objref_TypedefDef;
class _impl_TypedefDef;
typedef _objref_TypedefDef* TypedefDef_ptr;
typedef TypedefDef_ptr TypedefDefRef;

class TypedefDef_Helper {
public:
  typedef TypedefDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_TypedefDef, TypedefDef_Helper> TypedefDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_TypedefDef,TypedefDef_Helper > TypedefDef_out;

#endif

class TypedefDef {
public:
  // Declarations for this interface type.
  typedef TypedefDef_ptr _ptr_type;
  typedef TypedefDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_TypedefDef :
  public virtual _objref_Contained,
  public virtual _objref_IDLType
{
public:
  
  inline _objref_TypedefDef() { _PR_setobj(0); }  // nil
  _objref_TypedefDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_TypedefDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_TypedefDef(const _objref_TypedefDef&);
  _objref_TypedefDef& operator = (const _objref_TypedefDef&);
  // not implemented
};

class _pof_TypedefDef : public proxyObjectFactory {
public:
  inline _pof_TypedefDef() : proxyObjectFactory(TypedefDef::_PD_repoId) {}
  virtual ~_pof_TypedefDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_TypedefDef :
  public virtual _impl_Contained, 
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_TypedefDef();

public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_TypedefDef;

struct TypeDescription {
  typedef _CORBA_ConstrType_Variable_Var<TypeDescription> _var_type;

  CORBA::String_member name;

  CORBA::String_member id;

  CORBA::String_member defined_in;

  CORBA::String_member version;

  CORBA::TypeCode_member type;

  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef TypeDescription::_var_type TypeDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< TypeDescription,TypeDescription_var > TypeDescription_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_TypeDescription;

#ifndef __CORBA_mStructDef__
#define __CORBA_mStructDef__

class StructDef;
class _objref_StructDef;
class _impl_StructDef;
typedef _objref_StructDef* StructDef_ptr;
typedef StructDef_ptr StructDefRef;

class StructDef_Helper {
public:
  typedef StructDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_StructDef, StructDef_Helper> StructDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_StructDef,StructDef_Helper > StructDef_out;

#endif

class StructDef {
public:
  // Declarations for this interface type.
  typedef StructDef_ptr _ptr_type;
  typedef StructDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_StructDef :
  public virtual _objref_TypedefDef,
  public virtual _objref_Container
{
public:
  
  StructMemberSeq* members();
  void members(const StructMemberSeq&);
  
  inline _objref_StructDef() { _PR_setobj(0); }  // nil
  _objref_StructDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_StructDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_StructDef(const _objref_StructDef&);
  _objref_StructDef& operator = (const _objref_StructDef&);
  // not implemented
};

class _pof_StructDef : public proxyObjectFactory {
public:
  inline _pof_StructDef() : proxyObjectFactory(StructDef::_PD_repoId) {}
  virtual ~_pof_StructDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_StructDef :
  public virtual _impl_TypedefDef, 
  public virtual _impl_Container
{
public:
  virtual ~_impl_StructDef();

  virtual StructMemberSeq* members() = 0;
  virtual void members(const StructMemberSeq&) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_StructDef;

#ifndef __CORBA_mUnionDef__
#define __CORBA_mUnionDef__

class UnionDef;
class _objref_UnionDef;
class _impl_UnionDef;
typedef _objref_UnionDef* UnionDef_ptr;
typedef UnionDef_ptr UnionDefRef;

class UnionDef_Helper {
public:
  typedef UnionDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_UnionDef, UnionDef_Helper> UnionDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_UnionDef,UnionDef_Helper > UnionDef_out;

#endif

class UnionDef {
public:
  // Declarations for this interface type.
  typedef UnionDef_ptr _ptr_type;
  typedef UnionDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_UnionDef :
  public virtual _objref_TypedefDef,
  public virtual _objref_Container
{
public:
  
  CORBA::TypeCode_ptr discriminator_type();
  IDLType_ptr discriminator_type_def();
  void discriminator_type_def(IDLType_ptr);
  UnionMemberSeq* members();
  void members(const UnionMemberSeq&);
  
  inline _objref_UnionDef() { _PR_setobj(0); }  // nil
  _objref_UnionDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_UnionDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_UnionDef(const _objref_UnionDef&);
  _objref_UnionDef& operator = (const _objref_UnionDef&);
  // not implemented
};

class _pof_UnionDef : public proxyObjectFactory {
public:
  inline _pof_UnionDef() : proxyObjectFactory(UnionDef::_PD_repoId) {}
  virtual ~_pof_UnionDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_UnionDef :
  public virtual _impl_TypedefDef, 
  public virtual _impl_Container
{
public:
  virtual ~_impl_UnionDef();

  virtual CORBA::TypeCode_ptr discriminator_type() = 0;
  virtual IDLType_ptr discriminator_type_def() = 0;
  virtual void discriminator_type_def(IDLType_ptr) = 0;
  virtual UnionMemberSeq* members() = 0;
  virtual void members(const UnionMemberSeq&) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_UnionDef;

#ifndef __CORBA_mEnumDef__
#define __CORBA_mEnumDef__

class EnumDef;
class _objref_EnumDef;
class _impl_EnumDef;
typedef _objref_EnumDef* EnumDef_ptr;
typedef EnumDef_ptr EnumDefRef;

class EnumDef_Helper {
public:
  typedef EnumDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_EnumDef, EnumDef_Helper> EnumDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_EnumDef,EnumDef_Helper > EnumDef_out;

#endif

class EnumDef {
public:
  // Declarations for this interface type.
  typedef EnumDef_ptr _ptr_type;
  typedef EnumDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_EnumDef :
  public virtual _objref_TypedefDef
{
public:
  
  EnumMemberSeq* members();
  void members(const EnumMemberSeq&);
  
  inline _objref_EnumDef() { _PR_setobj(0); }  // nil
  _objref_EnumDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_EnumDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_EnumDef(const _objref_EnumDef&);
  _objref_EnumDef& operator = (const _objref_EnumDef&);
  // not implemented
};

class _pof_EnumDef : public proxyObjectFactory {
public:
  inline _pof_EnumDef() : proxyObjectFactory(EnumDef::_PD_repoId) {}
  virtual ~_pof_EnumDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_EnumDef :
  public virtual _impl_TypedefDef
{
public:
  virtual ~_impl_EnumDef();

  virtual EnumMemberSeq* members() = 0;
  virtual void members(const EnumMemberSeq&) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_EnumDef;

#ifndef __CORBA_mAliasDef__
#define __CORBA_mAliasDef__

class AliasDef;
class _objref_AliasDef;
class _impl_AliasDef;
typedef _objref_AliasDef* AliasDef_ptr;
typedef AliasDef_ptr AliasDefRef;

class AliasDef_Helper {
public:
  typedef AliasDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_AliasDef, AliasDef_Helper> AliasDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_AliasDef,AliasDef_Helper > AliasDef_out;

#endif

class AliasDef {
public:
  // Declarations for this interface type.
  typedef AliasDef_ptr _ptr_type;
  typedef AliasDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_AliasDef :
  public virtual _objref_TypedefDef
{
public:
  
  IDLType_ptr original_type_def();
  void original_type_def(IDLType_ptr);
  
  inline _objref_AliasDef() { _PR_setobj(0); }  // nil
  _objref_AliasDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_AliasDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_AliasDef(const _objref_AliasDef&);
  _objref_AliasDef& operator = (const _objref_AliasDef&);
  // not implemented
};

class _pof_AliasDef : public proxyObjectFactory {
public:
  inline _pof_AliasDef() : proxyObjectFactory(AliasDef::_PD_repoId) {}
  virtual ~_pof_AliasDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_AliasDef :
  public virtual _impl_TypedefDef
{
public:
  virtual ~_impl_AliasDef();

  virtual IDLType_ptr original_type_def() = 0;
  virtual void original_type_def(IDLType_ptr) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_AliasDef;

#ifndef __CORBA_mNativeDef__
#define __CORBA_mNativeDef__

class NativeDef;
class _objref_NativeDef;
class _impl_NativeDef;
typedef _objref_NativeDef* NativeDef_ptr;
typedef NativeDef_ptr NativeDefRef;

class NativeDef_Helper {
public:
  typedef NativeDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_NativeDef, NativeDef_Helper> NativeDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_NativeDef,NativeDef_Helper > NativeDef_out;

#endif

class NativeDef {
public:
  // Declarations for this interface type.
  typedef NativeDef_ptr _ptr_type;
  typedef NativeDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_NativeDef :
  public virtual _objref_TypedefDef
{
public:
  
  inline _objref_NativeDef() { _PR_setobj(0); }  // nil
  _objref_NativeDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_NativeDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_NativeDef(const _objref_NativeDef&);
  _objref_NativeDef& operator = (const _objref_NativeDef&);
  // not implemented
};

class _pof_NativeDef : public proxyObjectFactory {
public:
  inline _pof_NativeDef() : proxyObjectFactory(NativeDef::_PD_repoId) {}
  virtual ~_pof_NativeDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_NativeDef :
  public virtual _impl_TypedefDef
{
public:
  virtual ~_impl_NativeDef();

public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_NativeDef;

#ifndef __CORBA_mPrimitiveDef__
#define __CORBA_mPrimitiveDef__

class PrimitiveDef;
class _objref_PrimitiveDef;
class _impl_PrimitiveDef;
typedef _objref_PrimitiveDef* PrimitiveDef_ptr;
typedef PrimitiveDef_ptr PrimitiveDefRef;

class PrimitiveDef_Helper {
public:
  typedef PrimitiveDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_PrimitiveDef, PrimitiveDef_Helper> PrimitiveDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_PrimitiveDef,PrimitiveDef_Helper > PrimitiveDef_out;

#endif

class PrimitiveDef {
public:
  // Declarations for this interface type.
  typedef PrimitiveDef_ptr _ptr_type;
  typedef PrimitiveDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_PrimitiveDef :
  public virtual _objref_IDLType
{
public:
  
  PrimitiveKind kind();
  
  inline _objref_PrimitiveDef() { _PR_setobj(0); }  // nil
  _objref_PrimitiveDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_PrimitiveDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_PrimitiveDef(const _objref_PrimitiveDef&);
  _objref_PrimitiveDef& operator = (const _objref_PrimitiveDef&);
  // not implemented
};

class _pof_PrimitiveDef : public proxyObjectFactory {
public:
  inline _pof_PrimitiveDef() : proxyObjectFactory(PrimitiveDef::_PD_repoId) {}
  virtual ~_pof_PrimitiveDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_PrimitiveDef :
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_PrimitiveDef();

  virtual PrimitiveKind kind() = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_PrimitiveDef;

#ifndef __CORBA_mStringDef__
#define __CORBA_mStringDef__

class StringDef;
class _objref_StringDef;
class _impl_StringDef;
typedef _objref_StringDef* StringDef_ptr;
typedef StringDef_ptr StringDefRef;

class StringDef_Helper {
public:
  typedef StringDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_StringDef, StringDef_Helper> StringDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_StringDef,StringDef_Helper > StringDef_out;

#endif

class StringDef {
public:
  // Declarations for this interface type.
  typedef StringDef_ptr _ptr_type;
  typedef StringDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_StringDef :
  public virtual _objref_IDLType
{
public:
  
  CORBA::ULong bound();
  void bound(CORBA::ULong);
  
  inline _objref_StringDef() { _PR_setobj(0); }  // nil
  _objref_StringDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_StringDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_StringDef(const _objref_StringDef&);
  _objref_StringDef& operator = (const _objref_StringDef&);
  // not implemented
};

class _pof_StringDef : public proxyObjectFactory {
public:
  inline _pof_StringDef() : proxyObjectFactory(StringDef::_PD_repoId) {}
  virtual ~_pof_StringDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_StringDef :
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_StringDef();

  virtual CORBA::ULong bound() = 0;
  virtual void bound(CORBA::ULong) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_StringDef;

#ifndef __CORBA_mWstringDef__
#define __CORBA_mWstringDef__

class WstringDef;
class _objref_WstringDef;
class _impl_WstringDef;
typedef _objref_WstringDef* WstringDef_ptr;
typedef WstringDef_ptr WstringDefRef;

class WstringDef_Helper {
public:
  typedef WstringDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_WstringDef, WstringDef_Helper> WstringDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_WstringDef,WstringDef_Helper > WstringDef_out;

#endif

class WstringDef {
public:
  // Declarations for this interface type.
  typedef WstringDef_ptr _ptr_type;
  typedef WstringDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_WstringDef :
  public virtual _objref_IDLType
{
public:
  
  CORBA::ULong bound();
  void bound(CORBA::ULong);
  
  inline _objref_WstringDef() { _PR_setobj(0); }  // nil
  _objref_WstringDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_WstringDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_WstringDef(const _objref_WstringDef&);
  _objref_WstringDef& operator = (const _objref_WstringDef&);
  // not implemented
};

class _pof_WstringDef : public proxyObjectFactory {
public:
  inline _pof_WstringDef() : proxyObjectFactory(WstringDef::_PD_repoId) {}
  virtual ~_pof_WstringDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_WstringDef :
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_WstringDef();

  virtual CORBA::ULong bound() = 0;
  virtual void bound(CORBA::ULong) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_WstringDef;

#ifndef __CORBA_mFixedDef__
#define __CORBA_mFixedDef__

class FixedDef;
class _objref_FixedDef;
class _impl_FixedDef;
typedef _objref_FixedDef* FixedDef_ptr;
typedef FixedDef_ptr FixedDefRef;

class FixedDef_Helper {
public:
  typedef FixedDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_FixedDef, FixedDef_Helper> FixedDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_FixedDef,FixedDef_Helper > FixedDef_out;

#endif

class FixedDef {
public:
  // Declarations for this interface type.
  typedef FixedDef_ptr _ptr_type;
  typedef FixedDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_FixedDef :
  public virtual _objref_IDLType
{
public:
  
  CORBA::UShort digits();
  void digits(CORBA::UShort);
  CORBA::Short scale();
  void scale(CORBA::Short);
  
  inline _objref_FixedDef() { _PR_setobj(0); }  // nil
  _objref_FixedDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_FixedDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_FixedDef(const _objref_FixedDef&);
  _objref_FixedDef& operator = (const _objref_FixedDef&);
  // not implemented
};

class _pof_FixedDef : public proxyObjectFactory {
public:
  inline _pof_FixedDef() : proxyObjectFactory(FixedDef::_PD_repoId) {}
  virtual ~_pof_FixedDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_FixedDef :
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_FixedDef();

  virtual CORBA::UShort digits() = 0;
  virtual void digits(CORBA::UShort) = 0;
  virtual CORBA::Short scale() = 0;
  virtual void scale(CORBA::Short) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_FixedDef;

#ifndef __CORBA_mSequenceDef__
#define __CORBA_mSequenceDef__

class SequenceDef;
class _objref_SequenceDef;
class _impl_SequenceDef;
typedef _objref_SequenceDef* SequenceDef_ptr;
typedef SequenceDef_ptr SequenceDefRef;

class SequenceDef_Helper {
public:
  typedef SequenceDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_SequenceDef, SequenceDef_Helper> SequenceDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_SequenceDef,SequenceDef_Helper > SequenceDef_out;

#endif

class SequenceDef {
public:
  // Declarations for this interface type.
  typedef SequenceDef_ptr _ptr_type;
  typedef SequenceDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_SequenceDef :
  public virtual _objref_IDLType
{
public:
  
  CORBA::ULong bound();
  void bound(CORBA::ULong);
  CORBA::TypeCode_ptr element_type();
  IDLType_ptr element_type_def();
  void element_type_def(IDLType_ptr);
  
  inline _objref_SequenceDef() { _PR_setobj(0); }  // nil
  _objref_SequenceDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_SequenceDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_SequenceDef(const _objref_SequenceDef&);
  _objref_SequenceDef& operator = (const _objref_SequenceDef&);
  // not implemented
};

class _pof_SequenceDef : public proxyObjectFactory {
public:
  inline _pof_SequenceDef() : proxyObjectFactory(SequenceDef::_PD_repoId) {}
  virtual ~_pof_SequenceDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_SequenceDef :
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_SequenceDef();

  virtual CORBA::ULong bound() = 0;
  virtual void bound(CORBA::ULong) = 0;
  virtual CORBA::TypeCode_ptr element_type() = 0;
  virtual IDLType_ptr element_type_def() = 0;
  virtual void element_type_def(IDLType_ptr) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_SequenceDef;

#ifndef __CORBA_mArrayDef__
#define __CORBA_mArrayDef__

class ArrayDef;
class _objref_ArrayDef;
class _impl_ArrayDef;
typedef _objref_ArrayDef* ArrayDef_ptr;
typedef ArrayDef_ptr ArrayDefRef;

class ArrayDef_Helper {
public:
  typedef ArrayDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ArrayDef, ArrayDef_Helper> ArrayDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ArrayDef,ArrayDef_Helper > ArrayDef_out;

#endif

class ArrayDef {
public:
  // Declarations for this interface type.
  typedef ArrayDef_ptr _ptr_type;
  typedef ArrayDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_ArrayDef :
  public virtual _objref_IDLType
{
public:
  
  CORBA::ULong length();
  void length(CORBA::ULong);
  CORBA::TypeCode_ptr element_type();
  IDLType_ptr element_type_def();
  void element_type_def(IDLType_ptr);
  
  inline _objref_ArrayDef() { _PR_setobj(0); }  // nil
  _objref_ArrayDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_ArrayDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_ArrayDef(const _objref_ArrayDef&);
  _objref_ArrayDef& operator = (const _objref_ArrayDef&);
  // not implemented
};

class _pof_ArrayDef : public proxyObjectFactory {
public:
  inline _pof_ArrayDef() : proxyObjectFactory(ArrayDef::_PD_repoId) {}
  virtual ~_pof_ArrayDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_ArrayDef :
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_ArrayDef();

  virtual CORBA::ULong length() = 0;
  virtual void length(CORBA::ULong) = 0;
  virtual CORBA::TypeCode_ptr element_type() = 0;
  virtual IDLType_ptr element_type_def() = 0;
  virtual void element_type_def(IDLType_ptr) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ArrayDef;

#ifndef __CORBA_mExceptionDef__
#define __CORBA_mExceptionDef__

class ExceptionDef;
class _objref_ExceptionDef;
class _impl_ExceptionDef;
typedef _objref_ExceptionDef* ExceptionDef_ptr;
typedef ExceptionDef_ptr ExceptionDefRef;

class ExceptionDef_Helper {
public:
  typedef ExceptionDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ExceptionDef, ExceptionDef_Helper> ExceptionDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ExceptionDef,ExceptionDef_Helper > ExceptionDef_out;

#endif

class ExceptionDef {
public:
  // Declarations for this interface type.
  typedef ExceptionDef_ptr _ptr_type;
  typedef ExceptionDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_ExceptionDef :
  public virtual _objref_Contained,
  public virtual _objref_Container
{
public:
  
  CORBA::TypeCode_ptr type();
  StructMemberSeq* members();
  void members(const StructMemberSeq&);
  
  inline _objref_ExceptionDef() { _PR_setobj(0); }  // nil
  _objref_ExceptionDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_ExceptionDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_ExceptionDef(const _objref_ExceptionDef&);
  _objref_ExceptionDef& operator = (const _objref_ExceptionDef&);
  // not implemented
};

class _pof_ExceptionDef : public proxyObjectFactory {
public:
  inline _pof_ExceptionDef() : proxyObjectFactory(ExceptionDef::_PD_repoId) {}
  virtual ~_pof_ExceptionDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_ExceptionDef :
  public virtual _impl_Contained, 
  public virtual _impl_Container
{
public:
  virtual ~_impl_ExceptionDef();

  virtual CORBA::TypeCode_ptr type() = 0;
  virtual StructMemberSeq* members() = 0;
  virtual void members(const StructMemberSeq&) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ExceptionDef;

struct ExceptionDescription {
  typedef _CORBA_ConstrType_Variable_Var<ExceptionDescription> _var_type;

  CORBA::String_member name;

  CORBA::String_member id;

  CORBA::String_member defined_in;

  CORBA::String_member version;

  CORBA::TypeCode_member type;

  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef ExceptionDescription::_var_type ExceptionDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< ExceptionDescription,ExceptionDescription_var > ExceptionDescription_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ExceptionDescription;

enum AttributeMode { ATTR_NORMAL, ATTR_READONLY };
typedef AttributeMode& AttributeMode_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_AttributeMode;

#ifndef __CORBA_mAttributeDef__
#define __CORBA_mAttributeDef__

class AttributeDef;
class _objref_AttributeDef;
class _impl_AttributeDef;
typedef _objref_AttributeDef* AttributeDef_ptr;
typedef AttributeDef_ptr AttributeDefRef;

class AttributeDef_Helper {
public:
  typedef AttributeDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_AttributeDef, AttributeDef_Helper> AttributeDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_AttributeDef,AttributeDef_Helper > AttributeDef_out;

#endif

class AttributeDef {
public:
  // Declarations for this interface type.
  typedef AttributeDef_ptr _ptr_type;
  typedef AttributeDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_AttributeDef :
  public virtual _objref_Contained
{
public:
  
  CORBA::TypeCode_ptr type();
  IDLType_ptr type_def();
  void type_def(IDLType_ptr);
  AttributeMode mode();
  void mode(AttributeMode);
  
  inline _objref_AttributeDef() { _PR_setobj(0); }  // nil
  _objref_AttributeDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_AttributeDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_AttributeDef(const _objref_AttributeDef&);
  _objref_AttributeDef& operator = (const _objref_AttributeDef&);
  // not implemented
};

class _pof_AttributeDef : public proxyObjectFactory {
public:
  inline _pof_AttributeDef() : proxyObjectFactory(AttributeDef::_PD_repoId) {}
  virtual ~_pof_AttributeDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_AttributeDef :
  public virtual _impl_Contained
{
public:
  virtual ~_impl_AttributeDef();

  virtual CORBA::TypeCode_ptr type() = 0;
  virtual IDLType_ptr type_def() = 0;
  virtual void type_def(IDLType_ptr) = 0;
  virtual AttributeMode mode() = 0;
  virtual void mode(AttributeMode) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_AttributeDef;

struct AttributeDescription {
  typedef _CORBA_ConstrType_Variable_Var<AttributeDescription> _var_type;

  CORBA::String_member name;

  CORBA::String_member id;

  CORBA::String_member defined_in;

  CORBA::String_member version;

  CORBA::TypeCode_member type;

  AttributeMode mode;

  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef AttributeDescription::_var_type AttributeDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< AttributeDescription,AttributeDescription_var > AttributeDescription_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_AttributeDescription;

enum OperationMode { OP_NORMAL, OP_ONEWAY };
typedef OperationMode& OperationMode_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_OperationMode;

enum ParameterMode { PARAM_IN, PARAM_OUT, PARAM_INOUT };
typedef ParameterMode& ParameterMode_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ParameterMode;

struct ParameterDescription {
  typedef _CORBA_ConstrType_Variable_Var<ParameterDescription> _var_type;

  CORBA::String_member name;

  CORBA::TypeCode_member type;

  _CORBA_ObjRef_Member< _objref_IDLType, IDLType_Helper>  type_def;

  ParameterMode mode;

  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef ParameterDescription::_var_type ParameterDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< ParameterDescription,ParameterDescription_var > ParameterDescription_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ParameterDescription;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ParDescriptionSeq;

class ParDescriptionSeq_var;

class ParDescriptionSeq : public _CORBA_Unbounded_Sequence< ParameterDescription>  {
public:
  typedef ParDescriptionSeq_var _var_type;
  inline ParDescriptionSeq() {}
  inline ParDescriptionSeq(const ParDescriptionSeq& s)
    : _CORBA_Unbounded_Sequence< ParameterDescription> (s) {}

  inline ParDescriptionSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< ParameterDescription> (_max) {}
  inline ParDescriptionSeq(_CORBA_ULong _max, _CORBA_ULong _len, ParameterDescription* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< ParameterDescription> (_max, _len, _val, _rel) {}

  inline ParDescriptionSeq& operator = (const ParDescriptionSeq& s) {
    _CORBA_Unbounded_Sequence< ParameterDescription> ::operator=(s);
    return *this;
  }
};

class ParDescriptionSeq_out;

class ParDescriptionSeq_var {
public:
  typedef ParDescriptionSeq T;
  typedef ParDescriptionSeq_var T_var;

  inline ParDescriptionSeq_var() : _pd_seq(0) {}
  inline ParDescriptionSeq_var(T* s) : _pd_seq(s) {}
  inline ParDescriptionSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ParDescriptionSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline ParameterDescription& operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class ParDescriptionSeq_out;

private:
  T* _pd_seq;
};

class ParDescriptionSeq_out {
public:
  typedef ParDescriptionSeq T;
  typedef ParDescriptionSeq_var T_var;

  inline ParDescriptionSeq_out(T*& s) : _data(s) { _data = 0; }
  inline ParDescriptionSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline ParDescriptionSeq_out(const ParDescriptionSeq_out& s) : _data(s._data) {}
  inline ParDescriptionSeq_out& operator = (const ParDescriptionSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline ParDescriptionSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline ParameterDescription& operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  ParDescriptionSeq_out();
  ParDescriptionSeq_out& operator=(const T_var&);
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ContextIdentifier;

typedef char* ContextIdentifier;
typedef CORBA::String_var ContextIdentifier_var;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ContextIdSeq;

class ContextIdSeq_var;

class ContextIdSeq : public _CORBA_Unbounded_Sequence__String {
public:
  typedef ContextIdSeq_var _var_type;
  inline ContextIdSeq() {}
  inline ContextIdSeq(const ContextIdSeq& s)
    : _CORBA_Unbounded_Sequence__String(s) {}

  inline ContextIdSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence__String(_max) {}
  inline ContextIdSeq(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence__String(_max, _len, _val, _rel) {}

  inline ContextIdSeq& operator = (const ContextIdSeq& s) {
    _CORBA_Unbounded_Sequence__String::operator=(s);
    return *this;
  }
};

class ContextIdSeq_out;

class ContextIdSeq_var {
public:
  typedef ContextIdSeq T;
  typedef ContextIdSeq_var T_var;

  inline ContextIdSeq_var() : _pd_seq(0) {}
  inline ContextIdSeq_var(T* s) : _pd_seq(s) {}
  inline ContextIdSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ContextIdSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline _CORBA_String_element operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class ContextIdSeq_out;

private:
  T* _pd_seq;
};

class ContextIdSeq_out {
public:
  typedef ContextIdSeq T;
  typedef ContextIdSeq_var T_var;

  inline ContextIdSeq_out(T*& s) : _data(s) { _data = 0; }
  inline ContextIdSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline ContextIdSeq_out(const ContextIdSeq_out& s) : _data(s._data) {}
  inline ContextIdSeq_out& operator = (const ContextIdSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline ContextIdSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline _CORBA_String_element operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  ContextIdSeq_out();
  ContextIdSeq_out& operator=(const T_var&);
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ExceptionDefSeq;

class ExceptionDefSeq_var;

class ExceptionDefSeq : public _CORBA_Unbounded_Sequence_ObjRef< _objref_ExceptionDef, _CORBA_ObjRef_Element< _objref_ExceptionDef, ExceptionDef_Helper> , ExceptionDef_Helper>  {
public:
  typedef ExceptionDefSeq_var _var_type;
  inline ExceptionDefSeq() {}
  inline ExceptionDefSeq(const ExceptionDefSeq& s)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_ExceptionDef, _CORBA_ObjRef_Element< _objref_ExceptionDef, ExceptionDef_Helper> , ExceptionDef_Helper> (s) {}

  inline ExceptionDefSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_ExceptionDef, _CORBA_ObjRef_Element< _objref_ExceptionDef, ExceptionDef_Helper> , ExceptionDef_Helper> (_max) {}
  inline ExceptionDefSeq(_CORBA_ULong _max, _CORBA_ULong _len, ExceptionDef_ptr* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_ObjRef< _objref_ExceptionDef, _CORBA_ObjRef_Element< _objref_ExceptionDef, ExceptionDef_Helper> , ExceptionDef_Helper> (_max, _len, _val, _rel) {}

  inline ExceptionDefSeq& operator = (const ExceptionDefSeq& s) {
    _CORBA_Unbounded_Sequence_ObjRef< _objref_ExceptionDef, _CORBA_ObjRef_Element< _objref_ExceptionDef, ExceptionDef_Helper> , ExceptionDef_Helper> ::operator=(s);
    return *this;
  }
};

class ExceptionDefSeq_out;

class ExceptionDefSeq_var {
public:
  typedef ExceptionDefSeq T;
  typedef ExceptionDefSeq_var T_var;

  inline ExceptionDefSeq_var() : _pd_seq(0) {}
  inline ExceptionDefSeq_var(T* s) : _pd_seq(s) {}
  inline ExceptionDefSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ExceptionDefSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline _CORBA_ObjRef_Element< _objref_ExceptionDef, ExceptionDef_Helper>  operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class ExceptionDefSeq_out;

private:
  T* _pd_seq;
};

class ExceptionDefSeq_out {
public:
  typedef ExceptionDefSeq T;
  typedef ExceptionDefSeq_var T_var;

  inline ExceptionDefSeq_out(T*& s) : _data(s) { _data = 0; }
  inline ExceptionDefSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline ExceptionDefSeq_out(const ExceptionDefSeq_out& s) : _data(s._data) {}
  inline ExceptionDefSeq_out& operator = (const ExceptionDefSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline ExceptionDefSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline _CORBA_ObjRef_Element< _objref_ExceptionDef, ExceptionDef_Helper>  operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  ExceptionDefSeq_out();
  ExceptionDefSeq_out& operator=(const T_var&);
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ExcDescriptionSeq;

class ExcDescriptionSeq_var;

class ExcDescriptionSeq : public _CORBA_Unbounded_Sequence< ExceptionDescription>  {
public:
  typedef ExcDescriptionSeq_var _var_type;
  inline ExcDescriptionSeq() {}
  inline ExcDescriptionSeq(const ExcDescriptionSeq& s)
    : _CORBA_Unbounded_Sequence< ExceptionDescription> (s) {}

  inline ExcDescriptionSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< ExceptionDescription> (_max) {}
  inline ExcDescriptionSeq(_CORBA_ULong _max, _CORBA_ULong _len, ExceptionDescription* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< ExceptionDescription> (_max, _len, _val, _rel) {}

  inline ExcDescriptionSeq& operator = (const ExcDescriptionSeq& s) {
    _CORBA_Unbounded_Sequence< ExceptionDescription> ::operator=(s);
    return *this;
  }
};

class ExcDescriptionSeq_out;

class ExcDescriptionSeq_var {
public:
  typedef ExcDescriptionSeq T;
  typedef ExcDescriptionSeq_var T_var;

  inline ExcDescriptionSeq_var() : _pd_seq(0) {}
  inline ExcDescriptionSeq_var(T* s) : _pd_seq(s) {}
  inline ExcDescriptionSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ExcDescriptionSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline ExceptionDescription& operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class ExcDescriptionSeq_out;

private:
  T* _pd_seq;
};

class ExcDescriptionSeq_out {
public:
  typedef ExcDescriptionSeq T;
  typedef ExcDescriptionSeq_var T_var;

  inline ExcDescriptionSeq_out(T*& s) : _data(s) { _data = 0; }
  inline ExcDescriptionSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline ExcDescriptionSeq_out(const ExcDescriptionSeq_out& s) : _data(s._data) {}
  inline ExcDescriptionSeq_out& operator = (const ExcDescriptionSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline ExcDescriptionSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline ExceptionDescription& operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  ExcDescriptionSeq_out();
  ExcDescriptionSeq_out& operator=(const T_var&);
};

#ifndef __CORBA_mOperationDef__
#define __CORBA_mOperationDef__

class OperationDef;
class _objref_OperationDef;
class _impl_OperationDef;
typedef _objref_OperationDef* OperationDef_ptr;
typedef OperationDef_ptr OperationDefRef;

class OperationDef_Helper {
public:
  typedef OperationDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_OperationDef, OperationDef_Helper> OperationDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_OperationDef,OperationDef_Helper > OperationDef_out;

#endif

class OperationDef {
public:
  // Declarations for this interface type.
  typedef OperationDef_ptr _ptr_type;
  typedef OperationDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_OperationDef :
  public virtual _objref_Contained
{
public:
  
  CORBA::TypeCode_ptr result();
  IDLType_ptr result_def();
  void result_def(IDLType_ptr);
  ParDescriptionSeq* params();
  void params(const ParDescriptionSeq&);
  OperationMode mode();
  void mode(OperationMode);
  ContextIdSeq* contexts();
  void contexts(const ContextIdSeq&);
  ExceptionDefSeq* exceptions();
  void exceptions(const ExceptionDefSeq&);
  
  inline _objref_OperationDef() { _PR_setobj(0); }  // nil
  _objref_OperationDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_OperationDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_OperationDef(const _objref_OperationDef&);
  _objref_OperationDef& operator = (const _objref_OperationDef&);
  // not implemented
};

class _pof_OperationDef : public proxyObjectFactory {
public:
  inline _pof_OperationDef() : proxyObjectFactory(OperationDef::_PD_repoId) {}
  virtual ~_pof_OperationDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_OperationDef :
  public virtual _impl_Contained
{
public:
  virtual ~_impl_OperationDef();

  virtual CORBA::TypeCode_ptr result() = 0;
  virtual IDLType_ptr result_def() = 0;
  virtual void result_def(IDLType_ptr) = 0;
  virtual ParDescriptionSeq* params() = 0;
  virtual void params(const ParDescriptionSeq&) = 0;
  virtual OperationMode mode() = 0;
  virtual void mode(OperationMode) = 0;
  virtual ContextIdSeq* contexts() = 0;
  virtual void contexts(const ContextIdSeq&) = 0;
  virtual ExceptionDefSeq* exceptions() = 0;
  virtual void exceptions(const ExceptionDefSeq&) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_OperationDef;

struct OperationDescription {
  typedef _CORBA_ConstrType_Variable_Var<OperationDescription> _var_type;

  CORBA::String_member name;

  CORBA::String_member id;

  CORBA::String_member defined_in;

  CORBA::String_member version;

  CORBA::TypeCode_member result;

  OperationMode mode;

  ContextIdSeq contexts;

  ParDescriptionSeq parameters;

  ExcDescriptionSeq exceptions;

  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef OperationDescription::_var_type OperationDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< OperationDescription,OperationDescription_var > OperationDescription_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_OperationDescription;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_RepositoryIdSeq;

class RepositoryIdSeq_var;

class RepositoryIdSeq : public _CORBA_Unbounded_Sequence__String {
public:
  typedef RepositoryIdSeq_var _var_type;
  inline RepositoryIdSeq() {}
  inline RepositoryIdSeq(const RepositoryIdSeq& s)
    : _CORBA_Unbounded_Sequence__String(s) {}

  inline RepositoryIdSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence__String(_max) {}
  inline RepositoryIdSeq(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence__String(_max, _len, _val, _rel) {}

  inline RepositoryIdSeq& operator = (const RepositoryIdSeq& s) {
    _CORBA_Unbounded_Sequence__String::operator=(s);
    return *this;
  }
};

class RepositoryIdSeq_out;

class RepositoryIdSeq_var {
public:
  typedef RepositoryIdSeq T;
  typedef RepositoryIdSeq_var T_var;

  inline RepositoryIdSeq_var() : _pd_seq(0) {}
  inline RepositoryIdSeq_var(T* s) : _pd_seq(s) {}
  inline RepositoryIdSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~RepositoryIdSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline _CORBA_String_element operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class RepositoryIdSeq_out;

private:
  T* _pd_seq;
};

class RepositoryIdSeq_out {
public:
  typedef RepositoryIdSeq T;
  typedef RepositoryIdSeq_var T_var;

  inline RepositoryIdSeq_out(T*& s) : _data(s) { _data = 0; }
  inline RepositoryIdSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline RepositoryIdSeq_out(const RepositoryIdSeq_out& s) : _data(s._data) {}
  inline RepositoryIdSeq_out& operator = (const RepositoryIdSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline RepositoryIdSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline _CORBA_String_element operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  RepositoryIdSeq_out();
  RepositoryIdSeq_out& operator=(const T_var&);
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_OpDescriptionSeq;

class OpDescriptionSeq_var;

class OpDescriptionSeq : public _CORBA_Unbounded_Sequence< OperationDescription>  {
public:
  typedef OpDescriptionSeq_var _var_type;
  inline OpDescriptionSeq() {}
  inline OpDescriptionSeq(const OpDescriptionSeq& s)
    : _CORBA_Unbounded_Sequence< OperationDescription> (s) {}

  inline OpDescriptionSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< OperationDescription> (_max) {}
  inline OpDescriptionSeq(_CORBA_ULong _max, _CORBA_ULong _len, OperationDescription* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< OperationDescription> (_max, _len, _val, _rel) {}

  inline OpDescriptionSeq& operator = (const OpDescriptionSeq& s) {
    _CORBA_Unbounded_Sequence< OperationDescription> ::operator=(s);
    return *this;
  }
};

class OpDescriptionSeq_out;

class OpDescriptionSeq_var {
public:
  typedef OpDescriptionSeq T;
  typedef OpDescriptionSeq_var T_var;

  inline OpDescriptionSeq_var() : _pd_seq(0) {}
  inline OpDescriptionSeq_var(T* s) : _pd_seq(s) {}
  inline OpDescriptionSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~OpDescriptionSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline OperationDescription& operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class OpDescriptionSeq_out;

private:
  T* _pd_seq;
};

class OpDescriptionSeq_out {
public:
  typedef OpDescriptionSeq T;
  typedef OpDescriptionSeq_var T_var;

  inline OpDescriptionSeq_out(T*& s) : _data(s) { _data = 0; }
  inline OpDescriptionSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline OpDescriptionSeq_out(const OpDescriptionSeq_out& s) : _data(s._data) {}
  inline OpDescriptionSeq_out& operator = (const OpDescriptionSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline OpDescriptionSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline OperationDescription& operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  OpDescriptionSeq_out();
  OpDescriptionSeq_out& operator=(const T_var&);
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_AttrDescriptionSeq;

class AttrDescriptionSeq_var;

class AttrDescriptionSeq : public _CORBA_Unbounded_Sequence< AttributeDescription>  {
public:
  typedef AttrDescriptionSeq_var _var_type;
  inline AttrDescriptionSeq() {}
  inline AttrDescriptionSeq(const AttrDescriptionSeq& s)
    : _CORBA_Unbounded_Sequence< AttributeDescription> (s) {}

  inline AttrDescriptionSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< AttributeDescription> (_max) {}
  inline AttrDescriptionSeq(_CORBA_ULong _max, _CORBA_ULong _len, AttributeDescription* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< AttributeDescription> (_max, _len, _val, _rel) {}

  inline AttrDescriptionSeq& operator = (const AttrDescriptionSeq& s) {
    _CORBA_Unbounded_Sequence< AttributeDescription> ::operator=(s);
    return *this;
  }
};

class AttrDescriptionSeq_out;

class AttrDescriptionSeq_var {
public:
  typedef AttrDescriptionSeq T;
  typedef AttrDescriptionSeq_var T_var;

  inline AttrDescriptionSeq_var() : _pd_seq(0) {}
  inline AttrDescriptionSeq_var(T* s) : _pd_seq(s) {}
  inline AttrDescriptionSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~AttrDescriptionSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline AttributeDescription& operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class AttrDescriptionSeq_out;

private:
  T* _pd_seq;
};

class AttrDescriptionSeq_out {
public:
  typedef AttrDescriptionSeq T;
  typedef AttrDescriptionSeq_var T_var;

  inline AttrDescriptionSeq_out(T*& s) : _data(s) { _data = 0; }
  inline AttrDescriptionSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline AttrDescriptionSeq_out(const AttrDescriptionSeq_out& s) : _data(s._data) {}
  inline AttrDescriptionSeq_out& operator = (const AttrDescriptionSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline AttrDescriptionSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline AttributeDescription& operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  AttrDescriptionSeq_out();
  AttrDescriptionSeq_out& operator=(const T_var&);
};

#ifndef __CORBA_mInterfaceDef__
#define __CORBA_mInterfaceDef__

class InterfaceDef;
class _objref_InterfaceDef;
class _impl_InterfaceDef;
typedef _objref_InterfaceDef* InterfaceDef_ptr;
typedef InterfaceDef_ptr InterfaceDefRef;

class InterfaceDef_Helper {
public:
  typedef InterfaceDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_InterfaceDef, InterfaceDef_Helper> InterfaceDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_InterfaceDef,InterfaceDef_Helper > InterfaceDef_out;

#endif

class InterfaceDef {
public:
  // Declarations for this interface type.
  typedef InterfaceDef_ptr _ptr_type;
  typedef InterfaceDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  struct FullInterfaceDescription {
    typedef _CORBA_ConstrType_Variable_Var<FullInterfaceDescription> _var_type;

    CORBA::String_member name;

    CORBA::String_member id;

    CORBA::String_member defined_in;

    CORBA::String_member version;

    OpDescriptionSeq operations;

    AttrDescriptionSeq attributes;

    RepositoryIdSeq base_interfaces;

    CORBA::TypeCode_member type;

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef FullInterfaceDescription::_var_type FullInterfaceDescription_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< FullInterfaceDescription,FullInterfaceDescription_var > FullInterfaceDescription_out;

  static _dyn_attr const CORBA::TypeCode_ptr _tc_FullInterfaceDescription;

};

class _objref_InterfaceDef :
  public virtual _objref_Container,
  public virtual _objref_Contained,
  public virtual _objref_IDLType
{
public:
  CORBA::Boolean is_a(const char* interface_id);
  InterfaceDef::FullInterfaceDescription* describe_interface();
  AttributeDef_ptr create_attribute(const char* id, const char* name, const char* version, IDLType_ptr type, AttributeMode mode);
  OperationDef_ptr create_operation(const char* id, const char* name, const char* version, IDLType_ptr result, OperationMode mode, const ParDescriptionSeq& params, const ExceptionDefSeq& exceptions, const ContextIdSeq& contexts);
  
  InterfaceDefSeq* base_interfaces();
  void base_interfaces(const InterfaceDefSeq&);
  
  inline _objref_InterfaceDef() { _PR_setobj(0); }  // nil
  _objref_InterfaceDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_InterfaceDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_InterfaceDef(const _objref_InterfaceDef&);
  _objref_InterfaceDef& operator = (const _objref_InterfaceDef&);
  // not implemented
};

class _pof_InterfaceDef : public proxyObjectFactory {
public:
  inline _pof_InterfaceDef() : proxyObjectFactory(InterfaceDef::_PD_repoId) {}
  virtual ~_pof_InterfaceDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_InterfaceDef :
  public virtual _impl_Container, 
  public virtual _impl_Contained, 
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_InterfaceDef();

  virtual CORBA::Boolean is_a(const char* interface_id) = 0;
  virtual InterfaceDef::FullInterfaceDescription* describe_interface() = 0;
  virtual AttributeDef_ptr create_attribute(const char* id, const char* name, const char* version, IDLType_ptr type, AttributeMode mode) = 0;
  virtual OperationDef_ptr create_operation(const char* id, const char* name, const char* version, IDLType_ptr result, OperationMode mode, const ParDescriptionSeq& params, const ExceptionDefSeq& exceptions, const ContextIdSeq& contexts) = 0;
  
  virtual InterfaceDefSeq* base_interfaces() = 0;
  virtual void base_interfaces(const InterfaceDefSeq&) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_InterfaceDef;

struct InterfaceDescription {
  typedef _CORBA_ConstrType_Variable_Var<InterfaceDescription> _var_type;

  CORBA::String_member name;

  CORBA::String_member id;

  CORBA::String_member defined_in;

  CORBA::String_member version;

  RepositoryIdSeq base_interfaces;

  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef InterfaceDescription::_var_type InterfaceDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< InterfaceDescription,InterfaceDescription_var > InterfaceDescription_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_InterfaceDescription;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_Visibility;

typedef CORBA::Short Visibility;

_CORBA_MODULE_VARINT const CORBA::Short PRIVATE_MEMBER _init_in_decl_( = 0 );

_CORBA_MODULE_VARINT const CORBA::Short PUBLIC_MEMBER _init_in_decl_( = 1 );

struct ValueMember {
  typedef _CORBA_ConstrType_Variable_Var<ValueMember> _var_type;

  CORBA::String_member name;

  CORBA::String_member id;

  CORBA::String_member defined_in;

  CORBA::String_member version;

  CORBA::TypeCode_member type;

  _CORBA_ObjRef_Member< _objref_IDLType, IDLType_Helper>  type_def;

  Visibility access;

  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef ValueMember::_var_type ValueMember_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< ValueMember,ValueMember_var > ValueMember_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ValueMember;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ValueMemberSeq;

class ValueMemberSeq_var;

class ValueMemberSeq : public _CORBA_Unbounded_Sequence< ValueMember>  {
public:
  typedef ValueMemberSeq_var _var_type;
  inline ValueMemberSeq() {}
  inline ValueMemberSeq(const ValueMemberSeq& s)
    : _CORBA_Unbounded_Sequence< ValueMember> (s) {}

  inline ValueMemberSeq(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< ValueMember> (_max) {}
  inline ValueMemberSeq(_CORBA_ULong _max, _CORBA_ULong _len, ValueMember* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< ValueMember> (_max, _len, _val, _rel) {}

  inline ValueMemberSeq& operator = (const ValueMemberSeq& s) {
    _CORBA_Unbounded_Sequence< ValueMember> ::operator=(s);
    return *this;
  }
};

class ValueMemberSeq_out;

class ValueMemberSeq_var {
public:
  typedef ValueMemberSeq T;
  typedef ValueMemberSeq_var T_var;

  inline ValueMemberSeq_var() : _pd_seq(0) {}
  inline ValueMemberSeq_var(T* s) : _pd_seq(s) {}
  inline ValueMemberSeq_var(const T_var& s) {
    if( s._pd_seq )  _pd_seq = new T(*s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~ValueMemberSeq_var() { if( _pd_seq )  delete _pd_seq; }

  inline T_var& operator = (T* s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = s;
    return *this;
  }
  inline T_var& operator = (const T_var& s) {
    if( s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new T;
      *_pd_seq = *s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }

  inline ValueMember& operator [] (_CORBA_ULong s) {
    return (*_pd_seq)[s];
  }

  inline T* operator -> () { return _pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
  inline operator T& () const { return *_pd_seq; }
#else
  inline operator const T& () const { return *_pd_seq; }
  inline operator T& () { return *_pd_seq; }
#endif

  inline const T& in() const { return *_pd_seq; }
  inline T&       inout()    { return *_pd_seq; }
  inline T*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline T* _retn() { T* tmp = _pd_seq; _pd_seq = 0; return tmp; }

  friend class ValueMemberSeq_out;

private:
  T* _pd_seq;
};

class ValueMemberSeq_out {
public:
  typedef ValueMemberSeq T;
  typedef ValueMemberSeq_var T_var;

  inline ValueMemberSeq_out(T*& s) : _data(s) { _data = 0; }
  inline ValueMemberSeq_out(T_var& s)
    : _data(s._pd_seq) { s = (T*) 0; }
  inline ValueMemberSeq_out(const ValueMemberSeq_out& s) : _data(s._data) {}
  inline ValueMemberSeq_out& operator = (const ValueMemberSeq_out& s) {
    _data = s._data;
    return *this;
  }  inline ValueMemberSeq_out& operator = (T* s) {
    _data = s;
    return *this;
  }
  inline operator T*&()  { return _data; }
  inline T*& ptr()       { return _data; }
  inline T* operator->() { return _data; }

  inline ValueMember& operator [] (_CORBA_ULong i) {
    return (*_data)[i];
  }

  T*& _data;

private:
  ValueMemberSeq_out();
  ValueMemberSeq_out& operator=(const T_var&);
};

#ifndef __CORBA_mValueMemberDef__
#define __CORBA_mValueMemberDef__

class ValueMemberDef;
class _objref_ValueMemberDef;
class _impl_ValueMemberDef;
typedef _objref_ValueMemberDef* ValueMemberDef_ptr;
typedef ValueMemberDef_ptr ValueMemberDefRef;

class ValueMemberDef_Helper {
public:
  typedef ValueMemberDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ValueMemberDef, ValueMemberDef_Helper> ValueMemberDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ValueMemberDef,ValueMemberDef_Helper > ValueMemberDef_out;

#endif

class ValueMemberDef {
public:
  // Declarations for this interface type.
  typedef ValueMemberDef_ptr _ptr_type;
  typedef ValueMemberDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_ValueMemberDef :
  public virtual _objref_Contained
{
public:
  
  CORBA::TypeCode_ptr type();
  IDLType_ptr type_def();
  void type_def(IDLType_ptr);
  Visibility access();
  void access(Visibility);
  
  inline _objref_ValueMemberDef() { _PR_setobj(0); }  // nil
  _objref_ValueMemberDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_ValueMemberDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_ValueMemberDef(const _objref_ValueMemberDef&);
  _objref_ValueMemberDef& operator = (const _objref_ValueMemberDef&);
  // not implemented
};

class _pof_ValueMemberDef : public proxyObjectFactory {
public:
  inline _pof_ValueMemberDef() : proxyObjectFactory(ValueMemberDef::_PD_repoId) {}
  virtual ~_pof_ValueMemberDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_ValueMemberDef :
  public virtual _impl_Contained
{
public:
  virtual ~_impl_ValueMemberDef();

  virtual CORBA::TypeCode_ptr type() = 0;
  virtual IDLType_ptr type_def() = 0;
  virtual void type_def(IDLType_ptr) = 0;
  virtual Visibility access() = 0;
  virtual void access(Visibility) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ValueMemberDef;

#ifndef __CORBA_mValueDef__
#define __CORBA_mValueDef__

class ValueDef;
class _objref_ValueDef;
class _impl_ValueDef;
typedef _objref_ValueDef* ValueDef_ptr;
typedef ValueDef_ptr ValueDefRef;

class ValueDef_Helper {
public:
  typedef ValueDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ValueDef, ValueDef_Helper> ValueDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ValueDef,ValueDef_Helper > ValueDef_out;

#endif

class ValueDef {
public:
  // Declarations for this interface type.
  typedef ValueDef_ptr _ptr_type;
  typedef ValueDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  struct FullValueDescription {
    typedef _CORBA_ConstrType_Variable_Var<FullValueDescription> _var_type;

    CORBA::String_member name;

    CORBA::String_member id;

    CORBA::Boolean is_abstract;

    CORBA::Boolean is_custom;

    CORBA::String_member defined_in;

    CORBA::String_member version;

    OpDescriptionSeq operations;

    AttrDescriptionSeq attributes;

    ValueMemberSeq members;

    InitializerSeq initializers;

    RepositoryIdSeq supported_interfaces;

    RepositoryIdSeq abstract_base_values;

    CORBA::Boolean is_truncatable;

    CORBA::String_member base_value;

    CORBA::TypeCode_member type;

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef FullValueDescription::_var_type FullValueDescription_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< FullValueDescription,FullValueDescription_var > FullValueDescription_out;

  static _dyn_attr const CORBA::TypeCode_ptr _tc_FullValueDescription;

};

class _objref_ValueDef :
  public virtual _objref_Container,
  public virtual _objref_Contained,
  public virtual _objref_IDLType
{
public:
  CORBA::Boolean is_a(const char* id);
  ValueDef::FullValueDescription* describe_value();
  ValueMemberDef_ptr create_value_member(const char* id, const char* name, const char* version, IDLType_ptr type, Visibility access);
  AttributeDef_ptr create_attribute(const char* id, const char* name, const char* version, IDLType_ptr type, AttributeMode mode);
  OperationDef_ptr create_operation(const char* id, const char* name, const char* version, IDLType_ptr result, OperationMode mode, const ParDescriptionSeq& params, const ExceptionDefSeq& exceptions, const ContextIdSeq& contexts);
  
  InterfaceDefSeq* supported_interfaces();
  void supported_interfaces(const InterfaceDefSeq&);
  InitializerSeq* initializers();
  void initializers(const InitializerSeq&);
  ValueDef_ptr base_value();
  void base_value(ValueDef_ptr);
  ValueDefSeq* abstract_base_values();
  void abstract_base_values(const ValueDefSeq&);
  CORBA::Boolean is_abstract();
  void is_abstract(CORBA::Boolean);
  CORBA::Boolean is_custom();
  void is_custom(CORBA::Boolean);
  CORBA::Boolean is_truncatable();
  void is_truncatable(CORBA::Boolean);
  
  inline _objref_ValueDef() { _PR_setobj(0); }  // nil
  _objref_ValueDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_ValueDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_ValueDef(const _objref_ValueDef&);
  _objref_ValueDef& operator = (const _objref_ValueDef&);
  // not implemented
};

class _pof_ValueDef : public proxyObjectFactory {
public:
  inline _pof_ValueDef() : proxyObjectFactory(ValueDef::_PD_repoId) {}
  virtual ~_pof_ValueDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_ValueDef :
  public virtual _impl_Container, 
  public virtual _impl_Contained, 
  public virtual _impl_IDLType
{
public:
  virtual ~_impl_ValueDef();

  virtual CORBA::Boolean is_a(const char* id) = 0;
  virtual ValueDef::FullValueDescription* describe_value() = 0;
  virtual ValueMemberDef_ptr create_value_member(const char* id, const char* name, const char* version, IDLType_ptr type, Visibility access) = 0;
  virtual AttributeDef_ptr create_attribute(const char* id, const char* name, const char* version, IDLType_ptr type, AttributeMode mode) = 0;
  virtual OperationDef_ptr create_operation(const char* id, const char* name, const char* version, IDLType_ptr result, OperationMode mode, const ParDescriptionSeq& params, const ExceptionDefSeq& exceptions, const ContextIdSeq& contexts) = 0;
  
  virtual InterfaceDefSeq* supported_interfaces() = 0;
  virtual void supported_interfaces(const InterfaceDefSeq&) = 0;
  virtual InitializerSeq* initializers() = 0;
  virtual void initializers(const InitializerSeq&) = 0;
  virtual ValueDef_ptr base_value() = 0;
  virtual void base_value(ValueDef_ptr) = 0;
  virtual ValueDefSeq* abstract_base_values() = 0;
  virtual void abstract_base_values(const ValueDefSeq&) = 0;
  virtual CORBA::Boolean is_abstract() = 0;
  virtual void is_abstract(CORBA::Boolean) = 0;
  virtual CORBA::Boolean is_custom() = 0;
  virtual void is_custom(CORBA::Boolean) = 0;
  virtual CORBA::Boolean is_truncatable() = 0;
  virtual void is_truncatable(CORBA::Boolean) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ValueDef;

struct ValueDescription {
  typedef _CORBA_ConstrType_Variable_Var<ValueDescription> _var_type;

  CORBA::String_member name;

  CORBA::String_member id;

  CORBA::Boolean is_abstract;

  CORBA::Boolean is_custom;

  CORBA::String_member defined_in;

  CORBA::String_member version;

  RepositoryIdSeq supported_interfaces;

  RepositoryIdSeq abstract_base_values;

  CORBA::Boolean is_truncatable;

  CORBA::String_member base_value;

  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef ValueDescription::_var_type ValueDescription_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< ValueDescription,ValueDescription_var > ValueDescription_out;

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ValueDescription;

#ifndef __CORBA_mValueBoxDef__
#define __CORBA_mValueBoxDef__

class ValueBoxDef;
class _objref_ValueBoxDef;
class _impl_ValueBoxDef;
typedef _objref_ValueBoxDef* ValueBoxDef_ptr;
typedef ValueBoxDef_ptr ValueBoxDefRef;

class ValueBoxDef_Helper {
public:
  typedef ValueBoxDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_ValueBoxDef, ValueBoxDef_Helper> ValueBoxDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_ValueBoxDef,ValueBoxDef_Helper > ValueBoxDef_out;

#endif

class ValueBoxDef {
public:
  // Declarations for this interface type.
  typedef ValueBoxDef_ptr _ptr_type;
  typedef ValueBoxDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_ValueBoxDef :
  public virtual _objref_TypedefDef
{
public:
  
  IDLType_ptr original_type_def();
  void original_type_def(IDLType_ptr);
  
  inline _objref_ValueBoxDef() { _PR_setobj(0); }  // nil
  _objref_ValueBoxDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_ValueBoxDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_ValueBoxDef(const _objref_ValueBoxDef&);
  _objref_ValueBoxDef& operator = (const _objref_ValueBoxDef&);
  // not implemented
};

class _pof_ValueBoxDef : public proxyObjectFactory {
public:
  inline _pof_ValueBoxDef() : proxyObjectFactory(ValueBoxDef::_PD_repoId) {}
  virtual ~_pof_ValueBoxDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_ValueBoxDef :
  public virtual _impl_TypedefDef
{
public:
  virtual ~_impl_ValueBoxDef();

  virtual IDLType_ptr original_type_def() = 0;
  virtual void original_type_def(IDLType_ptr) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_ValueBoxDef;

#ifndef __CORBA_mAbstractInterfaceDef__
#define __CORBA_mAbstractInterfaceDef__

class AbstractInterfaceDef;
class _objref_AbstractInterfaceDef;
class _impl_AbstractInterfaceDef;
typedef _objref_AbstractInterfaceDef* AbstractInterfaceDef_ptr;
typedef AbstractInterfaceDef_ptr AbstractInterfaceDefRef;

class AbstractInterfaceDef_Helper {
public:
  typedef AbstractInterfaceDef_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_AbstractInterfaceDef, AbstractInterfaceDef_Helper> AbstractInterfaceDef_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_AbstractInterfaceDef,AbstractInterfaceDef_Helper > AbstractInterfaceDef_out;

#endif

class AbstractInterfaceDef {
public:
  // Declarations for this interface type.
  typedef AbstractInterfaceDef_ptr _ptr_type;
  typedef AbstractInterfaceDef_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(CORBA::Object_ptr);
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_AbstractInterfaceDef :
  public virtual _objref_InterfaceDef
{
public:
  
  inline _objref_AbstractInterfaceDef() { _PR_setobj(0); }  // nil
  _objref_AbstractInterfaceDef(const char*, IOP::TaggedProfileList*, omniIdentity*, omniLocalIdentity*);

protected:
  virtual ~_objref_AbstractInterfaceDef();

private:
  virtual void* _ptrToObjRef(const char*);

  _objref_AbstractInterfaceDef(const _objref_AbstractInterfaceDef&);
  _objref_AbstractInterfaceDef& operator = (const _objref_AbstractInterfaceDef&);
  // not implemented
};

class _pof_AbstractInterfaceDef : public proxyObjectFactory {
public:
  inline _pof_AbstractInterfaceDef() : proxyObjectFactory(AbstractInterfaceDef::_PD_repoId) {}
  virtual ~_pof_AbstractInterfaceDef();

  virtual omniObjRef* newObjRef(omniIOR*,
                                omniIdentity*, omniLocalIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_AbstractInterfaceDef :
  public virtual _impl_InterfaceDef
{
public:
  virtual ~_impl_AbstractInterfaceDef();

public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(GIOP_S&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
};

_CORBA_MODULE_VAR _dyn_attr const CORBA::TypeCode_ptr _tc_AbstractInterfaceDef;

#endif

